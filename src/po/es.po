# #-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#
# Mensajes en español para GNU CLISP.
# Copyright (C) 1996 Free Software Foundation, Inc.
# Carlos Linares López <clinares@delicias.dia.fi.upm.es>, 1997.
#
# Han contribuido a esta traducción:
#
# cll - Carlos Linares López 	(Traducción)
# sv  - Santiago Vila Doncel	(Revisión)
# lsg - Leonardo Sarasúa García	(Traducción y Revisión)
#
# Agradecimientos especiales a:
#
# Bruno Haible
# Marcus Daniels
# 					(Programadores de CLisp)
#
# Enrique Melero
# 				    (Coordinador de Spanish GNU)
#
# Por haber atendido siempre mis preguntas y por mostrar tanto interés
# en esta traducción.
#
# Asimismo, quisiera expresar mi agradecimiento a las siguientes
# personas, por responder pacientemente todas mis preguntas: Joerg
# Hoehle (traductor de la versión francesa) y Juan Jordana.
#
# Por último, a toda la lista de Spanish GNU Translation Team
# (es@li.org) por sus sugerencias.
#
# NOTAS.
#
# * Los mensajes en los que se han realizado anotaciones de interés,
# bien porque haya alguna duda, bien porque contenga notas importantes
# relativas a las traducciones tienen la palabra `Duda:' al principio de
# su comentario.
#
# * Por favor, si alguien realiza alguna modificación a este archivo que
# ponga sus iniciales al final del comentario explicando el cambio y el
# motivo. Si su nombre no está en esta cabecera que lo añada poniendo
# las iniciales.
#
# * Todas las líneas que comienzan con #~ son mensajes obsoletos que no
# hace falta revisar. En cualquier caso, intentaré normalmente
# eliminarlas.
#
# $Id: es.po,v 1.33 2008/05/15 14:14:18 sds Exp $
# $Log: es.po,v $
# Revision 1.33  2008/05/15 14:14:18  sds
# 2.45 final
#
# Revision 1.32  2008/05/14 16:09:23  sds
# regenerated for 2.45 (2008-05-15)
#
# Revision 1.31  2008/05/09 18:00:58  sds
# regenerated
#
# Revision 1.30  2008/05/06 20:56:45  sds
# regenerated
#
# Revision 1.29  2008/05/02 19:14:31  sds
# regenerated
#
# Revision 1.28  2008/01/29 19:39:59  sds
# regenerated for 2.44
#
# Revision 1.27  2007/11/18 16:24:00  sds
# regenerated for 2.43
#
# Revision 1.26  2007/11/02 18:43:11  sds
# 2.43
#
# Revision 1.25  2007/10/12 19:24:51  sds
# regenerated for 2.41.1 pretest
#
# Revision 1.24  2006/10/13 04:10:53  sds
# clisp 2.41 release (Friday the 13th!)
#
# Revision 1.23  2006/10/01 16:13:06  sds
# 2.40 (2006-09-23)
#
# Revision 1.22  2006/07/14 15:45:47  sds
# regenerated for 2.39
#
# Revision 1.21  2006/01/24 15:55:42  sds
# regenerated for clisp 2.38 release
#
# Revision 1.20  2006/01/02 17:09:36  sds
# regenerated for 2.37 (2006-01-02)
#
# Revision 1.19  2005/12/04 22:37:32  sds
# regenerated for clisp 2.36 release
#
# Revision 1.18  2005/08/29 18:18:56  sds
# regenerated
#
# Revision 1.17  2005/08/28 16:27:17  sds
# regenerated
#
# Revision 1.16  2005/07/20 23:58:29  sds
# clisp 2.34 (2005-07-20)
#
# Revision 1.15  2005/07/13 19:11:34  sds
# regenerated for 2.33.84
#
# Revision 1.14  2005/07/06 17:05:52  sds
# regenerated
#
# Revision 1.13  2005/06/27 15:30:42  sds
# regenerated
#
# Revision 1.12  2005/03/17 23:14:48  sds
# regenerated
#
# Revision 1.11  2005/02/16 22:30:56  haible
# Regenerated.
#
# Revision 1.10  2004/12/10 16:11:18  sds
# GNU CLISP 2.33.80 (2004-11-27)
#
# Revision 1.9  2004/03/31 12:48:41  haible
# Update after change of format string convention: '~' -> '~S', '$' -> '~C'.
#
# Revision 1.8  2004/03/31 12:07:14  haible
# msgmerged.
#
# Revision 1.7  2004/03/31 11:52:39  haible
# Update for removal of leading and trailing newlines.
#
# Revision 1.6  2004/03/30 20:38:21  haible
# msgmerged.
#
# Revision 1.5  2004/03/17 20:47:07  sds
# regenerated for 2.33
#
# Revision 1.4  2004/03/14 17:27:54  sds
# regenerated for 2.32.94
#
# Revision 1.3  2004/03/12 19:22:47  sds
# regenerated for 2.32.93
#
# Revision 1.2  2002/09/13 15:00:36  sds
# regenerated for 2.30
#
# Revision 1.1  2002/05/18 14:27:46  sds
# kill src/gettext; POs are now in src/po
#
# Revision 1.12  1998/09/07 18:21:38  clinares
# Traducción de todos los mensajes para la versión del 29-8-1998. Estos
# cambios, sin embargo, serán publicados en alguna nueva versión de
# septiembre de este mismo año.
#
# Revision 1.9  1997/09/18 13:36:38  clinares
# He incluído nuevas modificaciones de Leo Sarasúa.
#
# Entre las más representativas está el hecho de haber modificado
# `trama' por `marco' y `# macro carácter' por `macro carácter
# secundario'. Nuevamente gracias, Leo, ...
#
# Revision 1.8  1997/09/05 17:23:30  clinares
# He introducido todas las modificaciones propuestas por Santiago Vila a
# la versión 1.6. Además, las he adaptado para el nuevo .pot que se
# empleó en la versión 1.7.
#
# Entre los cambios más importantes está: `command' es `orden', no
# `comando'; `warning' es, preferiblemente, `atención' y, en otro caso,
# propongo que sea `advertencia', en vez de `aviso'.
#
# Revision 1.7  1997/09/03 17:51:44  clinares
# He modificado la traducción de las directivas ~P, puesto que nunca se
# escribirán versiones en español de ellas, ya que el estándar Common
# Lisp - The Language es muy específico: solo en inglés. Ni en alemán,
# ni francés, ni español, ...
#
# Además, he adaptado los cambios del POT de la versión 1.6
# (POT-Creation-Date: 1997-05-04) a la última versión que existe
# actualmente (POT-Creation-Date: 1997-09-02). Para ello, he traducido 9
# mensajes nuevos, he corregido los mensajes difusos y he borrado todos
# los obsoletos.
#
# Revision 1.6  1997/08/30 14:04:08  clinares
# El 100% de los mensajes están traducidos :)
# En total, 9 meses de trabajo (es decir, aha sido un parto!! :)
#
# Revision 1.5  1997/08/27 00:48:46  clinares
# Esta es la traducción que resulta de programar todos los cambios
# propuestos por lsg (Leonardo Sarasúa García). En total, aalrededor de
# 800 líneas!!, ahí es nada :)
#
# Muchísimas gracias, Leo. Te debo la cerveza más grande del mundo, ...
#
# ------------------------------------------------------------------
# msgfmt --statistics -c -v -o /dev/null /home/clinares/GNU/clisp.po
# 1406 mensajes traducidos.
# ------------------------------------------------------------------
#
# #-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#
# Mensajes en español para GNU CLISP.
# Copyright (C) 1996 Free Software Foundation, Inc.
# Carlos Linares López <clinares@delicias.dia.fi.upm.es>, 1997.
#
# Han contribuido a esta traducción:
#
# cll - Carlos Linares López 	(Traducción)
# sv  - Santiago Vila Doncel	(Revisión)
# lsg - Leonardo Sarasúa García	(Traducción y Revisión)
#
# Agradecimientos especiales a:
#
# Bruno Haible
# Marcus Daniels
# 					(Programadores de CLisp)
#
# Enrique Melero
# 				    (Coordinador de Spanish GNU)
#
# Por haber atendido siempre mis preguntas y por mostrar tanto interés
# en esta traducción.
#
# Asimismo, quisiera expresar mi agradecimiento a las siguientes
# personas, por responder pacientemente todas mis preguntas: Joerg
# Hoehle (traductor de la versión francesa) y Juan Jordana.
#
# Por último, a toda la lista de Spanish GNU Translation Team
# (es@li.org) por sus sugerencias.
#
# NOTAS.
#
# * Los mensajes en los que se han realizado anotaciones de interés,
# bien porque haya alguna duda, bien porque contenga notas importantes
# relativas a las traducciones tienen la palabra `Duda:' al principio de
# su comentario.
#
# * Por favor, si alguien realiza alguna modificación a este archivo que
# ponga sus iniciales al final del comentario explicando el cambio y el
# motivo. Si su nombre no está en esta cabecera que lo añada poniendo
# las iniciales.
#
# * Todas las líneas que comienzan con #~S son mensajes obsoletos que no
# hace falta revisar. En cualquier caso, intentaré normalmente
# eliminarlas.
#
# $Id: es.po,v 1.33 2008/05/15 14:14:18 sds Exp $
# $Log: es.po,v $
# Revision 1.33  2008/05/15 14:14:18  sds
# 2.45 final
#
# Revision 1.32  2008/05/14 16:09:23  sds
# regenerated for 2.45 (2008-05-15)
#
# Revision 1.31  2008/05/09 18:00:58  sds
# regenerated
#
# Revision 1.30  2008/05/06 20:56:45  sds
# regenerated
#
# Revision 1.29  2008/05/02 19:14:31  sds
# regenerated
#
# Revision 1.28  2008/01/29 19:39:59  sds
# regenerated for 2.44
#
# Revision 1.27  2007/11/18 16:24:00  sds
# regenerated for 2.43
#
# Revision 1.26  2007/11/02 18:43:11  sds
# 2.43
#
# Revision 1.25  2007/10/12 19:24:51  sds
# regenerated for 2.41.1 pretest
#
# Revision 1.24  2006/10/13 04:10:53  sds
# clisp 2.41 release (Friday the 13th!)
#
# Revision 1.23  2006/10/01 16:13:06  sds
# 2.40 (2006-09-23)
#
# Revision 1.22  2006/07/14 15:45:47  sds
# regenerated for 2.39
#
# Revision 1.21  2006/01/24 15:55:42  sds
# regenerated for clisp 2.38 release
#
# Revision 1.20  2006/01/02 17:09:36  sds
# regenerated for 2.37 (2006-01-02)
#
# Revision 1.19  2005/12/04 22:37:32  sds
# regenerated for clisp 2.36 release
#
# Revision 1.18  2005/08/29 18:18:56  sds
# regenerated
#
# Revision 1.17  2005/08/28 16:27:17  sds
# regenerated
#
# Revision 1.16  2005/07/20 23:58:29  sds
# clisp 2.34 (2005-07-20)
#
# Revision 1.15  2005/07/13 19:11:34  sds
# regenerated for 2.33.84
#
# Revision 1.14  2005/07/06 17:05:52  sds
# regenerated
#
# Revision 1.13  2005/06/27 15:30:42  sds
# regenerated
#
# Revision 1.12  2005/03/17 23:14:48  sds
# regenerated
#
# Revision 1.11  2005/02/16 22:30:56  haible
# Regenerated.
#
# Revision 1.10  2004/12/10 16:11:18  sds
# GNU CLISP 2.33.80 (2004-11-27)
#
# Revision 1.9  2004/03/31 12:48:41  haible
# Update after change of format string convention: '~' -> '~S', '$' -> '~C'.
#
# Revision 1.8  2004/03/31 12:07:14  haible
# msgmerged.
#
# Revision 1.7  2004/03/31 11:52:39  haible
# Update for removal of leading and trailing newlines.
#
# Revision 1.6  2004/03/30 20:38:21  haible
# msgmerged.
#
# Revision 1.5  2004/03/17 20:47:07  sds
# regenerated for 2.33
#
# Revision 1.4  2004/03/14 17:27:54  sds
# regenerated for 2.32.94
#
# Revision 1.3  2004/03/12 19:22:47  sds
# regenerated for 2.32.93
#
# Revision 1.2  2002/09/13 15:00:36  sds
# regenerated for 2.30
#
# Revision 1.1  2002/05/18 14:27:46  sds
# kill src/gettext; POs are now in src/po
#
# Revision 1.12  1998/09/07 18:21:38  clinares
# Traducción de todos los mensajes para la versión del 29-8-1998. Estos
# cambios, sin embargo, serán publicados en alguna nueva versión de
# septiembre de este mismo año.
#
# Revision 1.9  1997/09/18 13:36:38  clinares
# He incluído nuevas modificaciones de Leo Sarasúa.
#
# Entre las más representativas está el hecho de haber modificado
# `trama' por `marco' y `# macro carácter' por `macro carácter
# secundario'. Nuevamente gracias, Leo, ...
#
# Revision 1.8  1997/09/05 17:23:30  clinares
# He introducido todas las modificaciones propuestas por Santiago Vila a
# la versión 1.6. Además, las he adaptado para el nuevo .pot que se
# empleó en la versión 1.7.
#
# Entre los cambios más importantes está: `command' es `orden', no
# `comando'; `warning' es, preferiblemente, `atención' y, en otro caso,
# propongo que sea `advertencia', en vez de `aviso'.
#
# Revision 1.7  1997/09/03 17:51:44  clinares
# He modificado la traducción de las directivas ~SP, puesto que nunca se
# escribirán versiones en español de ellas, ya que el estándar Common
# Lisp - The Language es muy específico: solo en inglés. Ni en alemán,
# ni francés, ni español, ...
#
# Además, he adaptado los cambios del POT de la versión 1.6
# (POT-Creation-Date: 1997-05-04) a la última versión que existe
# actualmente (POT-Creation-Date: 1997-09-02). Para ello, he traducido 9
# mensajes nuevos, he corregido los mensajes difusos y he borrado todos
# los obsoletos.
#
# Revision 1.6  1997/08/30 14:04:08  clinares
# El 100% de los mensajes están traducidos :)
# En total, 9 meses de trabajo (es decir, aha sido un parto!! :)
#
# Revision 1.5  1997/08/27 00:48:46  clinares
# Esta es la traducción que resulta de programar todos los cambios
# propuestos por lsg (Leonardo Sarasúa García). En total, aalrededor de
# 800 líneas!!, ahí es nada :)
#
# Muchísimas gracias, Leo. Te debo la cerveza más grande del mundo, ...
#
# ------------------------------------------------------------------
# msgfmt --statistics -c -v -o /dev/null /home/clinares/GNU/clisp.po
# 1406 mensajes traducidos.
# ------------------------------------------------------------------
#
msgid ""
msgstr ""
"Project-Id-Version: GNU clisp 1996-03-31\n"
"Report-Msgid-Bugs-To: clisp-devel@lists.sourceforge.net\n"
"POT-Creation-Date: 2008-05-15 10:12:29-0400\n"
"PO-Revision-Date: 1997-08-11 18:16 MET DST\n"
"Last-Translator: Carlos Linares López <clinares@delicias.dia.fi.upm.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: spvw.d:423
msgid "could not make symbol value per-thread"
msgstr ""

# "*** - desbordamiento de la pila del programa - REINICIALIZANDO" - lsg
#
# En mi opinión, RESET debe traducirse como un imperativo - cll
#
#: spvw.d:482
msgid "*** - Program stack overflow. RESET"
msgstr "*** - Desbordamiento de la pila del programa. REINICIE"

# ¡ Toma puntilloso que soy! Lisp debería escribirse con mayúscula.
# "*** - desbordamiento de la pila de Lisp - REINICIALIZANDO" - lsg
#
# No, no, nada de REINICIALIZANDO. Debe ser un imperativo: REINICIE.
# Por ejemplo, si durante una sesión con CLisp haces:
#
# > (defun foo (a) (foo (1- a)))
# FOO
# > (foo 2)
#
# *** - Desbordamiento de la pila de Lisp. REINICIE
# >
#
# ..., pero el intérprete se queda esperando a que tú sigas tecleando,
# es decir, él solo no se pone a reiniciar nada, ...
#
# Por otra parte, tienes toda la razón, Lisp debe ir con mayúsculas :) - cll
#
#: spvw.d:497
msgid "*** - Lisp stack overflow. RESET"
msgstr "*** - Desbordamiento de la pila de Lisp. REINICIE"

#: spvw.d:620
#, fuzzy, lisp-format
msgid "~S: malloc() failed"
msgstr "mprotect() falló."

#: spvw.d:631
#, fuzzy, lisp-format
msgid "~S: realloc() failed"
msgstr "mprotect() falló."

#
# Muy bueno el apunte sobre ese acento en "cómo". Gracias, Santiago - cll
#
#: spvw.d:661
#, fuzzy, lisp-format
msgid ""
"Internal error: statement in file ~S, line ~S has been reached!!\n"
"Please see <http://clisp.cons.org/impnotes/faq.html#faq-bugs> for bug reporting instructions."
msgstr ""
"error interno: aen la sentencia del fichero ~S, línea ~S!!\n"
"¡Por favor, envíe a los autores del programa una descripción de cómo\n"
"se produjo este error!"

# ß¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:712
#, fuzzy
msgid "Unknown FSUBR signature: %d %d %d\n"
msgstr "Tipo de argumento desconocido para SUBR\n"

# ß¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:820
#, fuzzy
msgid "Unknown SUBR signature: %d %d %d %d"
msgstr "Tipo de argumento desconocido para SUBR\n"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:1551
#, fuzzy
msgid "module '%s' requires package %s.\n"
msgstr "el módulo `%s' necesita el paquete %s.\n"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:1561
#, fuzzy
msgid "module '%s' redefines symbol "
msgstr "el módulo `%s' necesita el paquete %s.\n"

#: spvw.d:1563
#, fuzzy
msgid " in the locked package "
msgstr "un paquete borrado."

# Sugerencia: definición de macro. sv
#
# Hmmm, ..., lo de macro definición es bastante típico en informática
# (ya sabes, ...) Sin embargo, en Lisp se suele decir definición de
# macro, tal y como tú propones, ..., pues vale, ¡sugerencia
# completamente aceptada! cll
#
#: spvw.d:1565
#, fuzzy
msgid ""
"\n"
"old definition: "
msgstr " con definición de macro"

#: spvw.d:1602
msgid "is an ANSI Common Lisp implementation."
msgstr ""

#: spvw.d:1604
msgid "Usage:  "
msgstr ""

#: spvw.d:1606
msgid ""
" [options] [lispfile [argument ...]]\n"
" When 'lispfile' is given, it is loaded and '*ARGS*' is set\n"
" to the list of argument strings. Otherwise, an interactive\n"
" read-eval-print loop is entered.\n"
msgstr ""

#: spvw.d:1610
msgid "Informative output:\n"
msgstr ""

#: spvw.d:1611
msgid " -h, --help    - print this help and exit\n"
msgstr ""

#: spvw.d:1612
msgid " --version     - print the version information\n"
msgstr ""

#: spvw.d:1613
msgid " --license     - print the licensing information\n"
msgstr ""

#: spvw.d:1614
msgid " -help-image   - print image-specific help and exit\n"
msgstr ""

#: spvw.d:1615
msgid "Memory image selection:\n"
msgstr ""

#: spvw.d:1616
msgid " -B lisplibdir - set the installation directory\n"
msgstr ""

#: spvw.d:1618
msgid " -K linkingset - use this executable and memory image\n"
msgstr ""

#: spvw.d:1620
msgid " -M memfile    - use this memory image\n"
msgstr ""

#: spvw.d:1621
msgid " -m size       - memory size (size = nB or nKB or nMB)\n"
msgstr ""

#: spvw.d:1623
msgid " -t tmpdir     - temporary directory for memmap\n"
msgstr ""

#: spvw.d:1625
msgid "Internationalization:\n"
msgstr ""

#: spvw.d:1626
msgid " -L language   - set user language\n"
msgstr ""

#: spvw.d:1627
msgid " -N nlsdir     - NLS catalog directory\n"
msgstr ""

#: spvw.d:1628
msgid " -Edomain encoding - set encoding\n"
msgstr ""

#: spvw.d:1629
msgid "Interoperability:\n"
msgstr ""

#: spvw.d:1630
msgid ""
" -q, --quiet, --silent, -v, --verbose - verbosity level:\n"
"     affects banner, *LOAD-VERBOSE*/*COMPILE-VERBOSE*,\n"
"     and *LOAD-PRINT*/*COMPILE-PRINT*\n"
msgstr ""

#: spvw.d:1633
msgid " -w            - wait for a keypress after program termination\n"
msgstr ""

#: spvw.d:1634
msgid " -I            - be ILISP-friendly\n"
msgstr ""

#: spvw.d:1635
msgid "Startup actions:\n"
msgstr ""

#: spvw.d:1636
msgid " -ansi         - more ANSI CL compliance\n"
msgstr ""

#: spvw.d:1637
msgid " -traditional  - traditional (undoes -ansi)\n"
msgstr ""

#: spvw.d:1638
msgid " -modern       - start in a case-sensitive lowercase-preferring package\n"
msgstr ""

#: spvw.d:1639
msgid " -p package    - start in the package\n"
msgstr ""

#: spvw.d:1640
msgid " -C            - set *LOAD-COMPILING* to T\n"
msgstr ""

#: spvw.d:1641
msgid " -norc         - do not load the user ~/.clisprc file\n"
msgstr ""

#: spvw.d:1642
msgid " -lp dir       - add dir to *LOAD-PATHS* (can be repeated)\n"
msgstr ""

#: spvw.d:1643
msgid " -i file       - load initfile (can be repeated)\n"
msgstr ""

#: spvw.d:1644
msgid "Actions:\n"
msgstr ""

#: spvw.d:1645
msgid " -c [-l] lispfile [-o outputfile] - compile lispfile\n"
msgstr ""

#: spvw.d:1646
msgid " -x expressions - execute the expressions, then exit\n"
msgstr ""

#: spvw.d:1647
msgid " Depending on the image, positional arguments can mean:\n"
msgstr ""

#: spvw.d:1648
msgid "   lispscript [argument ...] - load script, then exit\n"
msgstr ""

#: spvw.d:1649
msgid "   [argument ...]            - run the init-function\n"
msgstr ""

#: spvw.d:1650
msgid "  arguments are placed in EXT:*ARGS* as strings.\n"
msgstr ""

#: spvw.d:1651
msgid "These actions put CLISP into a batch mode, which is overridden by\n"
msgstr ""

#: spvw.d:1652
msgid " -on-error action - action can be one of debug, exit, abort, appease\n"
msgstr ""

#: spvw.d:1653
msgid " -repl            - enter the interactive read-eval-print loop when done\n"
msgstr ""

#: spvw.d:1654
msgid "Default action is an interactive read-eval-print loop.\n"
msgstr ""

#: spvw.d:1663
msgid "%s: use '-h' for help"
msgstr ""

# ¿Por qué no inválido? La palabra existe.
# Un día os tengo que enviar un trozo de "1984" de Orwell,
# que habla de "neolengua", el único idioma del mundo que tiene
# cada vez menos palabras, en vez de más... sv
#
# a¡Por supuestísimo!!! Tienes toda la razón del mundo. De hecho, si
# echas un ojo al resto de los mensajes verás que yo siempre he
# traducido "invalid" por "inválido" salvo en tres ocasiones: en dos
# preferí la expresión "no es correcto" y en la otra lo dejé como "no es
# válido" en vez de "no válido" que, además, suena horrible.
#
# A propósito del trozo de "1984", venga, ya estoy esperando :) - cll
#
#: spvw.d:1666
#, fuzzy
msgid "invalid argument"
msgstr "Argumento inválido"

#: spvw.d:1806
msgid "Welcome to"
msgstr ""

#: spvw.d:1812
msgid "Type :h and hit Enter for context help."
msgstr ""

#: spvw.d:1966
msgid "Syntax for %s: nnnnnnn or nnnnKB or nMB"
msgstr "Sintaxis de %s: nnnnnnn or nnnnKB or nMB"

#: spvw.d:1972
msgid "warning: %s %lu too small, using %lu instead"
msgstr ""

#: spvw.d:1978
msgid "warning: %s %lu too large, using %lu instead"
msgstr ""

#: spvw.d:2116
msgid "memory size"
msgstr "tamaño de memoria"

#: spvw.d:2132
msgid "multiple -t"
msgstr ""

#: spvw.d:2152
msgid "multiple -B"
msgstr ""

#: spvw.d:2187
#, fuzzy
msgid "-E requires an argument"
msgstr "~S argumentos obligatorios"

#: spvw.d:2460
msgid "-l without -c is invalid"
msgstr ""

# Duda: En este mensaje, el primer "~S" se sustituye por el nombre de una
# función y el segundo "~S" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: spvw.d:2466
#, fuzzy
msgid "-x with -c is invalid"
msgstr "~S no es posible sobre el flujo ~S"

#: spvw.d:2471
msgid "-x with lisp-file is invalid"
msgstr ""

#: spvw.d:2604
#, fuzzy
msgid "Return value of malloc() = %lx is not compatible with type code distribution."
msgstr "El valor devuelto por malloc() = %x no es compatible con la distribución del código de tipo."

# solo es con acento.
# "sólo %d bytes disponibles\n" - lsg
#
# aMadre mía!! Tienes toda la razón del mundo - cll :)
#
#: spvw.d:2611
#, fuzzy
msgid "Only %ld bytes available."
msgstr "Sólo quedan %d bytes disponibles."

# Duda: Imagino que SP es el "Stack Pointer". Pero entonces, ¿a qu
# viene decir "SP stack"? ¿Se referirán con ello a la pila del sistema?
# - cll
#
#: spvw.d:2865
msgid "Could not determine the end of the SP stack!"
msgstr "No fue posible determinar el final de la pila SP!"

# "AVISO: No se ha especificado un fichero de inicializacion.\n" - lsg
#
# El mensaje inglés está en pretérito (specified) por eso yo he
# preferido poner "especificó" en vez de "ha especificado" - cll
#
# Pero Carlos, se ha especificado, es también pretérito,
# pretérito perfecto (compuesto), pero pretérito a fin de cuentas.
# No se ha especificado está más en la línea los demás
# mensajes de los otros ficheros .po. sv
#
# Vale, vale, ... La verdad es que a mí las dos me suenan igual de bien,
# de modo que, a tenor de la voluntad popular (dos votos contra uno),
# pues se pone como propuso Leo - cll
#
# Otra nota de interés es la siguiente: he cambiado "aviso" por
# "atención". Creo que así suena mejor. Sugerencia de Santiago - cll
#
#: spvw.d:3023
msgid "WARNING: No initialization file specified."
msgstr "ATENCIÓN: No se ha especificado ningún fichero de inicialización."

#: spvw.d:3025 spvw.d:3037
msgid "Please try: "
msgstr "Por favor, intente:"

# "AVISO: No se ha especificado un fichero de inicializacion.\n" - lsg
#
# El mensaje inglés está en pretérito (specified) por eso yo he
# preferido poner "especificó" en vez de "ha especificado" - cll
#
# Pero Carlos, se ha especificado, es también pretérito,
# pretérito perfecto (compuesto), pero pretérito a fin de cuentas.
# No se ha especificado está más en la línea los demás
# mensajes de los otros ficheros .po. sv
#
# Vale, vale, ... La verdad es que a mí las dos me suenan igual de bien,
# de modo que, a tenor de la voluntad popular (dos votos contra uno),
# pues se pone como propuso Leo - cll
#
# Otra nota de interés es la siguiente: he cambiado "aviso" por
# "atención". Creo que así suena mejor. Sugerencia de Santiago - cll
#
#: spvw.d:3035
#, fuzzy
msgid "WARNING: No installation directory specified."
msgstr "ATENCIÓN: No se ha especificado ningún fichero de inicialización."

#: spvw.d:3098
msgid "All positional arguments are put into "
msgstr ""

#: spvw.d:3100
msgid ""
"The first positional argument is the script name,\n"
"the rest are put into "
msgstr ""

#: spvw.d:3221
msgid "WARNING: no such package: "
msgstr ""

#: spvw.d:3440
#, fuzzy
msgid "%s: Not enough memory for Lisp."
msgstr "No hay memoria suficiente para Lisp."

#: spvw.d:3515
msgid "Bye."
msgstr "Adiós."

#: spvw.d:3521
msgid "Press a key to terminate..."
msgstr ""

# "*** - Memoria virtual agotada. REINICIALIZACION " - lsg
#
# Yo creo que el mensaje debe acabar en un imperativo: REINICIALIZAR - cll
#
#: spvw_alloca.d:48
msgid "*** - Virtual memory exhausted. RESET"
msgstr "*** - Memoria virtual agotada. REINICIE"

# "*** - Memoria agotada. REINICIALIZACION " - lsg
#
# Más de lo mismo - cll
#
#: spvw_alloca.d:50
msgid "*** - Memory exhausted. RESET"
msgstr "*** - Memoria agotada. REINICIE"

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:64 spvw_mmap.d:192 spvw_mmap.d:351 spvw_multimap.d:160
#, fuzzy
msgid "Cannot map memory to address 0x%lx ."
msgstr "No se puede asignar la memoria a la dirección 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:165
#, fuzzy
msgid "Cannot reserve address range at 0x%lx ."
msgstr "No se puede reservar el rango de direcciones a 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:175
#, fuzzy
msgid "Cannot reserve address range 0x%lx-0x%lx ."
msgstr "No se puede reservar el rango de direcciones 0x%x-0x%x ."

#: spvw_mmap.d:219
msgid "CreateFileMapping() failed."
msgstr "CreateFileMapping() falló."

#: spvw_mmap.d:227
msgid "MapViewOfFileEx(addr=0x%x,off=0x%x) failed."
msgstr "MapViewOfFileEx(dirección=0x%x,segmento=0x%x) falló."

#: spvw_mmap.d:233
msgid "MapViewOfFileEx() returned 0x%x instead of 0x%x."
msgstr "MapViewOfFileEx() devolvió 0x%x en vez de 0x%x."

#: spvw_mmap.d:248
msgid "VirtualFree() failed."
msgstr "VirtualFree() falló."

#: spvw_mmap.d:261
msgid "VirtualProtect() failed."
msgstr "VirtualProtect() falló."

#: spvw_mmap.d:331 spvw_multimap.d:115 spvw_multimap.d:187
#, fuzzy
msgid "Cannot open <%s>."
msgstr "No se puede abrir %s."

# "msync(0x%x,0x%x,MS_INVALIDATE) fracasó." - lsg
#
# O "falló" en vez de "fracasó". ¿Qué te parece? - cll
#
#: spvw_multimap.d:139
#, fuzzy
msgid "msync(0x%lx,0x%x,MS_INVALIDATE) failed."
msgstr "msync(0x%x,0x%x,MS_INVALIDATE) falló."

#: spvw_multimap.d:196
#, fuzzy
msgid "Cannot delete <%s>."
msgstr "No se puede borrar %s ."

# He seguido la propuesta de Santiago Vila. A partir de ahora, y siempre
# que sea posible, el término "warning" se traducirá por "atención". En
# aquellos casos en que esto no es posible, lo he indicado
# explícitamente con un comentario indicando el motivo. - cll
#
#: spvw_multimap.d:214
#, fuzzy
msgid "** WARNING: ** Too little free disk space for <%s>."
msgstr "** ATENCIÓN: ** Hay muy poco espacio libre en disco para %s ."

#: spvw_multimap.d:216
#, fuzzy
msgid "Please restart LISP with less memory (option -m)."
msgstr "Por favor, vuelva a ejecutar LISP con menos memoria (opción -m)."

#: spvw_multimap.d:225
#, fuzzy
msgid "Cannot make <%s> long enough."
msgstr "No es posible agrandar %s lo suficiente."

#: spvw_multimap.d:239
#, fuzzy
msgid "Cannot fill <%s>."
msgstr "No se puede rellenar %s ."

#: spvw_multimap.d:252 spvw_multimap.d:285
#, fuzzy
msgid "Cannot close <%s>."
msgstr "No se puede cerrar %s ."

#
# Muy buena tu sugerencia, Leo. Se queda tal y como tu propones - lsg
#
# ¿Apoyo o soporte? sv
#
# Bueno, si, tienes razón. De hecho ésta era una de esas traducciones
# "raras". El problema es que no estaba seguro de que el término
# "soporte" fuese aceptado. Pero si es así, pues perfecto - cll
#
#: spvw_multimap.d:322
msgid "Recompile your operating system with SYSV IPC support."
msgstr "Recompile su sistema operativo con soporte para SYSV IPC."

#
# "no se puede asignar un segmento privado en la memoria compartida" - lsg
#
#: spvw_multimap.d:335
#, fuzzy
msgid "Cannot allocate private shared memory segment of size %d."
msgstr "No se puede asignar un segmento privado en la memoria compartida."

#: spvw_multimap.d:349
#, fuzzy
msgid "Cannot map shared memory to address 0x%lx."
msgstr "No se puede asignar la memoria compartida a la direccion 0x%x."

#: spvw_multimap.d:364 spvw_multimap.d:370
#, fuzzy
msgid "%s: Cannot fill shared memory."
msgstr "No se puede rellenar la memoria compartida."

#
# En este y en otros tantos mensajes, he seguido tu consejo, Leo. He
# traducido `remove' por `desechar' en todos los sitios. - cll
#
#: spvw_multimap.d:383
msgid "Cannot remove shared memory segment."
msgstr "No se puede desechar el segmento de memoria compartida."

#: spvw_fault.d:283
#, fuzzy
msgid "mprotect(0x%lx,%d,%d) failed."
msgstr "mprotect() falló."

#: spvw_sigsegv.d:23
msgid "Permanently allocated: %lu bytes."
msgstr ""

#: spvw_sigsegv.d:26
msgid "Currently in use: %lu bytes."
msgstr ""

#: spvw_sigsegv.d:29
msgid "Free space: %lu bytes."
msgstr ""

# "SIGSEGV no puede ser subsanado. Dirección del error =3D 0x%x.\n" - lsg
#
# Si, me gusta más tu traducción. Yo había puesto:
#
# "No se puede evitar SIGSEGV. Dirección de fallo = 0x%x.\n"
#
# Pero el caso es que un SIGSEGV no tiene porque evitarse puesto que es
# una señal que, para cuando sale este mensaje, ya se ha recibido. El
# problema ---realmente--- es que no fue posible "subsanar" la
# señal. Muy bien - cll
#
# De todas formas, prefiero ponerlo al revés ("No se puede subsanar" en
# vez de "... no puede ser subsanado"). Por otra parte, en vez de
# "error" prefiero "fallo" puesto que eso es exactamente de lo que se
# trata. No de un error por algo que alguien hizo mal, sino de un fallo
# del sistema, ... - cll
#
#: spvw_sigsegv.d:40
#, fuzzy
msgid "SIGSEGV cannot be cured. Fault address = 0x%lx."
msgstr "No se puede subsanar SIGSEGV. Dirección de fallo = 0x%x."

#: spvw_sigsegv.d:74
msgid "Apollo 13 scenario: Stack overflow handling failed. On the next stack overflow we will crash!!!"
msgstr "Escenario Apollo 13: Falló la manipulación del desbordamiento de pila. a¡ Nos estrellaremos en el siguiente desbordamiento de pila !!!"

#: spvw_sigint.d:69 spvw_sigint.d:133
msgid "Ctrl-C: User break"
msgstr "Ctrl-C: Interrupción del usuario"

#: spvw_garcol.d:1965
#, fuzzy
msgid "munmap() failed."
msgstr "munmap() falló."

#: spvw_allocate.d:32
msgid "No more room for LISP objects"
msgstr "No queda espacio para almacenar más objetos LISP"

#
# "*** - no queda espacio para almacenar objetos LISP - REINICIALIZANDO" - lsg
#
# Yo sigo en mis trece, ... Debe ser un imperativo: REINICIE - cll
#
#: spvw_allocate.d:49
msgid "*** - No more room for LISP objects: RESET"
msgstr "*** - No queda espacio para almacenar más objetos LISP: REINICIE"

#: spvw_allocate.d:246 spvw_allocate.d:305 spvw_allocate.d:388
msgid "Trying to make room through a GC..."
msgstr "Intentando obtener más espacio a través de un GC ..."

#: spvw_sigterm.d:50
msgid "Signal %d while exiting on a signal; cleanup may be incomplete\n"
msgstr ""

#: spvw_sigterm.d:56
msgid "Exiting on signal "
msgstr ""

#: spvw_memfile.d:227
msgid "disk full"
msgstr "el disco está lleno"

#: spvw_memfile.d:270
#, lisp-format
msgid "runtime too small (~S bytes missing)"
msgstr ""

#
# "error del sistema operativo al cargar el fichero de inicialización `%s'\n" - lsg
#
# Así dicho parece que la culpa ha sido la carga del fichero de
# inicialización, cuando en realidad, el mensaje dice "durante". El
# error puede haber sido algo distinto de la carga. Por ejemplo, la
# carga puede ser correcta pero puede no cargarse en memoria (se me
# ocurre así de pronto), o cualquier otra cosa. Por eso prefiero la
# traducción:
#
# "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"
#
# - cll
#
#: spvw_memfile.d:930 spvw_memfile.d:1731
#, fuzzy
msgid "%s: operating system error during load of initialization file `%s'"
msgstr "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"

#: spvw_memfile.d:1432
#, fuzzy
msgid "%s: Cannot map the initialization file `%s' into memory."
msgstr "No puedo escribir el fichero de inicialización en memoria."

#: spvw_memfile.d:1736
#, fuzzy
msgid "%s: initialization file `%s' was not created by this version of CLISP runtime"
msgstr "el fichero de inicialización no fue creado con esta versión de LISP"

#: spvw_memfile.d:1740
#, fuzzy
msgid "%s: not enough memory for initialization"
msgstr "no hay memoria suficiente para la inicialización"

#: spvw_memfile.d:1809
msgid "%s: 'image size' method failed, but found image header at %d\n"
msgstr ""

#: eval.d:873 init.lisp:843 init.lisp:858 compiler.lisp:1187
#, lisp-format
msgid "Invalid access to the value of the lexical variable ~S from within a ~S definition"
msgstr ""

#: eval.d:1057 init.lisp:783 init.lisp:797 compiler.lisp:945
#, lisp-format
msgid "Invalid access to the local function definition of ~S from within a ~S definition"
msgstr ""

#: eval.d:1546
#, lisp-format
msgid "Too many documentation strings in ~S"
msgstr "Demasiadas cadenas de documentación en ~S"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~S. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#: eval.d:1747
#, fuzzy, lisp-format
msgid "~S: lambda-list for ~S is missing"
msgstr "FUNCTION: falta la lista lambda de ~S"

#
# "FUNCTION: la lista lambda de ~S debe ser una lista, no un(a) ~S" - lsg
#
# Lo de "un(a)" no me mola, aunque sin esa palabra el mensaje queda más
# "telegráfico", me parece más apropiado para tratarse del "diálogo con
# un ordenador" :) - cll
#
#: eval.d:1755
#, fuzzy, lisp-format
msgid "~S: lambda-list for ~S should be a list, not ~S"
msgstr "FUNCTION: la lista lambda de ~S debe ser una lista, no ~S"

#: eval.d:1880
#, fuzzy, lisp-format
msgid "~S: illegal declaration ~S"
msgstr "FUNCTION: declaración inválida ~S"

#: eval.d:1974 eval.d:2156
#, fuzzy, lisp-format
msgid "~S: variable specification after ~S too long: ~S"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~S"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~S" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#: eval.d:2012
#, fuzzy, lisp-format
msgid "~S: ~S var must be followed by ~S or ~S or end of list: ~S"
msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~S"

#
# Igualmente: "FUNCTION: &REST debe ir seguido de una variable: ~S" - lsg
#
# Pues si, es que cuando uno está mucho tiempo traduciendo del inglés,
# llega un momento en que empieza coger los hábitos de ese lenguaje y
# empieza a expresarse de una manera extraña, ... - cll
#
#: eval.d:2019
#, fuzzy, lisp-format
msgid "~S: ~S must be followed by a variable: ~S"
msgstr "FUNCTION: &REST debe ir seguido de una variable: ~S"

#: eval.d:2114
#, fuzzy, lisp-format
msgid "~S: incorrect variable specification after ~S: ~S"
msgstr "FUNCTION: especificación de variable incorrecta después de &KEY: ~S"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~S" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#: eval.d:2124
#, fuzzy, lisp-format
msgid "~S: ~S must be followed by ~S or end of list: ~S"
msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~S"

#: eval.d:2177
#, fuzzy, lisp-format
msgid "~S: badly placed lambda-list keyword ~S: ~S"
msgstr "La palabra clave ~S de la lista lambda está mal situada: ~S"

#: eval.d:2187
#, fuzzy, lisp-format
msgid "~S: too many parameters in the lambda-list ~S"
msgstr "FUNCTION: demasiados parámetros en la lista lambda ~S"

#: eval.d:2195
#, fuzzy, lisp-format
msgid "~S: a dot in a lambda-list is allowed only for macros, not here: ~S"
msgstr "FUNCTION: sólo en las macros se permite utilizar un punto en la lista lambda, no aquí: ~S"

#: eval.d:2266
#, fuzzy, lisp-format
msgid "~S: ~S is a special operator, not a function"
msgstr "APPLY: ~S es una forma especial, no una función"

#: eval.d:2277
#, lisp-format
msgid "~S: ~S is a macro, not a function"
msgstr "~S: ~S es una macro, no una función"

#
# "EVAL/APPLY: no se han pasado suficientes argumentos a ~S" - lsg
#
# Hmmm, ... Si me gusta, es más "explicativo". Si, me gusta, si, si
# Lo único que te trastoco es lo de "pasado" por "entregado". Ya sabes,
# un toque de distinción :) - cll
#
#: eval.d:2549
#, lisp-format
msgid "EVAL/APPLY: too few arguments given to ~S"
msgstr "EVAL/APPLY: no se han entregado suficientes argumentos a ~S"

#
# 'Se han pasado demasiados argumentos a ~S" - lsg
#
# Bueno, tu traducción es absolutamente válido. Tal vez, algo más
# informal que la mía, por aquello de "pasado" en vez de
# "entregado". Bueno, pues si te parece, esta vez lo dejo como lo tenía
# yo - cll
#
#: eval.d:2632
#, lisp-format
msgid "EVAL/APPLY: too many arguments given to ~S"
msgstr "EVAL/APPLY: se han entregado demasiados argumentos a ~S"

#
# "EVAL: la variable ~S no tiene asignado ningún valor" - lsg
#
# Bueno, he quitado lo de "asignado" porque parece de "perogrullo", pero
# lo demás se queda - cll
#
#: eval.d:3034
#, lisp-format
msgid "EVAL: variable ~S has no value"
msgstr "EVAL: la variable ~S no tiene ningún valor"

# "EVAL: no se han pasado suficientes argumentos a la forma especial ~S:~S" - lsg
#
# Bueno, pues te digo lo mismo que en el mensaje eval.d:2572, ... - cll
#
#: eval.d:3231
#, fuzzy, lisp-format
msgid "EVAL: too few parameters for special operator ~S: ~S"
msgstr "EVAL: no se han entregado suficientes argumentos a la forma especial ~S: ~S"

#
# "Se han pasado demasiados parámetros a la forma especial ~S: ~S" - lsg
#
# O sea, que quite lo de "para" y ponga "a". Pues vale, tienes toda la
# razón del mundo - cll
#
#: eval.d:3244
#, fuzzy, lisp-format
msgid "EVAL: too many parameters for special operator ~S: ~S"
msgstr "EVAL: se han entregado demasiados parámetros a la forma especial ~S: ~S"

#: eval.d:3256
#, fuzzy, lisp-format
msgid "EVAL: dotted parameter list for special operator ~S: ~S"
msgstr "EVAL: la lista de parámetros para la forma especial ~S está punteada: ~S"

#
# "EVAL: no se han pasado suficientes argumentos a ~S:~S" - lsg
#
# Una vez más, te digo lo mismo que en el mensaje eval.d:2572 - cll
#
#: eval.d:3316
#, lisp-format
msgid "EVAL: too few arguments given to ~S: ~S"
msgstr "EVAL: no se han entregado suficientes argumentos a ~S: ~S"

#
# "Se han pasado demasiados argumentos a ~S: ~S" - lsg
#
# Me gusta más "entregado" que "pasado" - cll
#
#: eval.d:3326
#, lisp-format
msgid "EVAL: too many arguments given to ~S: ~S"
msgstr "EVAL: se han entregado demasiados argumentos a ~S: ~S"

#
# "EVAL: la lista de argumentos pasada a ~S es punteada: ~S" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: eval.d:3334
#, lisp-format
msgid "EVAL: argument list given to ~S is dotted: ~S"
msgstr "EVAL: la lista de argumentos entregada a ~S está punteada: ~S"

#
# "EVAL: la lista de argumentos pasada a ~S es punteada: ~S" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: eval.d:4096
#, fuzzy, lisp-format
msgid "~S: argument list given to ~S is dotted (terminated by ~S)"
msgstr "EVAL: la lista de argumentos entregada a ~S está punteada: ~S"

#
# "Se han pasado demasiados argumentos a ~S" - lsg
#
# Una vez más, me gusta más "entregar" que "pasar" - cll
#
#: eval.d:4104
#, lisp-format
msgid "APPLY: too many arguments given to ~S"
msgstr "APPLY: se han entregado demasiados argumentos a ~S"

#: eval.d:4115
#, fuzzy, lisp-format
msgid "APPLY: dotted argument list given to ~S : ~S"
msgstr "lista punteada entregada a ~S: ~S"

#
# "APPLY: no se han pasado suficientes argumentos a ~S:~S" - lsg
#
# Pues eso, que me gusta más "entregar" - cll
#
#: eval.d:4119
#, lisp-format
msgid "APPLY: too few arguments given to ~S"
msgstr "APPLY: se han entregado pocos argumentos a ~S"

#
# "el símbolo ~S no tiene valor asignado" - lsg
#
# En algún otro sitio ha aparecido algo parecido a esto. Verás, como me
# parece evidente que si un símbolo no tiene valor, es que no tiene
# valor asignado, pues prefiero omitir lo de "asignado" y evitar que el
# usuario lea términos innecesarios - cll
#
#: eval.d:6402 eval.d:6414
#, fuzzy, lisp-format
msgid "~S: symbol ~S has no value"
msgstr "el símbolo ~S no tiene valor"

#: eval.d:6425
#, fuzzy, lisp-format
msgid "~S: assignment to constant symbol ~S is impossible"
msgstr "no pueden realizarse asignaciones sobre el símbolo constante ~S"

#
# "~S: se ha invocado ~S con demasiados argumentos" - lsg
#
# a¡ Traducción brillantísima !!! Te ha quedado perfecto. Lo que yo había puesto:
#
# "~S: se han entregado demasiados argumentos a ~S"
#
# queda como más "indio". Tu traducción me encanta - cll
#
#: eval.d:6990 control.d:2234
#, lisp-format
msgid "~S: too many arguments given to ~S"
msgstr "~S: se ha invocado ~S con demasiados argumentos"

# Duda: tagbody es de muy difícil traducción.
#       Echando un ojo a la traducción en francés me he encontrado con que est
#       tal cual, ... De momento se queda así hasta que otros miembros del
#       equipo decidan cualquier otra cosa, ...
#
# No es que sepa lo que es, pero, si tag es etiqueta, tagbody podría ser
# "el cuerpo de la etiqueta" (¿tiene sentido esto?), con lo cual, una
# posibilidad sería (para simplificar) "el cuerpo de las etiquetas..." sv
#
# Otra de las propuestas a esta cuestión en la lista de correo
# es@li.org, ha sido: "el contenido de las etiquetas ~S ya ha sido
# abandonado". Esta traducción me gusta, ... cll
#
# ( Desafortunadamente, no recuerdo el nombre de la persona que lo
# sugirió, ... cll )
#
# "(~S ~S): ya se ha salido del cuerpo de etiquetas ~S" - lsg
#
# Debo rendirme a la evidencia, ... La propuesta de Leo, no solo para
# este término sino todos cuanto se refieren a la traducción de `tag' y
# `tagbody' es perfecta y, además, sigue los pasos de la de Santiago, de
# modo que "moción aceptada" :)
#
#: eval.d:7149 eval.d:7181
#, lisp-format
msgid "(~S ~S): the tagbody of the tags ~S has already been left"
msgstr "(~S ~S): ya se ha salido del cuerpo de etiquetas ~S"

#: eval.d:7238 control.d:1956
#, lisp-format
msgid "~S: there is no CATCHer for tag ~S"
msgstr "~S: No hay ningún capturador (CATCH) para la etiqueta de salto ~S"

#: eval.d:7258
msgid "STACK corrupted"
msgstr "Pila (STACK) corrupta"

#: eval.d:7598
#, lisp-format
msgid "~S: ~S is not a correct index into ~S"
msgstr "~S: ~S no es un índice correcto en ~S"

#: eval.d:8196
#, lisp-format
msgid "undefined bytecode in ~S at byte ~S"
msgstr "Código de octeto ~S indefinido en el octeto ~S"

#: eval.d:8210
#, lisp-format
msgid "~S: jump by ~S takes ~S outside [~S;~S]"
msgstr ""

#: eval.d:8215
#, fuzzy, lisp-format
msgid "~S: too many return values"
msgstr "Demasiados valores devueltos"

#: eval.d:8221
#, lisp-format
msgid "Corrupted STACK in ~S at byte ~S"
msgstr "Pila corrupta en ~S en el byte ~S"

#: control.d:79 init.lisp:1253
#, lisp-format
msgid "~S: ~S should be a lambda expression"
msgstr "~S: ~S debe ser una expresión lambda"

#: control.d:100
#, lisp-format
msgid "~S: ~S has no dynamic value"
msgstr "~S: ~S no tiene ningún valor dinámico"

#: control.d:190
#, fuzzy, lisp-format
msgid "~S: odd number of arguments: ~S"
msgstr "~S invocado con un número impar de argumentos: ~S"

#: control.d:288
#, fuzzy, lisp-format
msgid "~S: the special operator definition of ~S must not be removed"
msgstr "~S: no se debe desechar la definición de la forma especial de ~S"

#: control.d:355
#, fuzzy, lisp-format
msgid "doc-string is not allowed here and will be ignored: ~S"
msgstr "~S: aquí no se permiten cadenas de documentación: ~S"

#: control.d:407
#, lisp-format
msgid "~S: illegal variable specification ~S"
msgstr "~S: especificación inválida de variable ~S"

#: control.d:541
#, fuzzy, lisp-format
msgid "~S: symbol ~S has been declared SPECIAL and may not be re-defined as a SYMBOL-MACRO"
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el símbolo ~S no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:546
#, fuzzy, lisp-format
msgid "~S: symbol ~S must not be declared SPECIAL and defined a SYMBOL-MACRO at the same time"
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el símbolo ~S no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:583
#, lisp-format
msgid "~S: too many variables and/or declarations"
msgstr "~S: demasiadas variables y/o declaraciones"

#: control.d:846
#, lisp-format
msgid "~S: ~S is not a function specification"
msgstr "~S: ~S no es la especificación de una función"

#: control.d:1021
#, lisp-format
msgid "~S: ~S is not a macro specification"
msgstr "~S: ~S no es la especificación de una macro"

#: control.d:1028
#, lisp-format
msgid "~S: macro name ~S should be a symbol"
msgstr "~S: el nombre de la macro ~S debe ser un símbolo"

#: control.d:1083
#, fuzzy, lisp-format
msgid "~S: ~S is not a function and macro specification"
msgstr "~S: ~S no es la especificación de una función"

#: control.d:1090
#, fuzzy, lisp-format
msgid "~S: function and macro name ~S should be a symbol"
msgstr "~S: el nombre de la función ~S debe ser un símbolo"

#: control.d:1205
#, lisp-format
msgid "~S: clause ~S should be a list"
msgstr "~S: la clausula ~S debe ser una lista"

#: control.d:1235
#, lisp-format
msgid "~S: missing key list: ~S"
msgstr "~S: falta la lista de claves: ~S"

#: control.d:1244 macros1.lisp:307
#, lisp-format
msgid "~S: the ~S clause must be the last one"
msgstr "~S: la clausula ~S debe ser la última"

#: control.d:1298
#, lisp-format
msgid "~S: the block named ~S has already been left"
msgstr "~S: el bloque de nombre ~S ya ha sido abandonado"

#: control.d:1333
#, lisp-format
msgid "~S: no block named ~S is currently visible"
msgstr "~S: no hay ningún bloque visible con el nombre ~S"

#: control.d:1590
#, lisp-format
msgid "~S: ~S is neither tag nor form"
msgstr "~S: ~S no es ni una etiqueta de salto ni una forma"

#: control.d:1632
#, lisp-format
msgid "~S: illegal tag ~S"
msgstr "~S: etiqueta de salto inválida ~S"

#: control.d:1670
#, lisp-format
msgid "~S: tagbody for tag ~S has already been left"
msgstr "~S: ya se ha salido del cuerpo de etiquetas de ~S"

#: control.d:1684
#, lisp-format
msgid "~S: no tag named ~S is currently visible"
msgstr "~S: no hay ninguna etiqueta de salto visible con el nombre ~S"

#: control.d:1698
#, lisp-format
msgid "~S: too many values"
msgstr "~S: demasiados valores"

#: control.d:1738
#, lisp-format
msgid "~S: too many arguments to ~S"
msgstr "~S: se han entregado demasiados argumentos a ~S"

#: control.d:1996
#, lisp-format
msgid "Argument ~S is not a macroexpansion environment"
msgstr "El argumento ~S no es un entorno para la expansión de macros"

#: control.d:2053
#, lisp-format
msgid "declarations ~S are not allowed here"
msgstr "las declaraciones ~S no están permitidas aquí"

#: control.d:2075
#, lisp-format
msgid "~S: ~S evaluated to the values ~S, not of type ~S"
msgstr "~S: La forma ~S ha producido los valores ~S, ninguno de los cuales es del tipo ~S"

#: control.d:2086
#, lisp-format
msgid "~S: bad declaration ~S"
msgstr "~S: declaración incorrecta ~S"

#: control.d:2351 error.d:909
#, fuzzy, lisp-format
msgid "~S: ~S is not a symbol"
msgstr "~SS: ~SS no es un símbolo."

#: control.d:2384
#, lisp-format
msgid "keyword argument list ~S has an odd length"
msgstr "la lista de argumentos clave ~S tiene longitud impar"

#: control.d:2421
#, fuzzy, lisp-format
msgid ""
"Illegal keyword/value pair ~S, ~S in argument list.\n"
"The allowed keywords are ~S"
msgstr "par argumento clave/valor inválido ~S, ~S en la lista de argumentos. Los parámetros clave permitidos son ~S"

#: encoding.d:240
#, fuzzy, lisp-format
msgid "Invalid base64 encoding termination at position ~S"
msgstr "La especificación de parámetros ~S de la función ~S es incorrecta"

#: encoding.d:245
#, lisp-format
msgid "Invalid base64 encoding at ~S (character ~S of ~S)"
msgstr ""

#: encoding.d:279
#, lisp-format
msgid "Character #\\u~C~C~C~C cannot be represented in the character set ~S"
msgstr ""

#: encoding.d:283
#, lisp-format
msgid "Character #\\u00~C~C~C~C~C~C cannot be represented in the character set ~S"
msgstr ""

#: encoding.d:296
#, lisp-format
msgid "incomplete byte sequence at end of buffer for ~S"
msgstr ""

#: encoding.d:552
#, lisp-format
msgid "character #x~C~C~C~C~C~C~C~C in ~S conversion, not an UTF-32 character"
msgstr ""

#: encoding.d:749
#, lisp-format
msgid "invalid byte #x~C~C in ~S conversion, not a Unicode-16"
msgstr ""

#: encoding.d:761
#, lisp-format
msgid "invalid byte sequence #x~C~C #x~C~C in ~S conversion"
msgstr ""

#: encoding.d:775
#, lisp-format
msgid "invalid byte sequence #x~C~C #x~C~C #x~C~C in ~S conversion"
msgstr ""

#: encoding.d:791
#, lisp-format
msgid "invalid byte sequence #x~C~C #x~C~C #x~C~C #x~C~C in ~S conversion"
msgstr ""

#: encoding.d:1596
#, lisp-format
msgid "invalid byte #x~C~C in ~S conversion"
msgstr ""

#: encoding.d:2029 encoding.d:2040 encoding.d:2050 encoding.d:2061 pathname.d:1272 pathname.d:3609 pathname.d:6413 pathname.d:6444 pathname.d:6483 pathname.d:7603 pathname.d:8531 stream.d:3298 stream.d:3406 stream.d:16546 hashtabl.d:2027 error.d:1254
#, lisp-format
msgid "~S: illegal ~S argument ~S"
msgstr "~S: el argumento de ~S es inválido: ~S"

#: encoding.d:2543 encoding.d:2548
msgid "WARNING: %s: no encoding %s, using %s"
msgstr ""

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#
#: pathname.d:682 pathname.d:725
#, lisp-format
msgid "~S: host should be NIL or a string, not ~S"
msgstr "~S: el anfitrión debe ser, o bien NIL, o una cadena, pero no ~S"

#
# Duda: he traducido hostname por "nombre del `host'". ¿Qué os parece?
#
#: pathname.d:702 pathname.d:746
#, lisp-format
msgid "~S: illegal hostname ~S"
msgstr "~S: nombre de anfitrión inválido ~S"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:763
#, lisp-format
msgid "~S: host should be NIL, not ~S"
msgstr "~S: el anfitrión debe ser NIL, no ~S"

#: pathname.d:894
#, fuzzy, lisp-format
msgid "~S: argument ~S should be a pathname designator ~S"
msgstr "~S: el argumento ~S debe ser un flujo"

#: pathname.d:928
#, lisp-format
msgid "~S: filename for ~S is unknown"
msgstr "~S: el nombre de fichero de ~S es desconocido"

#: pathname.d:1404 realelem.d:204
#, lisp-format
msgid ""
"The variable ~S had an illegal value.\n"
"~S has been reset to ~S."
msgstr ""
"La variable ~S tenía un valor inválido.\n"
"~S ha sido inicializado a ~S."

#: pathname.d:1748
#, lisp-format
msgid "~S: there is no user named ~S"
msgstr "~S: no hay ningún usuario con el nombre ~S"

#: pathname.d:1807
#, lisp-format
msgid "~S: there is no environment variable ~S"
msgstr "~S: no hay ninguna variable de entorno ~S"

#: pathname.d:1974
#, lisp-format
msgid "~S: syntax error in filename ~S at position ~S"
msgstr "~S: error de sintáxis en el nombre del fichero ~S, en la posición ~S"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:1990 pathname.d:2005
#, lisp-format
msgid "~S: hosts ~S and ~S of ~S should coincide"
msgstr "~S: los anfitriones ~S y ~S de ~S deben coincidir"

#: pathname.d:2178
#, lisp-format
msgid "~S: argument ~S is not a logical pathname, string, stream or symbol"
msgstr "~S: el argumento ~S no es un PATHNAME \"lógica\", una cadena de caracteres, un flujo o un símbolo"

#: pathname.d:2188
#, fuzzy, lisp-format
msgid "~S: the stream ~S was not opened with a logical pathname"
msgstr "~S: el flujo de entrada ~S ha terminado mientras se procesaba un objeto"

#: pathname.d:2203
#, fuzzy, lisp-format
msgid "~S: argument ~S does not contain a host specification"
msgstr "~S: el argumento ~S no es el flujo de un fichero abierto"

#: pathname.d:2258
#, lisp-format
msgid "~S: endless loop while resolving ~S"
msgstr "~S: bucle infinito para ~S"

#: pathname.d:2285
#, lisp-format
msgid "~S: unknown logical host ~S in ~S"
msgstr "~S: anfitrión ~S desconocido en ~S"

#: pathname.d:2297
#, lisp-format
msgid "~S: No replacement rule for ~S is known."
msgstr "~S: No se conoce ninguna regla de sustitución para ~S."

#: pathname.d:2612
#, lisp-format
msgid "~S: :VERSION-argument should be NIL or a positive fixnum or :WILD or :NEWEST, not ~S"
msgstr "~S: el argumento :VERSION debe ser NIL, un número positivo del tipo fixnum, :WILD o :NEWEST pero no ~S"

#: pathname.d:2680
#, lisp-format
msgid "The value of ~S was not a pathname. ~:*~S is being reset."
msgstr "El valor de ~S no es del tipo PATHNAME. ~:*~S se reinicializará."

#: pathname.d:3423
#, lisp-format
msgid "~S: on host ~S, device ~S is invalid, should be NIL"
msgstr ""

# Duda: Wildcard por comodín, ..., está bien, ¿no?
#
#: pathname.d:3865
#, lisp-format
msgid "wildcards are not allowed here: ~S"
msgstr "Aquí no están permitidos los comodines: ~S"

#: pathname.d:3900
#, lisp-format
msgid "~S: argument ~S should be ~S, ~S, ~S, ~S, ~S, ~S or ~S"
msgstr "~S: el argumento ~S debe ser ~S, ~S, ~S, ~S, ~S, ~S o ~S"

#: pathname.d:4821
#, lisp-format
msgid "~S: replacement pieces ~S do not fit into ~S"
msgstr "~S: las piezas de intercambio ~S no caben en ~S"

#: pathname.d:4904
#, lisp-format
msgid "~S: ~S is not a specialization of ~S"
msgstr "~S: ~S no es una especialización de ~S"

#: pathname.d:4960
#, lisp-format
msgid "(~S ~S ~S ~S) is ambiguous: ~S"
msgstr "(~S ~S ~S ~S) es ambiguo: ~S"

#: pathname.d:5004
#, lisp-format
msgid "nonexistent directory: ~S"
msgstr "directorio inexistente: ~S"

#: pathname.d:5013
#, fuzzy, lisp-format
msgid "~S: file ~S already exists"
msgstr "~S: El fichero ~S ya existe"

#: pathname.d:5230
#, lisp-format
msgid "no directory ~S above ~S"
msgstr "no existe el directorio ~S bajo ~S"

#: pathname.d:5237
#, lisp-format
msgid "\"..\\\\\" after \"...\\\\\" is invalid: ~S"
msgstr "\"..\\\\\" después de \"...\\\\\" es inválido: ~S"

# Casi lo mismo. Bueno, al menos aquí hay dos puntos. sv
#
# Tienes razón. Ahora que veo este mensaje me lío a poner dos puntos en
# los mensajes anteriores. cll
#
#: pathname.d:5519
#, lisp-format
msgid "UNIX error while GETWD: ~S"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~S"

# Si la tildecilla se sustituye por aquello que devolvió la orden GETWD,
# la frase resultante no tiene mucho sentido.
# Sugerencia: "La ejecución de GETWD en Unix devolvió ~S" sv
#
# Hmmm, ..., podría ser, pero verás: en primer lugar, el texto que est
# asociado con la etiqueta "UNIX GETWD returned ~S" es "UNIX error while
# GETWD" (fichero pathname.d, línea 6176); segundo, en CLisp se sigue la
# convención de colocar primero un mensaje y después, al final, aquello
# que originó el mensaje y, francamente, no quiero cambiar esta
# convención. Es decir, no quiero faltar al estilo original de los
# autores del programa. cll
#
# Por este motivo, creo que lo más conveniente es dejarlo como está. cll
#
#: pathname.d:5526
#, lisp-format
msgid "UNIX GETWD returned ~S"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~S"

# Lo mismo. sv
#
# Lo mismo también ;) cll
#
#: pathname.d:5636
#, lisp-format
msgid "UNIX REALPATH returned ~S"
msgstr "Se produjo un error UNIX durante la ejecución de REALPATH: ~S"

#: pathname.d:5677
#, lisp-format
msgid "~S: ~S names a directory, not a file"
msgstr "~S: ~S es el nombre de un directorio, no de un fichero"

#: pathname.d:5808
#, lisp-format
msgid "no file name given: ~S"
msgstr "no se ha entregado ningún nombre de fichero: ~S"

#: pathname.d:5819
#, lisp-format
msgid "not a directory: ~S"
msgstr "no es un directorio: ~S"

#: pathname.d:5862
#, lisp-format
msgid "~S: file ~S does not exist"
msgstr "~S: el fichero ~S no existe"

#: pathname.d:5895
#, lisp-format
msgid "~S: pathname with type but without name makes no sense: ~S"
msgstr "~S: un PATHNAME con tipo, pero sin nombre, no tiene ningún sentido: ~S"

#: pathname.d:6076
#, fuzzy, lisp-format
msgid "~S: Cannot delete file ~S since there is a file stream open to it"
msgstr "no se puede borrar el fichero ~S puesto que hay un flujo abierto sobre el"

#: pathname.d:6120
#, fuzzy, lisp-format
msgid "~S: Cannot rename file ~S since there is a file stream open to it"
msgstr "no se puede renombrar el fichero ~S puesto que hay un flujo abierto sobre el"

#: pathname.d:6536
msgid "Open the file anyway"
msgstr ""

#: pathname.d:6537
#, lisp-format
msgid "~S: ~S already points to file ~S, opening the file again for ~S may produce unexpected results"
msgstr ""

#: pathname.d:7703
#, lisp-format
msgid "root directory not allowed here: ~S"
msgstr "el directorio raíz no está permitido aquí: ~S"

# Duda: ¿Creando *el* directorio? ¿Creando *un* directorio? De momento,
# simplemente "Creando directorio" - cll
#
#: pathname.d:7808
msgid "Creating directory: "
msgstr "Creando directorio: "

#: pathname.d:8867
#, lisp-format
msgid "~S: installation directory is not known, use the -B command line option to specify it or set *LIB-DIRECTORY*"
msgstr ""

# Duda: En este mensaje, el primer "~S" se sustituye por el nombre de una
# función y el segundo "~S" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: stream.d:272 stream.d:13633
#, lisp-format
msgid "~S on ~S is illegal"
msgstr "~S no es posible sobre el flujo ~S"

# "~S:argumento de ~S debe ser un entero comprendido entre 2 y 36, no ~S" - lsg
#
# Algo parecido he puesto yo - cll
#
#: stream.d:614 stream.d:670 stream.d:864
#, fuzzy, lisp-format
msgid "Return value ~S of call to ~S should be an integer between ~S and ~S."
msgstr "~S: el argumento ~S debe ser un entero comprendido entre 2 y 36, y no ~S"

#: stream.d:763
#, lisp-format
msgid "~S: the last character read from ~S was not ~S"
msgstr "~S: el último carácter leído de ~S no era ~S"

# Duda: A continuación vienen muchos mensajes que empiezan por "~S from
# ~S". Para ayudar en su trabajo a quienes estén revisando este trabajo
# (no me canso de darte las gracias, Santiago, ..., y a quienes se
# animen) aclaro que el primer "~S" se sustituye por el nombre de una
# función cuya evaluación (o ejecución, pero esto no es correcto en
# Lisp, ... se prefiere el término evaluación porque se está a nivel de
# intérprete) produce el error; el segundo "~S" se refiere al nombre del
# flujo desde el cual se leyó dicha función. Luego, a continuación,
# viene el mensaje de error propiamente dicho.
#
# Por ejemplo, la siguiente instrucción en CLisp:
#
# > (read)
#
# ..., si se teclea:
#
# #<...>
#
# ..., produce el siguiente error: (en español, ya traducido)
#
# *** - READ en #<TERMINAL-STREAM>: los objetos escritos de la manera
# #<...> no pueden volverse a leer
#
# ¿De acuerdo?
#
# A continuación reproduzco un par de mails donde se explica el
# mecanismo general de estos mensajes, a propósito de la pregunta que
# puse en la lista de correo de CLisp:
#
# Mi pregunta fue:
#
# > 21. There are a few messages which begin with "~S from ~S". They are
# > very easy to translate but they use a lot of prepositions, and words
# > that could be translated in masculine or feminine. So, I need some
# > real examples of their use.
#
# Las respuestas fueron:
#
#
# ---------------------------------------------------------------------------
# Look in io.d:
#     { pushSTACK(*stream_); # Wert fu:r Slot STREAM von STREAM-ERROR
#       pushSTACK(ch); # Character
#       pushSTACK(*stream_); # Stream
#       pushSTACK(S(read));
#       //: DEUTSCH "~S von ~S: Gelesenes Zeichen ist kein String-Char: ~S"
#       //: ENGLISH "~S from ~S: character read should be a string-char: ~S"
#       //: FRANCAIS "~S de ~S : le caracte!re lu n'est pas de type STRING-CHAR."
# The first ~S is the function name, the second the stream that was being
# read from or written to and the third is the character that was read/written.
#
# So it says something like "READ from #<STREAM ...>: illegal character"
#
# 						(Joerg Hoehle)
#
# ---------------------------------------------------------------------------
# A general question here: I thought gettext was coming with an Emacs
# mode called "po-mode", which helps you in translating the messages.
# In particular, there are keystroke commands for showing the C/Lisp source
# surrounding the original reference to a message. From this context,
# you should at least be able to guess the meaning of the objects which
# are substituted for the ~S. Note, however, that the first ~S corresponds
# the last pushSTACK command before the string, the second ~S to the
# second-to-last pushSTACK command etc.
#
# 						(Bruno Haible)
#
# ---------------------------------------------------------------------------
#
#: stream.d:769
#, lisp-format
msgid "~S from ~S without ~S before it"
msgstr "~S en ~S sin ~S antes de él"

#: stream.d:1128
#, lisp-format
msgid "~S: cannot output to ~S"
msgstr "~S: no se puede escribir en ~S"

#: stream.d:1139
#, fuzzy, lisp-format
msgid "~S: cannot output ~S into ~S, not of type ~S"
msgstr "~S: no se puede escribir en ~S"

#: stream.d:1165
#, lisp-format
msgid "integer ~S is out of range, cannot be output onto ~S"
msgstr "el entero ~S está fuera del dominio, no puede imprimirse en ~S"

#: stream.d:1179
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a stream of type ~S"
msgstr "~S: el argumento ~S debe ser un flujo del tipo ~S"

#: stream.d:1237
#, fuzzy, lisp-format
msgid "~S: argument ~S should be an input stream"
msgstr "~S: el argumento ~S debe ser un flujo"

#: stream.d:1249
#, fuzzy, lisp-format
msgid "~S: argument ~S should be an output stream"
msgstr "~S: el argumento ~S debe ser un flujo"

#: stream.d:1543
#, fuzzy, lisp-format
msgid "~S: argument should be a symbol, not ~S"
msgstr "~S: el argumento debe ser una cadena de caracteres, no ~S"

#: stream.d:2394 stream.d:2881
#, lisp-format
msgid "~S is beyond the end because the string ~S has been adjusted"
msgstr "~S está más allá del final porque la cadena ~S ha sido ajustada"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2509
#, fuzzy, lisp-format
msgid "~S: ~S is not a string input stream"
msgstr "~S: ~S no es un flujo de entrada con buffer"

#: stream.d:2581 charstrg.d:3209
#, fuzzy, lisp-format
msgid "~S: ~S argument must be a subtype of ~S, not ~S"
msgstr "~SS: el argumento debe ser ~SS, ~SS o ~SS, pero no ~SS"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2636
#, fuzzy, lisp-format
msgid "~S: ~S is not a string output stream"
msgstr "~S: ~S no es un flujo de entrada con buffer"

# Duda: He traducido `fill pointer' por "puntero de relleno". En
# realidad, los `fill-pointer' son exactamente, eso:
#
# "The fill pointer constitutes the "active length" of the vector; all
# vector elements whose index is less than the fill pointer are active,
# and the others are inactive." (Guy L. Steele, Jr; Common Lisp, The
# Language - 2nd Edition; pag. 454).
#
#: stream.d:2670
#, lisp-format
msgid "~S: argument ~S should be a string with fill pointer"
msgstr "~S: El argumento ~S debe ser una cadena con un puntero de relleno"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2721
#, fuzzy, lisp-format
msgid "~S: ~S is not a string stream"
msgstr "~S: ~S no es un flujo de entrada con buffer"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2972
#, lisp-format
msgid "~S: ~S is not a buffered input stream"
msgstr "~S: ~S no es un flujo de entrada con buffer"

#: stream.d:3917
#, lisp-format
msgid "~S: Ctrl-C: User break"
msgstr "~S: Ctrl-C: Interrupción del usuario"

#: stream.d:3997
#, fuzzy, lisp-format
msgid "unknown character set ~S"
msgstr "Registro desconocido: ~SS"

#: stream.d:5780
#, lisp-format
msgid "Unbuffered streams need an ~S with a bit size being a multiple of 8, not ~S"
msgstr ""

#: stream.d:6139
#, lisp-format
msgid "Closed ~S because disk is full."
msgstr "Se ha cerrado ~S porque el disco está lleno."

#: stream.d:6257
#, lisp-format
msgid "cannot position ~S beyond EOF"
msgstr "no es posible colocarse en ~S más allá de EOF"

# Duda: lo del fichero `regular' por `normal'. De hecho, yo juraría que
# en la asignatura de Sistemas Operativos, en mi Facultad, los
# llamábamos "ficheros normales". ¿Qué tal os suena?.
#
#: stream.d:7804
#, fuzzy, lisp-format
msgid "~S: argument ~S ~S was specified, but ~S is not a regular file."
msgstr "~S: ~S no es un fichero normal."

#: stream.d:7838
#, lisp-format
msgid "~S: arguments ~S ~S and ~S ~S were specified, but ~S is not a regular file."
msgstr ""

# Duda: aqui he traducido de la version francesa (no se frances, pero
# por lo que parece que pone, ...)
#
#: stream.d:7894
#, lisp-format
msgid "file ~S is not an integer file"
msgstr "el fichero ~S no tiene el formato de un fichero de enteros"

#: stream.d:8992
#, fuzzy, lisp-format
msgid "Return value ~S of call to ~S is not a list."
msgstr "El valor de ~S no es un flujo: ~S"

#: stream.d:9013
#, fuzzy, lisp-format
msgid "Return value ~S of call to ~S contains ~S which is not a ~S."
msgstr "El valor de ~S no es un flujo: ~S"

#: stream.d:10094
#, lisp-format
msgid "~S: argument ~S should be a window stream"
msgstr "~S: el argumento ~S debe ser un WINDOW-STREAM"

#: stream.d:10640
msgid "cannot output to standard output"
msgstr "no se puede escribir en la salida estándar"

#: stream.d:11831
msgid "environment has no TERM variable"
msgstr "no existe ninguna variable de entorno TERM"

#: stream.d:11836
#, lisp-format
msgid "terminal type ~S unknown to termcap"
msgstr "No existe ninguna entrada para el tipo de terminal ~S en termcap"

# Duda: Juan Jordana (de la lista de CLisp) propone usar la expresión:
#
# 	Terminal incompleta (o errónea): Terminal de impresora.
#
# 	y me gusta, salvo que prefiero decir a continuación algo del
# 	tipo "usando el modo de impresora" o algo así, ¿no os parece
# 	mejor?
#
#: stream.d:11849
msgid "insufficient terminal: hardcopy terminal"
msgstr "terminal insuficiente: usando el modo de impresora"

# Duda: ¿Pues qué voy a decir? La traducción siguiente es una auténtica
# traducción libre. De todos modos, tanto la versión francesa como la
# alemana (aunque no sé ni alemán ni francés) hacen ---por lo visto---,
# lo que yo: una traducción libre.
#
#: stream.d:11853
msgid "insufficient terminal: overstrikes, cannot clear output"
msgstr "teminal insuficiente: no se puede inicializar la salida"

#: stream.d:11857
msgid "insufficient terminal: cannot scroll"
msgstr "terminal insuficiente: no se puede desplazar la pantalla"

#: stream.d:11862
msgid "insufficient terminal: cannot clear screen"
msgstr "terminal insuficiente: no se puede borrar la pantalla"

#: stream.d:11866
msgid "insufficient terminal: cannot position cursor randomly"
msgstr "terminal insuficiente: no se puede situar el cursor aleatoriamente"

# Duda: he dejado `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: stream.d:13363
#, lisp-format
msgid "host should be string, not ~S"
msgstr "el anfitrión debe ser una cadena de caracteres y no ~S"

# Duda: Pues otra vez como siempre, ..., he dejado `display' tal
# cual. Pienso que todo el mundo sabe lo que es un `display' ¿no?
#
# Por otra parte (como ya sucedió en un mensaje anterior), ..., `fixnum'
# por ser el nombre de un subtipo (o tipo, si se quiere) en Lisp, est
# sin traducir, ...
#
#: stream.d:13370
#, fuzzy, lisp-format
msgid "display should be a small nonnegative integer, not ~S"
msgstr "el `display' debe ser un entero del tipo FIXNUM >=0, y no ~S"

#: stream.d:13445 stream.d:16694 stream.d:16752 stream.d:16805 stream.d:16864 io.d:948
#, lisp-format
msgid "~S: input stream ~S has reached its end"
msgstr "~S: el flujo de entrada ~S ha alcanzado su final"

#: stream.d:13628 record.d:217 record.d:592 record.d:753 record.d:794 record.d:850 weak.d:40 weak.d:130 weak.d:248 weak.d:314 weak.d:372 weak.d:473 weak.d:575 weak.d:722 sequence.d:330 error.d:816 error.d:818 error.d:1025
#, fuzzy, lisp-format
msgid "~S: ~S is not a ~S"
msgstr "~S: ~S no es un par"

#: stream.d:13671
#, fuzzy, lisp-format
msgid "~S: argument ~S is not an open SOCKET-STREAM"
msgstr "~S: el argumento ~S no es un SOCKET-STREAM"

#: stream.d:13682
#, lisp-format
msgid "~S: argument ~S is not a SOCKET-STREAM"
msgstr "~S: el argumento ~S no es un SOCKET-STREAM"

#: stream.d:13696
msgid "WARNING: (socket-server <socket>) is deprecated, use (socket-server <port> :interface <socket>)"
msgstr ""

#: stream.d:13952
#, fuzzy, lisp-format
msgid "~S: argument ~S is not an open stream"
msgstr "~S: el argumento ~S no es el flujo de un fichero abierto"

#: stream.d:14172
#, fuzzy, lisp-format
msgid "~S: list ~S is too long (~S maximum)"
msgstr "~S: la secuencia ~S es demasiado larga"

#: stream.d:14399
#, fuzzy, lisp-format
msgid "~S: argument ~S should be of type ~S."
msgstr "~S: el argumento ~S debe ser un flujo del tipo ~S"

#: stream.d:14611
#, fuzzy, lisp-format
msgid "Invalid direction ~S for accessing ~S"
msgstr "Sintaxis inválida en la forma ~SS: ~SS."

#: stream.d:14641
#, fuzzy, lisp-format
msgid "~S: ~S should be a handle, handle stream, or one of ~S, ~S, ~S"
msgstr "~SS: ~SS debe ser una expresión lambda"

#: stream.d:14926
#, lisp-format
msgid "The value of ~S is not a stream: ~S"
msgstr "El valor de ~S no es un flujo: ~S"

#: stream.d:14928
#, lisp-format
msgid "The value of ~S is not an appropriate stream: ~S"
msgstr "El valor de ~S no es un flujo apropiado: ~S"

#: stream.d:14940
#, fuzzy, lisp-format
msgid "The value of ~S was not an appropriate stream: ~S. It has been changed to ~S."
msgstr "El valor de ~S no era un flujo: ~S. Ha sido cambiado por ~S."

#: stream.d:14953
msgid "readline library: out of memory."
msgstr "biblioteca readline: la memoria ha sido agotada."

#: stream.d:15255
#, fuzzy, lisp-format
msgid "~S: The ~S of ~S cannot be changed from ~S to ~S."
msgstr "~S: ~S no puede convertirse al tipo ~S"

#: stream.d:15839
#, fuzzy, lisp-format
msgid "Return value ~S of call to ~S is not a string."
msgstr "El valor de ~S no es un flujo: ~S"

#: stream.d:16350
#, lisp-format
msgid "Return value ~S of call to ~S is not a fixnum >= 0 or NIL."
msgstr ""

#: stream.d:16513
#, lisp-format
msgid "~S needs an ~S with a bit size being a multiple of 8, not ~S"
msgstr ""

#: stream.d:16563
#, fuzzy, lisp-format
msgid "~S: illegal endianness argument ~S"
msgstr "~S: el argumento de ~S es inválido: ~S"

#: stream.d:16676
#, fuzzy, lisp-format
msgid "~S: argument ~S does not contain a valid OS stream handle"
msgstr "~S: el argumento ~S no es el flujo de un fichero abierto"

#: stream.d:16677
#, lisp-format
msgid "~S: ~S: buffered pipe-input-streams are not supported"
msgstr ""

#: stream.d:16678
#, fuzzy, lisp-format
msgid "~S: ~S: stream of wrong direction"
msgstr "~S: ~S no es una función"

#: stream.d:16938 stream.d:16948
#, fuzzy, lisp-format
msgid "~S is not a ~S, cannot be output onto ~S"
msgstr "~S no es un entero, no puede escribirse en ~S"

#: stream.d:17020
#, fuzzy, lisp-format
msgid "~S: argument ~S is not an open file stream"
msgstr "~S: el argumento ~S no es el flujo de un fichero abierto"

#: stream.d:17074
#, fuzzy, lisp-format
msgid "~S: position argument should be ~S or ~S or a nonnegative integer, not ~S"
msgstr "~S: el argumento de posición debe ser ~S, ~S o un número no negativo del tipo FIXNUM, pero no ~S"

#: socket.d:475
#, fuzzy, lisp-format
msgid "~S: IP address ~S must have length ~S or ~S"
msgstr "~S: el argumento ~S debe ser un flujo"

#
# "~S: los elementos de la formación ~S no son de tipo ~S" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#: socket.d:477
#, fuzzy, lisp-format
msgid "~S: IP address ~S must have length ~S"
msgstr "~S: los elementos de la matriz ~S no son del tipo ~S"

#: io.d:481
#, lisp-format
msgid "The value of ~S was not a readtable. It has been reset."
msgstr "El valor de ~S no es una tabla de lectura. Ha sido inicializado/a."

#: io.d:563 error.d:1153
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a ~S"
msgstr "~S: el argumento ~S no es el flujo de un fichero abierto"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
# Al final, por iniciativa de Leo, he cambiado `# macro carácter', que
# no me gustaba demasiado por `macro carácter secundario', que me parece
# mucho mejor. - cll
#
#: io.d:717
#, lisp-format
msgid "~S: ~S is a dispatch macro character"
msgstr "~S: ~S es un macro carácter secundario"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:769
#, lisp-format
msgid "~S: ~S is not a dispatch macro character"
msgstr "~S: ~S no es un macro carácter secundario"

#: io.d:793
#, fuzzy, lisp-format
msgid "~S: digit ~C not allowed as sub-char"
msgstr "~S: el dígito $ no está permitido como un sub-carácter"

#: io.d:840
#, lisp-format
msgid "~S: new value ~S should be ~S, ~S, ~S or ~S."
msgstr "~S: el nuevo valor ~S debe ser ~S, ~S, ~S o ~S."

#: io.d:872
#, lisp-format
msgid ""
"The value of ~S should be an integer between 2 and 36, not ~S.\n"
"It has been reset to 10."
msgstr ""
"El valor de ~S debe ser un entero entre 2 y 36, no ~S.\n"
"Ha sido inicializado a 10."

#: io.d:918 defs2.lisp:178
#, fuzzy, lisp-format
msgid "~S from ~S: character read should be a character: ~S"
msgstr "~S en ~S: el carácter leído debe ser un STRING-CHAR: ~S"

#: io.d:960
#, lisp-format
msgid "~S: input stream ~S ends within an object. Last opening parenthesis probably in line ~S."
msgstr "~S: el flujo de entrada ~S ha terminado mientras se procesaba un objeto. El último paréntesis abierto es, probablemente, el de la línea ~S."

#: io.d:964
#, lisp-format
msgid "~S: input stream ~S ends within an object"
msgstr "~S: el flujo de entrada ~S ha terminado mientras se procesaba un objeto"

#: io.d:1242
#, lisp-format
msgid "~S from ~S: illegal character ~S"
msgstr "~S en ~S: carácter inválido ~S"

#
# Duda: Lo mismo de antes, he dejado `token' sin traducir
#
#: io.d:1252
#, lisp-format
msgid "~S: input stream ~S ends within a token after single escape character"
msgstr "~S: el flujo de entrada ~S termina con un `token' después de un carácter de escape simple"

#
# Duda: A ver, ¿la palabra `token'?
#       Mientras no se os ocurra algo mejor, lo he dejado en inglés, ...
#
#: io.d:1298
#, lisp-format
msgid "~S: input stream ~S ends within a token after multiple escape character"
msgstr "~S: el flujo de entrada ~S termina con un `token' después de un carácter de escape múltiple"

#: io.d:1816
#, lisp-format
msgid "~S from ~S: ~S has no macro character definition"
msgstr "~S en ~S: ~S no tiene ninguna definición de macro carácter"

#: io.d:1828
#, lisp-format
msgid "~S from ~S: macro character definition for ~S may not return ~S values, only one value."
msgstr "~S en ~S: la definición del macro carácter para ~S no puede devolver ~S valores, sólo puede ser uno."

#: io.d:1849 defs2.lisp:172
#, fuzzy, lisp-format
msgid "~S: input stream ~S ends within read macro beginning with ~S"
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el flujo de entrada ~S ha terminado durante el procesamiento de una macro de lectura que empezaba en ~S\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el flujo de entrada ~S ha terminado mientras se procesaba una macro de lectura en ~S"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:1881 defs2.lisp:199
#, fuzzy, lisp-format
msgid "~S from ~S: After ~S is ~S an undefined dispatch macro character"
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S en ~S: Después de ~S está ~S, un macro carácter sencundario indefinido\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S en ~S: Después de ~S está ~S, que no es un macro carácter secundario"

#: io.d:1893
#, lisp-format
msgid "~S from ~S: dispatch macro character definition for ~S after ~S may not return ~S values, only one value."
msgstr "~S en ~S: la definición del macro carácter secundario de ~S después de ~S sólo puede devolver un valor, no ~S"

# Duda: He traducido `token' tal cual, ... Santiago, imagino que la
# palabra token se queda tal cual. Quiero decir, ¿es necesario lo de las
# comillas? - cll
#
#: io.d:1958
#, lisp-format
msgid "~S from ~S: a token consisting only of dots cannot be meaningfully read in"
msgstr "~S en ~S: no puede leerse correctamente un `token' que consiste únicamente en puntos"

# Duda: Todo el mundo sabe que `colon' es el signo de dos puntos
# `:'. Bueno, pues la traducción del siguiente mensaje podría ser algo
# del estilo: "demasiados signos de dos puntos en el token ...", sin
# embargo, me ha parecido mejor poner los dos puntos directamente, ...
#
#: io.d:2068
#, lisp-format
msgid "~S from ~S: too many colons in token ~S"
msgstr "~S en ~S: demasiados `:' en el `token' ~S"

#: io.d:2075
#, lisp-format
msgid "~S from ~S: token ~S contains an invalid constituent character (see ANSI CL 2.1.4.2.)"
msgstr ""

#: io.d:2122
#, lisp-format
msgid "~S from ~S: there is no package with name ~S"
msgstr "~S en ~S: no existe ningún paquete con el nombre ~S"

#: io.d:2148
#, lisp-format
msgid "~S from ~S: ~S has no external symbol with name ~S"
msgstr "~S en ~S: ~S no tiene ningún símbolo externo con el nombre ~S"

#: io.d:2187
#, lisp-format
msgid "~S from ~S: token \".\" not allowed here"
msgstr "~S en ~S: el `token' \".\" no está permitido aquí"

#: io.d:2213
#, fuzzy, lisp-format
msgid "~S: the value of ~S has been arbitrarily altered to ~S"
msgstr "~S: el valor de ~S ha sido arbitrariamente alterado"

#: io.d:2221
#, lisp-format
msgid "~S: symbol ~S is not bound, it appears that top-level ~S was called with a non-NIL recursive-p argument"
msgstr ""

#: io.d:2257
#, lisp-format
msgid "~S: no entry for ~S from ~S in ~S = ~S"
msgstr "~S: no existe ninguna entrada para ~S de ~S en ~S = ~S"

#: io.d:2468
#, lisp-format
msgid "~S from ~S: illegal end of dotted list"
msgstr "~S en ~S: fin de lista punteada inválido"

#: io.d:2536
#, lisp-format
msgid "~S from ~S: an object cannot start with ~S"
msgstr "~S en ~S: un objeto no puede comenzar por ~S"

#: io.d:2654
#, lisp-format
msgid "~S: input stream ~S ends within a string"
msgstr "~S: el flujo de entrada ~S termina con una cadena"

#: io.d:2717
#, fuzzy, lisp-format
msgid "~S from ~S: no number allowed between # and ~C"
msgstr "~S en ~S: no debe haber ningún número entre # y $"

#: io.d:2806
#, fuzzy, lisp-format
msgid "~S: input stream ~S ends within a comment #~C ... ~C#"
msgstr "~S: el flujo de entrada ~S termina dentro un comentario #$ ... $#"

#: io.d:2873
#, fuzzy, lisp-format
msgid "~S from ~S: font number ~S for character is too large, should be = 0"
msgstr "~S en ~S: el número ~S para la fuente de caracteres es demasiado grande, debe ser < ~S"

#: io.d:2938
#, lisp-format
msgid "~S from ~S: there is no character with name ~S"
msgstr "~S en ~S: no hay ningún carácter con el nombre ~S"

#: io.d:2994
#, fuzzy, lisp-format
msgid "~S from ~S: token ~S after #~C is not a rational number in base ~S"
msgstr "~S en ~S: el `token' ~S después de #$ no es un número racional en base ~S"

#: io.d:3058
#, lisp-format
msgid "~S from ~S: the number base must be given between # and R"
msgstr "~S en ~S: el número de la base debe estar entre # y R"

#: io.d:3071
#, lisp-format
msgid "~S from ~S: The base ~S given between # and R should lie between 2 and 36"
msgstr "~S en ~S: La base ~S entre # y R debe estar entre 2 y 36"

#: io.d:3116
#, lisp-format
msgid "~S from ~S: bad syntax for complex number: #C~S"
msgstr "~S en ~S: sintaxis incorrecta del número complejo: #C~S"

#: io.d:3146
#, lisp-format
msgid "~S from ~S: token expected after #:"
msgstr "~S en : ~S: se esperaba un `token' después de #:"

#: io.d:3173
#, lisp-format
msgid "~S from ~S: token ~S after #: should contain no colon"
msgstr "~S en ~S: el `token' ~S después de #: no debe contener dos puntos"

#: io.d:3198
#, fuzzy, lisp-format
msgid "~S from ~S: ~S is longer than the explicitly given length ~S"
msgstr "~S en ~S: el vector tiene una longitud mayor que la explícitamente indicada ~S"

#: io.d:3207
#, fuzzy, lisp-format
msgid "~S from ~S: must specify elements of ~S of length ~S"
msgstr "~S en ~S: debe especificar un elemento para el vector de longitud ~S"

#: io.d:3217
#, fuzzy, lisp-format
msgid "~S from ~S: invalid ~S length ~S"
msgstr "~S: la longitud de BIT-VECTOR ~S es inválida"

#: io.d:3266
#, lisp-format
msgid "~S from ~S: only zeroes and ones are allowed after #*"
msgstr "~S en ~S: sólo se permiten ceros y unos después de #*"

#: io.d:3413
#, lisp-format
msgid "~S from ~S: bad syntax for array: #A~S"
msgstr "~S en ~S: sintaxis incorrecta en la matriz: #A~S"

#: io.d:3477
#, lisp-format
msgid "~S from ~S: ~S = ~S does not allow the evaluation of ~S"
msgstr "~S en ~S: ~S = ~S no permite la evaluación de ~S"

#: io.d:3592
#, fuzzy, lisp-format
msgid "~S from ~S: a number must be given between # and ~C"
msgstr "~S en ~S: debe indicarse un número entre # y $"

#: io.d:3641
#, lisp-format
msgid "~S from ~S: label #~S= may not be defined twice"
msgstr "~S en ~S: la etiqueta #~S= no puede definirse dos veces"

#: io.d:3668
#, lisp-format
msgid "~S from ~S: #~S= #~S# is illegal"
msgstr "~S en ~S: #~S= #~S# no está permitido"

#: io.d:3692
#, lisp-format
msgid "~S from ~S: undefined label #~S#"
msgstr "~S en ~S: la etiqueta #~S# no está definida"

#: io.d:3706
#, lisp-format
msgid "~S from ~S: objects printed as #<...> cannot be read back in"
msgstr "~S en ~S: los objetos escritos de la manera #<...> no pueden volverse a leer"

#: io.d:3721
#, lisp-format
msgid "~S from ~S: objects printed as # in view of ~S cannot be read back in"
msgstr "~S en ~S: los objetos escritos como # a causa de ~S no pueden volverse a leer"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#: io.d:3751
#, lisp-format
msgid "~S from ~S: illegal feature ~S"
msgstr "~S en ~S: propiedad inválida ~S"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#: io.d:3755
#, fuzzy, lisp-format
msgid "~S: illegal feature ~S"
msgstr "~S en ~S: propiedad inválida ~S"

#: io.d:3923
#, lisp-format
msgid "~S from ~S: #S must be followed by the type and the contents of the structure, not ~S"
msgstr "~S en ~S: #S debe estar seguido del tipo y contenidos de la estructura, no ~S"

#: io.d:3934
#, lisp-format
msgid "~S from ~S: the type of a structure should be a symbol, not ~S"
msgstr "~S en ~S: el tipo de una estructura debe ser un símbolo, no ~S"

#: io.d:3945 io.d:3986
#, lisp-format
msgid "~S from ~S: bad ~S"
msgstr "~S en ~S: ~S es incorrecto"

#: io.d:4040
#, lisp-format
msgid "~S from ~S: bad ~S for ~S"
msgstr "~S en ~S: ~S es incorrecto en ~S"

#: io.d:4050
#, lisp-format
msgid "~S from ~S: no structure of type ~S has been defined"
msgstr "~S en ~S: no se ha definido ninguna estructura del tipo ~S"

#: io.d:4059
#, lisp-format
msgid "~S from ~S: structures of type ~S cannot be read in, missing constructor function"
msgstr "~S en ~S: las estructuras del tipo ~S no pueden leerse, no se conoce la función de construcción"

#: io.d:4080
#, lisp-format
msgid "~S from ~S: a structure ~S may not contain a component \".\""
msgstr "~S en ~S: una estructura ~S no debe contener un componente \".\""

#: io.d:4091
#, lisp-format
msgid "~S from ~S: ~S is not a symbol, not a slot name of structure ~S"
msgstr "~S en ~S: ~S no es un símbolo, ni el nombre de una ranura ni una estructura ~S"

#: io.d:4100
#, lisp-format
msgid "~S from ~S: missing value of slot ~S in structure ~S"
msgstr "~S en ~S: falta el valor de la ranura ~S en la estructura ~S"

#
# Duda: slots se queda tal cual, ...
#
# De acuerdo con la lista spanglish, `slot' se traducirá, en todo el
# CLisp, como "ranura".
#
#: io.d:4119
#, lisp-format
msgid "~S from ~S: too many slots for structure ~S"
msgstr "~S en ~S: hay demasiadas ranuras en la estructura ~S"

#
# "~S en ~S: sintaxis inválida del vector de código de recinto tras #~SY" - lsg
#
# Hmmm, no me acaba de gustar, ... - cll
#
#: io.d:4157
#, lisp-format
msgid "~S from ~S: illegal syntax of closure code vector after #~SY"
msgstr "~S en ~S: sintaxis inválida del vector de código de la cerradura después de #~SY"

#: io.d:4215
#, lisp-format
msgid "~S from ~S: object #Y~S has not the syntax of a compiled closure"
msgstr "~S en ~S: el objeto #Y~S no tiene la sintaxis de una cerradura compilada"

#: io.d:4245
#, fuzzy, lisp-format
msgid "~S from ~S: invalid code vector length ~S"
msgstr "~S: la longitud de BIT-VECTOR ~S es inválida"

#
# pathname NO es array!
# "~S en ~S: sintaxis incorrecta en nombre de path: #A~S" - lsg
#
# Si, es verdad, aquí se me había ido la mano, ...
#
# Además, PATHNAME no se traduce puesto que, o bien se refiere al tipo
# de datos PATHNAME o a la función PATHNAME (en este caso, al tipo de
# datos). Como ambos términos están definidos en el estándar de Common
# Lisp: Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr., pues
# no se traduce y se pone en mayúsculas para distinguirlo de otros
# términos. - cll
#
#: io.d:4363
#, lisp-format
msgid "~S from ~S: bad syntax for pathname: #P~S"
msgstr "~S en ~S: la sintaxis del PATHNAME: #P~S es incorrecta"

# Nota: El siguiente mensaje se debe a la función PEEK-CHAR (Common
# Lisp, The Language - 2nd Edition; Guy L. Steele, Jr; pag. 574), que
# realiza la lectura del siguiente objeto de un flujo de caracteres
# según el valor de su primer argumento opcional `peek-type' que solo
# puede valer, como reza el mensaje, NIL, T o un carácter.
#
#: io.d:4588
#, lisp-format
msgid "~S: peek type should be NIL or T or a character, not ~S"
msgstr "~S: el tipo del PEEK solo puede ser NIL, T o un carácter, y no ~S"

# "~S:argumento de ~S debe ser un entero comprendido entre 2 y 36, no ~S" - lsg
#
# Algo parecido he puesto yo - cll
#
#: io.d:4727
#, fuzzy, lisp-format
msgid "~S: ~S argument ~S is not an integer between 2 and 36"
msgstr "~S: el argumento ~S debe ser un entero comprendido entre 2 y 36, y no ~S"

# "~S: la cadena ~S no tiene sintaxis de entero" - lsg
#
# He cambiado lo "de entero" por "de un número entero", que parece más
# inteligible - cll
#
#: io.d:4826
#, fuzzy, lisp-format
msgid "~S: substring ~S does not have integer syntax at position ~S"
msgstr "~S: la cadena ~S no tiene la sintaxis de un número entero"

#: io.d:4974
#, fuzzy, lisp-format
msgid "~S: Despite ~S, ~S cannot be printed readably."
msgstr "~S: A pesar de ~S, ~S no puede imprimirse de manera legible."

#: io.d:5000
#, lisp-format
msgid ""
"~S: the value ~S of ~S is neither ~S nor ~S nor ~S.\n"
"It is reset to ~S."
msgstr ""
"~S: el valor ~S de ~S no es ~S ni ~S ni ~S.\n"
"Ha sido inicializado a ~S."

#: io.d:5578
#, lisp-format
msgid "~S: must be a positive integer or NIL, not ~S"
msgstr "~S: debe ser un número positivo entero o NIL, pero no ~S"

# "~S: espacio insuficiente en la pila para realizar un análisis de circularidad" - lsg
#
# Vale - cll
#
#: io.d:6597
#, lisp-format
msgid "~S: not enough stack space for carrying out circularity analysis"
msgstr "~S: no hay espacio suficiente en la pila para realizar un análisis de circularidad"

#: io.d:8349
#, fuzzy, lisp-format
msgid "~S: bad class"
msgstr "~S: incorrecto ~S"

#: io.d:9471
#, lisp-format
msgid "~S: an unknown record type has been generated!"
msgstr "~S: se ha generado un tipo de registro desconocido!"

#: io.d:10016
#, fuzzy, lisp-format
msgid "~S: argument ~S is too large"
msgstr "~S: el argumento ~S no es un string"

#: io.d:10038
#, fuzzy, lisp-format
msgid "~S: argument ~S should be ~S or ~S."
msgstr "~S: el argumento ~S debe ser un flujo"

#: io.d:10079 weak.d:684
#, fuzzy, lisp-format
msgid "~S: argument ~S should be ~S, ~S, ~S or ~S."
msgstr "~S: el argumento ~S debe ser ~S, ~S, ~S, ~S, ~S, ~S o ~S"

#
# aLarge no es largo, sino grande!! - lsg
#
# Tienes toda la razón, ya lo he cambiado en todos los mensajes - cll
#
#: array.d:239
msgid "index too large"
msgstr "índice demasiado grande"

# FIXME. Esto no cabe en 80 columnas. Comunicar al autor (?) sv
#
# "Una formación ha sido acortada mediante un ajuste al trasladar otra formación hacia ella"
# O bien, para que quepa en 80 columnas:
# "Una formación ha sido acortada al trasladar otra formación hacia ella" - lsg
#
# Yo había puesto:
#
# "Una matriz ha sido acortada debido a un ajuste cuando otra se ha desplazado "
# "hacia ella"
#
# Y ciertamente me gusta más tu traducción, salvo que en vez de
# formaciones hay que hablar de matrices, ¿no crees? - cll
#
#: array.d:244
msgid "An array has been shortened by adjusting it while another array was displaced to it."
msgstr "Una matriz ha sido acortada al trasladar otra matriz ella"

#: array.d:348 foreign.d:2648
#, lisp-format
msgid "~S: got ~S subscripts, but ~S has rank ~S"
msgstr "~S: se encontraron ~S subíndices, pero ~S tiene rango ~S"

#: array.d:360 foreign.d:2663
#, lisp-format
msgid "~S: subscripts ~S for ~S are not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~S: los subíndices ~S de ~S no son del tipo '(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:382 foreign.d:2672
#, lisp-format
msgid "~S: subscripts ~S for ~S are out of range"
msgstr "~S: los subíndices ~S de ~S han excedido el rango"

#: array.d:439
#, lisp-format
msgid "~S: index ~S for ~S is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~S: el índice ~S de ~S no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:456
#, lisp-format
msgid "~S: index ~S for ~S is out of range"
msgstr "~S: el índice ~S de ~S ha excedido el rango"

#: array.d:503
#, lisp-format
msgid "~S: cannot retrieve values from an array of element type NIL"
msgstr ""

#: array.d:509
#, fuzzy, lisp-format
msgid "~S: cannot store values in an array of element type NIL"
msgstr "~S: ~S no puede convertirse al tipo ~S"

#: array.d:515
#, fuzzy, lisp-format
msgid "~S: cannot access values of an array of element type NIL"
msgstr "~S: ~S no puede convertirse al tipo ~S"

#: array.d:560
#, lisp-format
msgid "~S: ~S does not fit into ~S, bad type"
msgstr "~S: ~S no cabe en ~S, tipo incorrecto"

#: array.d:564
#, fuzzy, lisp-format
msgid "~S: ~S cannot be stored in an array of element type NIL"
msgstr "~S: ~S no puede convertirse al tipo ~S"

#: array.d:937
#, lisp-format
msgid "~S: ~S is not an nonnegative integer less than the rank of ~S"
msgstr "~S: ~S no es un entero no negativo menor que el rango de ~S"

#: array.d:1162
#, lisp-format
msgid "~S: ~S is not an array of bits"
msgstr "~S: ~S no es una matriz de bits"

#: array.d:1963
#, lisp-format
msgid "~S: The arguments ~S and ~S should be arrays of bits with the same dimensions"
msgstr "~S: Los argumentos ~S y ~S deben ser matrices de bits de la misma dimensión"

#: array.d:1972
#, lisp-format
msgid "~S: The arguments ~S, ~S and ~S should be arrays of bits with the same dimensions"
msgstr "~S: Los argumentos ~S, ~S y ~S deben ser matrices de bits de la misma dimensión"

#: array.d:3748
#, lisp-format
msgid "~S: vector ~S has no fill pointer"
msgstr "~S: el vector ~S no tiene ningún puntero de relleno"

#: array.d:3812
#, lisp-format
msgid "~S: ~S has length zero"
msgstr "~S: ~S tiene longitud nula"

#: array.d:3824
#, lisp-format
msgid "~S: extending the vector by ~S elements makes it too long"
msgstr "~S: ampliar el vector en ~S elementos, lo hace muy grande"

#: array.d:3845
#, lisp-format
msgid "~S works only on adjustable arrays, not on ~S"
msgstr "~S funciona sólo con matrices ajustables, no con ~S"

#: array.d:3862
#, lisp-format
msgid "~S: extension ~S should be a positive fixnum"
msgstr "~S: la extensión ~S debe ser un número positivo del tipo FIXNUM"

#: array.d:3955
#, lisp-format
msgid "~S: cannot push ~S into array ~S (bad type)"
msgstr "~S: no se puede introducir ~S en la matriz ~S (tipo incorrecto)"

#: array.d:4020
#, lisp-format
msgid "~S: dimension ~S is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~S: la dimensión ~S no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:4282
#, lisp-format
msgid "~S: dimensions ~S produce too large total-size"
msgstr "~S: las dimensiones ~S producen un tamaño total demasiado grande"

#: array.d:4323
#, lisp-format
msgid "~S: ambiguous, more than one initialization specified"
msgstr "~S: ambiguo, se ha especificado más de una inicialización"

#: array.d:4332
#, lisp-format
msgid "~S: ~S must not be specified without ~S"
msgstr "~S: ~S no debe especificarse sin ~S"

#: array.d:4354
#, lisp-format
msgid "~S: the initial-element ~S is not of type ~S"
msgstr "~S: el INITIAL-ELEMENT ~S no es del tipo ~S"

#: array.d:4486
#, lisp-format
msgid "~S: ~S is of incorrect length"
msgstr "~S: ~S no tiene la longitud correcta"

#: array.d:4510
#, lisp-format
msgid "~S: ~S-argument ~S is not an array"
msgstr "~S: El ~S argumento ~S no es una matriz"

#: array.d:4527
#, lisp-format
msgid "~S: ~S-argument ~S does not have element type ~S"
msgstr "~S: El ~S argumento ~S no tiene como tipo de elemento ~S"

#: array.d:4542
#, lisp-format
msgid "~S: ~S-argument ~S is not of type `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"
msgstr "~S: El ~S argumento ~S no es del tipo `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"

#: array.d:4552
#, lisp-format
msgid "~S: array-total-size + displaced-offset (= ~S) exceeds total size ~S of ~S-argument"
msgstr "~S: array-total-size + displaced-offset (= ~S) excede el tamaño total ~S del ~S argumento"

#: array.d:4573
#, lisp-format
msgid "~S: fill-pointer ~S should be a nonnegative fixnum"
msgstr "~S: El puntero de relleno ~S debe ser un número no negativo del tipo FIXNUM"

#: array.d:4580
#, lisp-format
msgid "~S: fill-pointer argument ~S is larger than the length ~S"
msgstr "~S: El argumento FILL-POINTER ~S es mayor que la longitud ~S"

#
# "~S: el rango intentado ~S es demasiado grande" - lsg
#
# De acuerdo - cll
#
#: array.d:4648
#, lisp-format
msgid "~S: attempted rank ~S is too large"
msgstr "~S: el rango intentado ~S es demasiado grande"

#: array.d:4661
#, lisp-format
msgid "~S: ~S may not be specified for an array of rank ~S"
msgstr "~S: ~S no debe especificarse para una matriz de rango ~S"

#: array.d:4856
#, lisp-format
msgid "~S: rank ~S of array ~S cannot be altered: ~S"
msgstr "~S: no es posible cambiar el rango ~S de la matriz ~S: ~S"

#
# "~S: los elementos de la formación ~S no son de tipo ~S" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#: array.d:4876
#, lisp-format
msgid "~S: array ~S does not have element-type ~S"
msgstr "~S: los elementos de la matriz ~S no son del tipo ~S"

#: array.d:4989
#, lisp-format
msgid "~S: cannot displace array ~S to itself"
msgstr "~S: no se puede desplazar la matriz ~S hacia ella misma"

#: array.d:5020
#, lisp-format
msgid "~S: the fill-pointer of array ~S is ~S, greater than ~S"
msgstr "~S: el puntero de relleno de la matriz ~S es ~S que es mayor que ~S"

# ... de la misma forma que uno no pone "START Índice" sv
#
# Si, si, ..., tienes toda la razón, ... cll
#
#: array.d:5142
#, lisp-format
msgid "Illegal START index ~S for ~S"
msgstr "Índice START ~S inválido en ~S"

#: array.d:5170
#, lisp-format
msgid "Illegal END index ~S for ~S"
msgstr "Índice END ~S inválido en ~S"

#: array.d:5183
#, lisp-format
msgid "~S: invalid bit-vector length ~S"
msgstr "~S: la longitud de BIT-VECTOR ~S es inválida"

#: hashtabl.d:1371
#, lisp-format
msgid "Performance/scalability warning: The hash table ~S needs to be rehashed after a garbage collection, since it contains key whose hash code is not GC-invariant."
msgstr ""

#: hashtabl.d:1558
#, lisp-format
msgid "Performance/scalability warning: The hash table ~S must be rehashed after each garbage collection, since its key ~S has a hash code that is not GC-invariant."
msgstr ""

# Duda: hash lo he traducido por hash. ¿Alguna sugerencia? ¿Tablas de
# acceso rápido, o algo así?. Tened en cuenta que en Common Lisp, las
# tablas hash son una estructura bien definida que cuenta con sus
# propias instrucciones. A mí me gusta tal cual, ...
# Sugerencia: tabla de `hash'. sv
#
# No, no, no, no, ... :) `hash table' es `tabla hash'. Si se quiere,
# podríamos traducir la palabra `hash' pero si se deja es `tabla
# hash'. Todos los informáticos las llamamos así. Jamás he oído `Tabla
# *de* hash' cll
#
#: hashtabl.d:1706
#, lisp-format
msgid "Hash table size ~S too large"
msgstr "La tabla hash ~S es demasiado grande"

#
# "error interno al redimensionar ~S" - lsg
#
# Me gusta, salvo que el error ocurre "durante" - cll
#
#: hashtabl.d:1753
#, lisp-format
msgid "internal error occured while resizing ~S"
msgstr "error interno durante el redimensionamiento de ~S"

#: hashtabl.d:1867 hashtabl.d:1887 hashtabl.d:1907
#, fuzzy, lisp-format
msgid ""
"~S: The value of ~S should be ~S or ~S, not ~S.\n"
"It has been reset to ~S."
msgstr ""
"~S: el valor ~S de ~S no es ~S ni ~S ni ~S.\n"
"Ha sido inicializado a ~S."

#: hashtabl.d:1927
#, fuzzy, lisp-format
msgid "~S: argument ~S should be ~S, ~S, ~S, ~S or ~S."
msgstr "~S: el argumento ~S debe ser ~S, ~S, ~S, ~S, ~S, ~S o ~S"

#: hashtabl.d:2046
#, fuzzy, lisp-format
msgid "~S: ~S argument should be a fixnum >=0, not ~S"
msgstr "~S : El argumento debe ser del tipo FIXNUM >=0 y no ~S"

#: hashtabl.d:2068
#, fuzzy, lisp-format
msgid "~S: ~S argument should be an integer or a float > 1, not ~S"
msgstr "~S: el argumento debe ser un entero, no ~S"

# "~S:argumento de ~S debe ser un entero comprendido entre 2 y 36, no ~S" - lsg
#
# Algo parecido he puesto yo - cll
#
#: hashtabl.d:2113
#, fuzzy, lisp-format
msgid "~S: ~S argument should be a real between 0 and 1, not ~S"
msgstr "~S: el argumento ~S debe ser un entero comprendido entre 2 y 36, y no ~S"

#: hashtabl.d:2207
#, lisp-format
msgid "~S: internal error while building ~S"
msgstr "~S: error interno durante la construcción de ~S"

#: hashtabl.d:2251
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a hash table"
msgstr "~S: el argumento ~S no es un carácter"

#: list.d:747
#, fuzzy, lisp-format
msgid "~S: ~S is a circular list"
msgstr "~S: ~S no es un par"

#: list.d:1145
#, lisp-format
msgid "~S: ~S is not a pair"
msgstr "~S: ~S no es un par"

#: list.d:1669
#, lisp-format
msgid "~S: lists ~S and ~S are not of same length"
msgstr "~S: las listas ~S y ~S no son de la misma longitud"

#: list.d:1845
#, lisp-format
msgid "~S: index ~S too large for ~S"
msgstr "~S: el índice ~S es demasiado grande para ~S"

#: list.d:1897
#, lisp-format
msgid "~S: start index ~S too large for ~S"
msgstr "~S: el índice :START ~S es demasiado grande para ~S"

#: list.d:1937
#, lisp-format
msgid "~S: end index ~S too large for ~S"
msgstr "~S: el índice :END ~S es demasiado grande para ~S"

#: package.d:353
#, lisp-format
msgid "symbol ~S cannot be deleted from symbol table"
msgstr "el símbolo ~S no puede ser borrado de la tabla de símbolos"

#: package.d:669
#, lisp-format
msgid "~S inconsistent: symbol ~S is a shadowing symbol but not present"
msgstr "inconsistencia en ~S: el símbolo ~S es un símbolo que eclipsa a otro/s, sin embargo no está presente."

#: package.d:703
msgid "Ignore the lock and proceed"
msgstr ""

#: package.d:704
#, lisp-format
msgid "~A(~S): ~S is locked"
msgstr ""

#: package.d:939
#, fuzzy
msgid "symbol ~A from ~A will become a shadowing symbol"
msgstr "el símbolo ~A del paquete #<PACKAGE ~A> se convertirá en un símbolo que eclipsa a otro"

#: package.d:970
#, fuzzy, lisp-format
msgid ""
"Uninterning ~S from ~S uncovers a name conflict.\n"
"You may choose the symbol in favour of which to resolve the conflict."
msgstr "Puede elegir el símbolo en favor del cual se resolverá el conflicto."

#
# publicar está mal y ademas no es consistente con el mensaje d:329 en el que dice 'sacar'
# En este y en otros mensajes, el texto no es una orden dada al usuario, sino una opción que
# se le ofrece. Por tanto, no debe traducirse como un imperativo (impórtelo)  sino en
# infinitivo (importarlo). Pero deberías confirmar esto. - lsg
#
# Si, creo que tienes toda la razón, ... Entonces pongo `sacar' que
# aunque suene muy burro, creo que es muy, muy claro, ...
#
#: package.d:1018
#, fuzzy
msgid "((IMPORT \"import it and unintern the other symbol\" . T) (IGNORE \"do not import it, leave undone\" . NIL))"
msgstr "((\"I\" \"impórtarlo y sacar el otro símbolo\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Aquí tengo la misma duda anterior - lsg
#
#: package.d:1022
#, fuzzy
msgid "((IMPORT \"import it, unintern one other symbol and shadow the other symbols\" . T) (IGNORE \"do not import it, leave undone\" . NIL))"
msgstr "((\"I\" \"importarlo, sacar uno de los otro símbolos y eclipsar el resto\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Lo mismo de antes - lsg
#
#: package.d:1026
#, fuzzy
msgid "((IMPORT \"import it and shadow the other symbol\" . T) (IGNORE \"do nothing\" . NIL))"
msgstr "((\"I\" \"importarlo y eclipsar el otro símbolo\" T) (\"N\" \"no hacer nada\" NIL))"

#: package.d:1032
#, fuzzy, lisp-format
msgid "Importing ~S into ~S produces a name conflict with ~S and other symbols."
msgstr "la importación de ~SS en ~SS produce un conflicto de nombres con ~SS y otros símbolos."

#: package.d:1033
#, fuzzy, lisp-format
msgid "Importing ~S into ~S produces a name conflict with ~S."
msgstr "la importación de ~SS en ~SS produce un conflicto de nombres con ~SS."

#: package.d:1133
#, lisp-format
msgid "UNEXPORT in ~S is illegal"
msgstr "UNEXPORT en ~S es inválido"

#
# "UNEXPORT sólo funciona con símbolos accesibles, no con ~S en ~S" - lsg
#
# Ya, o sea, que cambie "sobre" por "con". Vale, me gusta mucho más tu
# mensaje que el mío - cll
#
#: package.d:1152
#, lisp-format
msgid "UNEXPORT works only on accessible symbols, not on ~S in ~S"
msgstr "UNEXPORT sólo funciona sobre símbolos accesibles, no con ~S en ~S"

#
# La misma cuestión anterior entre imperativo e infinitivo - lsg
#
#: package.d:1200
#, fuzzy
msgid "((IMPORT \"import the symbol first\" . T) (IGNORE \"do nothing, do not export the symbol\" . NIL))"
msgstr "((\"I\" importar el símbolo primero\" T) (\"N\" \"no hacer nada, no exportar el símbolo\"))"

#: package.d:1202
#, fuzzy, lisp-format
msgid "~S: Symbol ~S should be imported into ~S before being exported."
msgstr "el símbolo ~SS debe ser importado a ~SS antes de ser exportado."

#: package.d:1236
msgid "the symbol to export, "
msgstr "el símbolo a exportar, "

#: package.d:1247
msgid "the old symbol, "
msgstr "El símbolo original, "

#
# El segundo from deberia ser 'de', porque quiere decir que un símbolo
# a de un paquete A entra en conflicto con el símbolo b _del_ paquete
# B. Luego, debe ser 'de'.
#
#: package.d:1261
#, fuzzy, lisp-format
msgid ""
"Exporting ~S from ~S produces a name conflict with ~S from ~S.\n"
"You may choose which symbol should be accessible in ~S."
msgstr "la exportación de ~SS desde ~SS produce un conflicto de nombres con ~SS de ~SS."

#: package.d:1488
#, fuzzy, lisp-format
msgid ""
"(~S ~S ~S): ~S name conflicts remain\n"
"Which symbol with name ~S should be accessible in ~S?"
msgstr "¿ Qué símbolo con nombre ~SS debe ser accesible en ~SS ?"

#: package.d:1722
#, fuzzy, lisp-format
msgid "The value of *PACKAGE* was not a package and was reset. The old value was ~S. The new value is ~S."
msgstr "El valor de *PACKAGE* no era un paquete. Valor anterior ~S. Nuevo valor ~S."

#: package.d:1723
msgid "Proceed with the new value."
msgstr ""

#: package.d:1746
#, fuzzy, lisp-format
msgid "~S: Package ~S has been deleted."
msgstr "El paquete ~S ha sido borrado."

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~SS.",
# pienso que "No hay ningún paquete con el nombre ~SS" es ligeramente
# mejor, ¿qué te parece? - cll
#
#: package.d:1758
#, fuzzy, lisp-format
msgid "~S: There is no package with name ~S"
msgstr "~SS: No hay ningún paquete con el nombre ~SS."

#: package.d:1775
#, lisp-format
msgid "~S: argument should be a package or a package name, not ~S"
msgstr "~S: el argumento debe ser un paquete o el nombre de un paquete, no ~S"

#: package.d:1887
#, lisp-format
msgid "~S: there is already a package named ~S"
msgstr "~S: ya hay un paquete llamado ~S"

#
# "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: package.d:2186
#, lisp-format
msgid "~S: argument should be a symbol or a list of symbols, not ~S"
msgstr "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S"

#: package.d:2315
msgid "discard this nickname"
msgstr ""

#: package.d:2316
msgid "return the existing package"
msgstr ""

#: package.d:2320
#, fuzzy
msgid "input another nickname"
msgstr "Puede introducir otro apodo."

#: package.d:2321
#, fuzzy
msgid "input another name"
msgstr "Puede introducir otro nombre."

#: package.d:2327
#, fuzzy, lisp-format
msgid "~S: a package with name ~S already exists."
msgstr "ya existe un paquete con el nombre ~SS."

#: package.d:2418
#, fuzzy, lisp-format
msgid "One should not change the case sensitiveness of ~S."
msgstr "No es posible cambiar las mayúsculas/minúsculas de ~S."

#: package.d:2429
#, fuzzy, lisp-format
msgid "One should not change the case inversion of ~S."
msgstr "No es posible cambiar las mayúsculas/minúsculas de ~S."

# Ojo con el ignorar. sv
#
# No, ya te he puesto antes las acepciones de esta palabra y esta vez,
# viene al caso, ... cll
#
# O sea, que estás 'ignorando ' la sugerencia de sv, ;-) - lsg
#
# Muy bueno, muy bueno, ... :) Santiago, por aquí hay mucho cachondeo :) - cll
#
#
#: package.d:2499
msgid "Ignore."
msgstr "Ignorar."

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~S.",
# pienso que "No hay ningún paquete con el nombre ~S" es ligeramente
# mejor, ¿qué te parece? - cll
#
#: package.d:2500
#, lisp-format
msgid "~S: There is no package with name ~S."
msgstr "~S: No hay ningún paquete con el nombre ~S."

#: package.d:2528
#, lisp-format
msgid "~*Delete ~S anyway."
msgstr ""

#
# Leo, en vez de "está siendo utilizado", ¿no crees que es mejor "es
# utilizado"? - cll
#
# Propongo *se utiliza*, es mucho más español. sv
#
# Pero, ¿cómo pones algo así? "~S se utiliza en ~{~S~^, ~}.", ¿por
# ejemplo? Es que el problema es que no ~S (el primero) no "se utiliza"
# en la segunda expresión, sino que la segunda expresión es una que
# emplea a la primera. No se si me explico, ...
#
# En cualquier caso, creo que tienes toda la razón al decir "es mucho
# más español", es que de hecho la expresión "es utilizado" aunque es
# correcta, no parece muy española, por favor, ¿sugerencias? - cll
#
#: package.d:2529
#, lisp-format
msgid "~S: ~S is used by ~{~S~^, ~}."
msgstr "~S: ~S es utilizado por ~{~S~^, ~}."

#: package.d:2698
#, fuzzy, lisp-format
msgid "~S: ~S is not using ~S"
msgstr "Esto no es una cadena: ~S"

#: record.d:32
#, lisp-format
msgid "~S: ~S is not a valid index into ~S"
msgstr "~S: ~S no es un índice válido en ~S"

#: record.d:40
#, lisp-format
msgid "~S: ~S is not a record"
msgstr "~S: ~S no es un registro"

#: record.d:99
#, fuzzy, lisp-format
msgid "~S: length ~S should be of type ~S"
msgstr "~S: el argumento ~S debe ser un flujo del tipo ~S"

#: record.d:132
#, lisp-format
msgid "~S: ~S is not a structure of type ~S"
msgstr "~S: ~S no es una estructura del tipo ~S"

#: record.d:180
#, fuzzy, lisp-format
msgid "~S: Slot ~S of ~S has no value"
msgstr "~S: Una ranura de ~S no tiene valor"

#: record.d:284 trace.lisp:72
#, lisp-format
msgid "~S: ~S is not a closure"
msgstr "~S: ~S no es una cerradura"

#: record.d:312
#, fuzzy, lisp-format
msgid "~S: ~S is not a compiled closure"
msgstr "~S: No se trata de una cerradura compilada: ~S"

#: record.d:401
#, lisp-format
msgid "~S is not a valid code-vector byte"
msgstr "~S no es un byte CODE-VECTOR válido"

#: record.d:412
#, fuzzy, lisp-format
msgid "~S: invalid side-effect class ~S for function ~S"
msgstr "~SS: especificación inválida de ranura y función de acceso: ~SS"

#: record.d:439
#, lisp-format
msgid "~S: function ~S is too big: ~S"
msgstr "~S: la función ~S es demasiado grande: ~S"

#: record.d:547
#, fuzzy, lisp-format
msgid "~S: argument is not a funcallable instance: ~S"
msgstr "~S: el argumento no es una variable extranjera: ~S"

#: record.d:554
#, fuzzy, lisp-format
msgid "~S: argument is not a function: ~S"
msgstr "~S: el argumento no es una función extranjera: ~S"

#: record.d:617
#, fuzzy, lisp-format
msgid "~S: This is not a prototype of a generic function: ~S"
msgstr "~S: Ésta no es una función genérica: ~S"

#: record.d:811
#, lisp-format
msgid "Due to the compiler optimization settings, lambda list for ~S is not available"
msgstr ""

#: record.d:954
#, fuzzy, lisp-format
msgid "~S: ~S is not a CLOS class-version"
msgstr "~S: ~S no es una clase"

#: record.d:1041
#, fuzzy, lisp-format
msgid "~S: invalid initialization argument ~S"
msgstr "~S: el argumento ~S es inválido"

#: record.d:1129
#, lisp-format
msgid "~S: Invalid location ~S of slot ~S in ~S (check the :ALLOCATION slot option)"
msgstr ""

#
# "EVAL: la lista de argumentos pasada a ~S es punteada: ~S" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: record.d:1146
#, fuzzy, lisp-format
msgid "~S: invalid arguments: class argument ~S is not the class of ~S"
msgstr "EVAL: la lista de argumentos entregada a ~S está punteada: ~S"

#: record.d:1366
#, fuzzy, lisp-format
msgid "~S: invalid slot location ~S"
msgstr "~S ~S: la opción ~S es inválida"

#: record.d:1372
#, fuzzy, lisp-format
msgid "~S: not a CLOS instance: ~S"
msgstr "~S: no es una lista: ~S"

#: record.d:2064 clos-class5.lisp:633
#, lisp-format
msgid "~S method for ~S returned ~S"
msgstr ""

#: weak.d:436 weak.d:538
#, fuzzy, lisp-format
msgid "~S: the keys list argument is empty"
msgstr "~S: se han entregado demasiados argumentos a ~S"

#: weak.d:649
#, fuzzy, lisp-format
msgid "~S: ~S is not an association list"
msgstr "~S: ~S no es un par"

#: sequence.d:271
#, lisp-format
msgid "There are no sequences of type ~S"
msgstr "No hay secuencias del tipo ~S"

#: sequence.d:359
#, lisp-format
msgid "~S: sequence type forces length ~S, but result has length ~S"
msgstr ""

#: sequence.d:371
#, lisp-format
msgid "~S: ~S should be an integer >=0, not ~S"
msgstr "~S: ~S debe ser un entero >=0, no ~S"

#: sequence.d:415 sequence.d:442
#, lisp-format
msgid "~S: ~S = ~S should not be greater than ~S = ~S"
msgstr "~S: ~S = ~S no debe ser mayor que ~S = ~S"

#: sequence.d:583
#, lisp-format
msgid "~S: the index should be a fixnum >=0, not ~S"
msgstr "~S: el índice debe ser un número >=0 del tipo FIXNUM, no ~S"

#: sequence.d:848 sequence.d:1194
#, lisp-format
msgid "~S: bad length ~S"
msgstr "~S: longitud incorrecta ~S"

#: sequence.d:956
#, fuzzy, lisp-format
msgid "~S: the result ~S is not of type ~S"
msgstr "~S: ~S no es un par"

#: sequence.d:978
#, lisp-format
msgid "~S: size should be an integer >=0, not ~S"
msgstr "~S: el tamaño debe ser un entero >=0, no ~S"

#: sequence.d:984
#, fuzzy, lisp-format
msgid "~S: :UPDATE must not be specified without :INITIAL-ELEMENT"
msgstr "~: ~ no debe especificarse sin ~"

#: sequence.d:2011
#, fuzzy, lisp-format
msgid "~S: sequence ~S is too long: ~S is not a FIXNUM"
msgstr "~S: la secuencia ~S es demasiado larga"

#: charstrg.d:1586
#, lisp-format
msgid "~S: the radix must be an integer between 2 and 36, not ~S"
msgstr "~S: la base debe ser un entero entre 2 y 36, no ~S"

#: charstrg.d:1931
#, lisp-format
msgid "~S: the code argument should be an integer, not ~S"
msgstr "~S: el argumento del código debe ser un entero y no ~S"

# "~S: no se puede convertir ~S al tipo character"
#
# No sé si traducir la palabra character, puesto que es una palabra
# clave en Lisp. - lsg
#
# Yo ya había traducido este mensaje como:
#
# "~S: ~S no puede convertirse a un carácter"
#
# Pero el tuyo me gusta mucho más, salvo que `character', puesto que es
# un término definido en el estándar Common Lisp, debe ir en mayúsculas
# - cll
#
#: charstrg.d:1952
#, lisp-format
msgid "~S: cannot coerce ~S to a character"
msgstr "~S: no se puede convertir ~S al tipo CHARACTER"

#: charstrg.d:1985
#, lisp-format
msgid "~S: the weight argument should be an integer, not ~S"
msgstr "~S: el argumento de ponderación debe ser un entero, y no ~S"

#: charstrg.d:2021
#, lisp-format
msgid "~S: argument should be an integer, not ~S"
msgstr "~S: el argumento debe ser un entero, no ~S"

#: charstrg.d:2168 compiler.lisp:7158
#, lisp-format
msgid "~S: index should be an integer, not ~S"
msgstr "~S: el índice debe ser un entero, no ~S"

#: charstrg.d:2171
#, lisp-format
msgid "~S: ~S-index should be an integer, not ~S"
msgstr "~S: el índice ~S debe ser un entero, no ~S"

#: charstrg.d:2182
#, lisp-format
msgid "~S: index should be NIL or an integer, not ~S"
msgstr "~S: el índice debe ser NIL o un entero, no ~S"

#: charstrg.d:2185
#, lisp-format
msgid "~S: ~S-index should be NIL or an integer, not ~S"
msgstr "~S: el índice ~S debe ser NIL o un entero, no ~S"

#: charstrg.d:2196
#, lisp-format
msgid "~S: index should not be negative: ~S"
msgstr "~S: el índice no debe ser negativo: ~S"

#: charstrg.d:2199
#, lisp-format
msgid "~S: ~S-index should not be negative: ~S"
msgstr "~S: el índice ~S no debe ser negativo: ~S"

#: charstrg.d:2217
#, lisp-format
msgid "~S: index ~S should not be greater than the length of the string"
msgstr "~S: el índice ~S no debe ser mayor que la longitud de la cadena"

#: charstrg.d:2220
#, lisp-format
msgid "~S: ~S-index ~S should not be greater than the length of the string"
msgstr "~S: el índice ~S = ~S no debe ser mayor que la longitud de la cadena"

#: charstrg.d:2239
#, lisp-format
msgid "~S: index ~S should be less than the length of the string"
msgstr "~S: el índice ~S debe ser menor que la longitud de la cadena"

#: charstrg.d:2242
#, lisp-format
msgid "~S: ~S-index ~S should be less than the length of the string"
msgstr "~S: el índice ~S = ~S debe ser menor que la longitud de la cadena"

#: charstrg.d:2401 charstrg.d:2505 charstrg.d:3711
#, fuzzy, lisp-format
msgid "~S: :START-index ~S must not be greater than :END-index ~S"
msgstr "~S: El índice :start ~S no debe ser mayor que el índice :end ~S"

#: charstrg.d:2466
#, fuzzy, lisp-format
msgid "~S: argument ~S should be a string, a symbol or a character"
msgstr "~S: el argumento ~S debe ser del tipo string o string-char, o un símbolo"

#: charstrg.d:2555
#, fuzzy, lisp-format
msgid "~S: :START1-index ~S must not be greater than :END1-index ~S"
msgstr "~S: El índice :start ~S no debe ser mayor que el índice :end ~S"

#: charstrg.d:2578
#, fuzzy, lisp-format
msgid "~S: :START2-index ~S must not be greater than :END2-index ~S"
msgstr "~S: El índice :start ~S no debe ser mayor que el índice :end ~S"

#: charstrg.d:3194
#, lisp-format
msgid "~S: the string length ~S should be nonnegative fixnum"
msgstr ""
"~S: la longitud de la cadena de caracteres ~S debe ser un número no negativo\n"
"del tipo FIXNUM"

#: charstrg.d:3226
#, fuzzy, lisp-format
msgid "~S: ~S argument ~S should be of type ~S"
msgstr "~S: el argumento ~S debe ser un flujo del tipo ~S"

#
# Duda: esta traducción ha sido muy difícil, y está basada en la
# traducción francesa que dice: "~S: Mauvais mode de saut d'environnement
# ~S."
#
#: debug.d:857
#, fuzzy, lisp-format
msgid "~S: bad frame climbing mode ~S"
msgstr "~S: modo de salto de marco incorrecto"

#: debug.d:875
#, lisp-format
msgid "~S: ~S is not a stack pointer"
msgstr "~S: ~S no es un puntero de pila"

#: debug.d:1043
#, lisp-format
msgid "~S: ~S is not a pointer to an EVAL/APPLY frame"
msgstr "~S: ~S no es un puntero a un marco de tipo EVAL/APPLY"

#: debug.d:1205
msgid "APPLY frame with breakpoint for call "
msgstr "marco APPLY con punto de ruptura para invocar "

#: debug.d:1208
msgid "APPLY frame for call "
msgstr "marco APPLY para invocar "

#: debug.d:1225
msgid "EVAL frame with breakpoint for form "
msgstr "marco EVAL con punto de ruptura para la forma "

#: debug.d:1228
msgid "EVAL frame for form "
msgstr "marco EVAL para la forma "

#
# A ver aquí, que hay mogollón, hay mogollón, ...
#
# Leo, tu opinas que aquí deberíamos traducir:
#
# "variables con vinculación de recintos (~ = dinámicamente):"
#
# Sin embargo, yo creo que lo más correcto es:
#
# "trama de ligadura de las variables (~ = dinámicamente):"
#
# Puesto que esto se refiere al tipo de tramas que hay en la pila,
# cuando ésta está siendo examinada. De hecho, la traducción francesa
# es:
#
# "Le «frame» de liaison de variables (~ signifiant dynamique) lie :"
#
# ..., que viene a ser algo como lo que he puesto yo. - cll
#
#: debug.d:1233
msgid "frame binding variables (~ = dynamically):"
msgstr "marco de ligadura de las variables (~ = dinámicamente):"

#: debug.d:1249
msgid "CALLBACK frame"
msgstr "marco CALLBACK"

#: debug.d:1254
msgid "frame binding variables "
msgstr "marco de ligadura de las variables"

#: debug.d:1257 debug.d:1286
msgid " binds (~ = dynamically):"
msgstr " vincula (~ = dinámicamente):"

#: debug.d:1282
msgid "frame binding functions "
msgstr "marco de ligadura de las funciones "

# Un poco más en español podría ser: "Entorno siguiente: " sv
#
# Hmmm, ..., aquí no estoy de acuerdo contigo. No me suena bien lo del
# "Entorno siguiente", ... cll
#
#: debug.d:1306 debug.d:1377
msgid "  Next environment: "
msgstr "  Siguiente entorno: "

#: debug.d:1332
msgid "compiled tagbody frame for "
msgstr "marco compilado del cuerpo de etiquetas de salto para "

#: debug.d:1336
msgid "compiled block frame for "
msgstr "marco de bloque compilado para "

#: debug.d:1342
msgid "block frame "
msgstr "marco de bloque"

#: debug.d:1345
msgid "nested block frame "
msgstr "marco anidado de bloque"

#: debug.d:1350
msgid " for "
msgstr " para "

#: debug.d:1355
msgid "tagbody frame "
msgstr "marco de cuerpo de etiquetas de salto"

# Duda: Aquí lo de `nested' es bastante puñetero. Creo que no debe
# traducirse por `anidado' (que no tendría demasiado sentido, creo),
# sino por `encajada', haciendo referencia a la trama a la que se llega
# por el uso de las etiquetas de salto, ...
#
# Sin embargo, no estoy demasiado seguro, ... aSocorro!! - cll
#
# A propósito de esta cuestión, pregunté en la lista de correo de CLisp:
#
# > `nested' have various meanings. It can mean that one thing is `into'
# > other one or that one thing is `joined' with other one. In this
# > message, I think you are talking about the frame you arrive when using
# > a tag, as if you were `joining' a new frame, is it so?
#
# Y la respuesta de Bruno Haible fue:
#
# No. In CLISP it's yet another (maybe new?) meaning. Interpretation frames
# are normally built up in the stack. However, when a closure is created,
# some parts of the frames must be moved out to the heap, so that the
# closure points to valid data, called "environment", even after the frame
# has been deestablished. We called this process "nesting" of a frame.
# Any better vocabulary? Can you propose a good german or french translation?
#
# Asi que, la verdad, "anidado" me parece correcto. Para ello, imaginaos
# una trama (o marco), de la que se "re-elabora" una parte denominada
# "entorno" pero que solo tiene sentido dentro de esta trama (o marco),
# puesto que se ha levantado un `closure'. - cll
#
#: debug.d:1358
msgid "nested tagbody frame "
msgstr "marco anidado del cuerpo de etiquetas de salto"

#: debug.d:1363
msgid " for"
msgstr " para"

#: debug.d:1388
#, fuzzy, lisp-format
msgid "~S: environment is not an association list"
msgstr "~S: el entorno no es una a-lista"

#
# Ésta estaba claramente mal - lsg
#
#: debug.d:1401
msgid "catch frame for tag "
msgstr "marco de captura para la etiqueta "

# Handler, otra buena.. Sugerencias? - lsg
#
# Duda: ¿cómo traducir `handler'?
#
# Pues bien, he elegido el término `manipulador' puesto que eso es,
# precisamente, lo que es un `handler' en Common Lisp. De hecho, el
# estándar Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr.,
# en la página 872 dice:
#
# "The process of signaling involves the search for an invocation of a
# handler, a piece of code that will attempt to deal appropiately with
# the situation"
#
# Y atención a la siguiente observación: (en la misma página, a
# continuación del párrafo anterior)
#
# "If a handle is found, it may either handle the situation, by
# performing some non-local transfer of control, or decline to handle
# it, by failing to perform a non-local transfer of control. If it
# declines, other handlers are sought".
#
# En fin, a la vista de esta definición y de la siguiente aclaración,
# propongo `manejador' para su traducción - cll
#
#: debug.d:1405
msgid "handler frame for conditions"
msgstr "marco de manipulación (HANDLER) para las condiciones"

#
# Estaba mal. Yo pondria: "recinto de unwind-protect" - lsg
#
# Y yo creo que si cambiamos `recinto' por `trama' ya es la leche de
# perfecto ;) - cll
#
# Leo, como puedes ver he cambiado en todos lados `trama' por `marco' - cll
#
#: debug.d:1415
msgid "unwind-protect frame"
msgstr "marco `unwind-protect'"

# Duda: Lo de `driver' lo dejo sin traducir, ...
#
# En la traducción francesa está sin traducir y en el estándar de Common
# Lisp no se hace ni la mas mínima referencia a algo que se llame así.
#
# "recinto de driver" - lsg
#
# Vale, ¡pero vamos!, que cambio `recinto' por `trama' - cll
#
#: debug.d:1419
msgid "driver frame"
msgstr "marco `driver'"

# "Entornos con vinculación de recintos" - lsg
#
# Aquí volvemos un poco a lo del mensaje constobj.d:915 Según creo,
# estos mensajes se refieren al tipo de tramas que hay en la pila, no se
# trata de un entorno (en el sentido que en Lisp tiene esta palabra).
#
# La traducción francesa dice:
#
# "«frame» de liaison d'environnements"
#
# ¿Que os parece?
#
#: debug.d:1423 debug.d:1428 debug.d:1433 debug.d:1438 debug.d:1443 debug.d:1448 debug.d:1455
msgid "frame binding environments"
msgstr "marco de ligadura del entorno"

#: debug.d:1469
#, lisp-format
msgid "~S: unknown frame type"
msgstr "~S: tipo de marco desconocido"

#: error.d:57 reploop.lisp:472
msgid "Unprintable error message"
msgstr "Mensaje de error no imprimible"

#: error.d:183
#, lisp-format
msgid "internal error or error in message catalog: invalid low-level format string ~S"
msgstr ""

#: error.d:725 error.d:730
#, lisp-format
msgid "~S: User break"
msgstr "~S: Interrupción del usuario"

#: error.d:728
#, fuzzy
msgid "Continue execution"
msgstr "continuar la búsqueda"

#: error.d:795 foreign.d:688 foreign.d:2424 foreign.d:2536 foreign.d:3186
#, fuzzy, lisp-format
msgid "~S: ~S is not of type ~S"
msgstr "~S: ~S no es un par"

#: error.d:826 error.d:828
#, fuzzy, lisp-format
msgid "~S: ~S comes from a previous Lisp session and is invalid"
msgstr "~S proviene de una sesion anterior de Lisp y es inválido"

#: error.d:845 error.d:870
#, fuzzy, lisp-format
msgid "~S: ~S is not a list"
msgstr "~S: ~S no es un par"

#: error.d:881
#, fuzzy, lisp-format
msgid "~S: A proper list must not end with ~S"
msgstr "~S: Una auténtica lista no debe finalizar con ~S"

#: error.d:894
#, fuzzy, lisp-format
msgid "~S: A proper list must not be circular: ~S"
msgstr "~S: Una auténtica lista no debe finalizar con ~S"

# me comería el "y por ello", todo el mundo lo entenderá, y además no
# está en el original. sv
#
# No sólo eso, sino que además el mensaje queda demasiado largo. Ser
# mucho más cómodo, para quien esté trabajando, ver mensajes cortos,
# ... sugerencia aceptada. cll
#
#: error.d:929
#, fuzzy, lisp-format
msgid "~S: ~S is a constant, may not be used as a variable"
msgstr "FUNCTION: ~S es una constante, no puede usarse como una variable"

# Duda: Nótese cómo la traducción dice `declararse SPECIAL'. Esto es
# así, porque en Common Lisp existe SPECIAL para declarar variables
# especiales. Por eso, si digo `declararse SPECIAL' estoy diciendo
# `declararse especial con SPECIAL', pero esto último me parece muy
# rebuscado, ¿o es lo correcto?
#
# La traducción es perfectamente fiel. Déjala así. sv
#
# Además, he quitado el "por ello". cll
#: error.d:948
#, fuzzy, lisp-format
msgid "~S: ~S is not a symbol, cannot be declared ~S"
msgstr "FUNCTION: ~S no es un símbolo, no puede declararse SPECIAL"

#: error.d:969
msgid "Remove the global SYMBOL-MACRO definition"
msgstr ""

#: error.d:971
#, lisp-format
msgid "~S: attempting to turn ~S into a SPECIAL variable, but it is already a global SYMBOL-MACRO."
msgstr ""

#: error.d:973
#, lisp-format
msgid "~S: attempting to turn ~S into a constant, but it is already a global SYMBOL-MACRO."
msgstr ""

#: error.d:974
#, lisp-format
msgid "~S: interning ~S into the KEYWORD package would turn it into a constant, but it is already a global SYMBOL-MACRO."
msgstr ""

#: error.d:993 error.d:1005
#, fuzzy, lisp-format
msgid "~S: the symbol ~S names a global SPECIAL variable"
msgstr "~S: el símbolo ~S nombra una variable global"

#: error.d:1004
msgid "Remove the global SPECIAL variable binding"
msgstr ""

#: error.d:1035
#, fuzzy, lisp-format
msgid "~S: ~S is not a vector"
msgstr "~S: ~S no es un registro"

#: error.d:1043
#, fuzzy, lisp-format
msgid "~S: argument ~S is not an array"
msgstr "~S: El ~S argumento ~S no es una matriz"

#: error.d:1050
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a vector"
msgstr "~S: el argumento ~S no es el flujo de un fichero abierto"

#: error.d:1063
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a vector of type ~S"
msgstr "~S: el argumento ~S debe ser un flujo del tipo ~S"

#: error.d:1077
#, lisp-format
msgid "~S: ~S may not be used as an environment"
msgstr "~S: ~S no puede usarse como un entorno"

#: error.d:1087 error.d:1095
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a nonnegative fixnum"
msgstr "~S: el argumento ~S debe ser un número no negativo del tipo fixnum"

#: error.d:1102
#, fuzzy, lisp-format
msgid "~S: ~S is not an integer"
msgstr "~S: ~S no es un par"

#: error.d:1115
#, fuzzy, lisp-format
msgid "~S: ~S is not a non-negative integer"
msgstr "~S: ~S no es el nombre de una función"

#: error.d:1129 error.d:1137 xcharin.lisp:34
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a character"
msgstr "~S: el argumento ~S no es un carácter"

#: error.d:1144
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a string"
msgstr "~S: el argumento ~S no es el flujo de un fichero abierto"

#: error.d:1161
#, lisp-format
msgid "Attempt to modify a read-only string: ~S"
msgstr ""

#: error.d:1171
#, fuzzy, lisp-format
msgid "~S: argument ~S is neither a string nor an integer"
msgstr "~S: el argumento ~S no es un string"

#: error.d:1182
#, lisp-format
msgid "string too long: desired length ~S exceeds the supported maximum length"
msgstr ""

#: error.d:1193 clos-class2.lisp:103
#, lisp-format
msgid "~S: ~S is not a class"
msgstr "~S: ~S no es una clase"

#: error.d:1202
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a stream"
msgstr "~S: el argumento ~S no es el flujo de un fichero abierto"

#: error.d:1255
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a character set"
msgstr "~S: el argumento ~S no es un carácter"

#: error.d:1267
#, lisp-format
msgid "~S: the property list ~S has an odd length"
msgstr "~S: la lista de propiedades ~S tiene longitud impar"

#: error.d:1284
#, fuzzy, lisp-format
msgid "~S: keyword arguments in ~S should occur pairwise"
msgstr "EVAL/APPLY: los argumentos clave de ~S deben aparecer por pares"

#: error.d:1295
#, fuzzy, lisp-format
msgid "~S: ~S marker ~S is not a symbol"
msgstr "~S: ~S no es un par"

#
# Yo pondría un guión entre argumento y clave. - lsg
#
# Hmm, o sea `argumento-clave'. No, no me gusta y de hecho, en el
# "Vocabulario bilingüe de términos técnicos" de "Lisp" (3ra edición) de
# Winston y Horn, los traductores al español ponen en la página 649:
#
# keyword arguments - argumentos clave
#
# sin guión por medio - cll
#
#: error.d:1318
#, lisp-format
msgid ""
"~S: illegal keyword/value pair ~S, ~S in argument list.\n"
"The allowed keywords are ~S"
msgstr ""
"~S: par argumento clave/valor inválido ~S, ~S en la lista de argumentos.\n"
"Los parámetros clave permitidos son ~S"

#: error.d:1333
#, fuzzy, lisp-format
msgid "~S: ~S is not a function"
msgstr "~S: ~S no es el nombre de una función"

#: error.d:1369 trace.lisp:159
#, lisp-format
msgid "~S: undefined function ~S"
msgstr "~S: la función ~S no está definida"

#: error.d:1425
#, fuzzy, lisp-format
msgid "~S: ~S is not a function name; try using a symbol instead"
msgstr "~S: ~S no es el nombre de una función"

#: error.d:1441
#, lisp-format
msgid ""
"~S: argument ~S is not a function.\n"
"To get a function in the current environment, write (FUNCTION ...).\n"
"To get a function in the global environment, write (COERCE '... 'FUNCTION)."
msgstr ""

#: error.d:1458
#, fuzzy, lisp-format
msgid "EVAL/APPLY: Too many arguments (~S instead of at most ~S) given to ~S"
msgstr "~S: Demasiados argumentos (~S en vez de ~S) para ~S"

#: error.d:1461
#, fuzzy, lisp-format
msgid "~S: Too many arguments (~S instead of at most ~S) given to ~S"
msgstr "~S: Demasiados argumentos (~S en vez de ~S) para ~S"

#: error.d:1477
#, fuzzy, lisp-format
msgid "EVAL/APPLY: Too few arguments (~S instead of at least ~S) given to ~S"
msgstr "~S: Muy pocos argumentos (~S en vez de, al menos, ~S) para ~S"

#: error.d:1480
#, fuzzy, lisp-format
msgid "~S: Too few arguments (~S instead of at least ~S) given to ~S"
msgstr "~S: Muy pocos argumentos (~S en vez de, al menos, ~S) para ~S"

# "~S:argumento de ~S debe ser un entero comprendido entre 2 y 36, no ~S" - lsg
#
# Algo parecido he puesto yo - cll
#
#: error.d:1496
#, fuzzy, lisp-format
msgid "~S: argument ~S is not an integer with at most ~S bits (including the sign bit)"
msgstr "~S: el argumento ~S debe ser un entero comprendido entre 2 y 36, y no ~S"

#: error.d:1497
#, fuzzy, lisp-format
msgid "~S: argument ~S is not a nonnegative integer with at most ~S bits"
msgstr "~S: ~S no es un entero no negativo menor que el rango de ~S"

#: error.d:1530
#, lisp-format
msgid "~S: ~S is not an `unsigned int' number"
msgstr "~S: ~S no es un número del tipo `unsigned int'"

#: error.d:1543
#, lisp-format
msgid "~S: ~S is not an `int' number"
msgstr "~S: ~S no es un número del tipo `int'"

#: error.d:1557
#, lisp-format
msgid "~S: ~S is not a `unsigned long' number"
msgstr "~S: ~S no es un número del tipo `unsigned long'"

#: error.d:1570
#, lisp-format
msgid "~S: ~S is not a `long' number"
msgstr "~S: ~S no es un número del tipo `long'"

#: error.d:1578
#, lisp-format
msgid "~S: ~S is not a single-float"
msgstr "~S: ~S no es un SINGLE-FLOAT"

#: error.d:1586
#, lisp-format
msgid "~S: ~S is not a double-float"
msgstr "~S: ~S no es un DOUBLE-FLOAT"

#: errunix.d:58
msgid "Invalid multibyte or wide character"
msgstr ""

#: errunix.d:65
msgid "Operation not permitted"
msgstr "Operación no permitida"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
# "No existe ese archivo o directorio" - lsg
#
# Pues si, me gusta más la traducción de Leo, que la de Enrique, salvo
# que, tal y como tu mismo apuntas, Leo, se debe decir "fichero" y no
# "archivo" - cll
#
#: errunix.d:71
msgid "No such file or directory"
msgstr "No existe ese fichero o directorio"

#: errunix.d:77
msgid "No such process"
msgstr "No existe tal proceso"

#: errunix.d:83
msgid "Interrupted system call"
msgstr "Llamada al sistema interrumpida"

# Sugerencia: E/S. sv
#
# Vaya, tu sugerencia es tan informática que me impresiona que se me
# haya escapado. cll
#
#: errunix.d:89
msgid "I/O error"
msgstr "Error de E/S"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:95
msgid "No such device or address"
msgstr "Dispositivo no configurado"

#: errunix.d:101
msgid "Arg list too long"
msgstr "Lista de argumentos demasiado larga"

#: errunix.d:107
msgid "Exec format error"
msgstr "Formato de programa no ejecutable"

#: errunix.d:113
msgid "Bad file number"
msgstr "Número de fichero incorrecto"

# Sugerencia: No hay ningún proceso hijo. sv
#
# Bueno, Enrique tradujo este mensaje como "Ningún proceso hijo" en libc
# asi que, si te parece bien, lo pondré como él puesto que lo suyo es
# una traducción ya aceptada y que además, resulta de mezclar lo que yo
# he puesto y de tu sugerencia. cll
#
#: errunix.d:119
msgid "No child processes"
msgstr "Ningún proceso hijo"

#: errunix.d:125
msgid "No more processes"
msgstr "No hay más procesos"

#: errunix.d:131
msgid "Not enough memory"
msgstr "No hay memoria suficiente"

#: errunix.d:137
msgid "Permission denied"
msgstr "Permiso denegado"

#: errunix.d:143
msgid "Bad address"
msgstr "Dirección incorrecta"

# Pongo esto un poco más en español.
# Antes decía "Dispositivo de bloque requerido".
# Por cierto, en otros sitios hemos puesto "dispositivo de bloques".
# ¿cómo es? sv
#: errunix.d:149
msgid "Block device required"
msgstr "Se requiere un dispositivo de bloque"

#: errunix.d:155
msgid "Device busy"
msgstr "Dispositivo ocupado"

#: errunix.d:161
msgid "File exists"
msgstr "El fichero ya existe"

#: errunix.d:167
msgid "Cross-device link"
msgstr "Enlace cruzado entre dispositivos"

#: errunix.d:173
msgid "No such device"
msgstr "No existe tal dispositivo"

#: errunix.d:179
msgid "Not a directory"
msgstr "No es un directorio"

#: errunix.d:185
msgid "Is a directory"
msgstr "Es un directorio"

# ¿Por qué no inválido? La palabra existe.
# Un día os tengo que enviar un trozo de "1984" de Orwell,
# que habla de "neolengua", el único idioma del mundo que tiene
# cada vez menos palabras, en vez de más... sv
#
# a¡Por supuestísimo!!! Tienes toda la razón del mundo. De hecho, si
# echas un ojo al resto de los mensajes verás que yo siempre he
# traducido "invalid" por "inválido" salvo en tres ocasiones: en dos
# preferí la expresión "no es correcto" y en la otra lo dejé como "no es
# válido" en vez de "no válido" que, además, suena horrible.
#
# A propósito del trozo de "1984", venga, ya estoy esperando :) - cll
#
#: errunix.d:191
msgid "Invalid argument"
msgstr "Argumento inválido"

#: errunix.d:197
msgid "File table overflow"
msgstr "Desbordamiento de la tabla de ficheros"

#: errunix.d:203
msgid "Too many open files"
msgstr "Demasiados ficheros abiertos"

#: errunix.d:209
msgid "Inappropriate ioctl for device"
msgstr "El dispositivo no acepta la llamada `ioctl'"

#: errunix.d:215
msgid "Text file busy"
msgstr "Fichero de texto en uso"

#: errunix.d:221
msgid "File too large"
msgstr "Fichero demasiado grande"

#: errunix.d:227
msgid "No space left on device"
msgstr "No queda espacio en el dispositivo"

#: errunix.d:233
msgid "Illegal seek"
msgstr "Desplazamiento inválido"

#: errunix.d:239
msgid "Read-only file system"
msgstr "Sistema de ficheros de sólo lectura"

#: errunix.d:245
msgid "Too many links"
msgstr "Demasiados enlaces"

#: errunix.d:251
msgid "Broken pipe, child process terminated or socket closed"
msgstr ""

#: errunix.d:261
msgid "Argument out of domain"
msgstr "Argumento fuera del dominio"

#
# "El resultado es demasiado grande" - lsg
#
# Si, ya he cambiado `largo' por `grande' en todos los mensajes. Un
# fallo realmente infantil :( - cll
#
#: errunix.d:267
msgid "Result too large"
msgstr "El resultado es demasiado grande"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:274
msgid "Operation would block"
msgstr "La operación se bloquearía"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:280
msgid "Operation now in progress"
msgstr "Operación en curso"

# Already sería "ya". aún sería still.
# Sugerencia: La operación ya se está realizando. sv
#
# Más aún, echando un ojo a la traducción de Enrique Melero en el glibc,
# me he encontrado con el mismo mensaje y el dice: "La operación ya se
# está llevando a cabo". Me gusta bastante. cll
#
#: errunix.d:286
msgid "Operation already in progress"
msgstr "La operación ya se está llevando a cabo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:293
msgid "Too many levels of symbolic links"
msgstr "Demasiados niveles de enlaces simbólicos"

#: errunix.d:299
msgid "File name too long"
msgstr "Nombre de fichero demasiado largo"

#: errunix.d:305
msgid "Directory not empty"
msgstr "El directorio no está vacío"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:312
msgid "Stale NFS file handle"
msgstr "Fichero NFS bloqueado"

# Duda: Aquí he seguido el consejo de Enrique Melero.
#
# En la versión 1.5 he decidido cambiar el término `camino' por
# `trayectoria', tal y como recomiendan los traductores del libro Lisp,
# (3ra edición) de Winston y Horn en el "Vocabulario bilingüe de
# términos técnicos", en la página 650.
#
#: errunix.d:318
msgid "Too many levels of remote in path"
msgstr "Demasiados niveles de profundidad en la trayectoria"

#: errunix.d:325
msgid "Socket operation on non-socket"
msgstr "Operación de `sockets' sobre un \"no-socket\""

#: errunix.d:331
msgid "Destination address required"
msgstr "Se necesita la dirección del destino"

#: errunix.d:337
msgid "Message too long"
msgstr "Mensaje demasiado largo"

#: errunix.d:343
msgid "Protocol wrong type for socket"
msgstr "Tipo de protocolo incorrecto para el `socket'"

#: errunix.d:349
msgid "Option not supported by protocol"
msgstr "Opción no soportada por el protocolo"

#: errunix.d:355
msgid "Protocol not supported"
msgstr "Protocolo no soportado"

#: errunix.d:361
msgid "Socket type not supported"
msgstr "Tipo de `socket' no soportado"

# Pongo `socket' en vez de socket. sv
#: errunix.d:367
msgid "Operation not supported on socket"
msgstr "Acción no permitida en un `socket'"

#: errunix.d:373
msgid "Protocol family not supported"
msgstr "Familia de protocolos no soportada"

#: errunix.d:379
msgid "Address family not supported by protocol family"
msgstr "Familia de direcciones no soportada por el protocolo"

#: errunix.d:385
msgid "Address already in use"
msgstr "Dirección en uso"

# Sugerencia: No se puede asignar. sv
#
# ¡Vale!, "No puede asignarse ..." es demasiado, ..., ¿impersonal? cll
#: errunix.d:391
msgid "Cannot assign requested address"
msgstr "No se puede asignar la dirección requerida"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#: errunix.d:397
msgid "Network is down"
msgstr "La red no está operativa"

#: errunix.d:403
msgid "Network is unreachable"
msgstr "No es posible conectarse con la red"

#: errunix.d:409
msgid "Network dropped connection on reset"
msgstr "Se ha perdido la conexión con la red debido a una reinicialización"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#: errunix.d:415
msgid "Software caused connection abort"
msgstr "El software ha provocado la interrupción de la conexión"

#: errunix.d:421
msgid "Connection reset by peer"
msgstr "Conexión reinicializada por el otro extremo"

#
# Duda: ¿Y buffer? ¿Como traduzco buffer?
#
# Yo he visto a menudo 'memoria tampón', que es el término usado por los
# franceses. - lsg
#
# Tienes toda la razón, ... Sin embargo, en este caso, la traducción
# francesa es:
#
# "Pas d'espace disponible pour un buffer"
#
# Además, como en spanglish.txt pone:
#
# "buffer - memoria intermedia, tampón, buffer"
#
# pues he utilizado `buffer' tal cual, ... - cll
#
#: errunix.d:427
msgid "No buffer space available"
msgstr "No queda espacio en el buffer"

# Lo de socket, si te parece. sv
#
# Te digo lo mismo que te dije antes. Cuando hay finalizado con la
# traducción me pondré a cambiar todas estas cosas con macros. cll
#
#: errunix.d:433
msgid "Socket is already connected"
msgstr "El `socket' ya está conectado"

#: errunix.d:439
msgid "Socket is not connected"
msgstr "El `socket' no está conectado"

# Añado comitas a `socket'. Es una especie de convenio que seguimos
# cuando no nos queda más remedio que poner la palabra inglesa.
# Así al menos reconocemos que es una palabra extraña. sv
#: errunix.d:445
msgid "Cannot send after socket shutdown"
msgstr "No se puede enviar después de la ruptura del `socket'"

#: errunix.d:451
msgid "Too many references: cannot splice"
msgstr ""

# Duda: ¿ Se excedió el tiempo para la conexión ?
#: errunix.d:457
msgid "Connection timed out"
msgstr "Se excedió el tiempo para la conexión"

#: errunix.d:463
msgid "Connection refused"
msgstr "Conexión rechazada"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#: errunix.d:468
#, fuzzy
msgid "Remote peer released connection"
msgstr "El software ha provocado la interrupción de la conexión"

# Estas dos darán que hablar, pero otro día las discutiremos... sv
#
# Al decir tú eso, he leído la traducción de este término en libc
# (traducido por Enrique Melero) y, madre mía, me he quedado
# "flipao". Aquello fue una discusión encarnizada, ...
#
# Para mas inri, yo no estoy de acuerdo con ninguno de los dos :) Verás,
# un host puede estar "caído" (que así es como se suele decir aunque es,
# evidentemente, incorrecto) y por ello no tiene por qué no estar
# operativo (en libc lo habeis traducido como "el `host' no est
# operativo"). De hecho, puede estar operando pero, por algún problema
# de la red o de tu propia transmisión, resultar inalcanzable, ... En
# fin, por este motivo prefiero "El `host' no está disponible"
#
# Por otra parte, no estoy muy de acuerdo con Enrique, ..., a mí lo de
# poner host no me gusta. Ciertamente, un `host' no tiene por qué ser un
# servidor, necesariamente, pero es el caso más común. En cualquier
# caso, todo el mundo comprende perfectamente que el `host' es un
# servidor. cll
#
#: errunix.d:473
msgid "Host is down"
msgstr "El servidor no está disponible"

# Aquí, pues idem de idem, ... :) cll
#
#: errunix.d:479
msgid "Host is unreachable"
msgstr "No se puede conectar con el servidor"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#: errunix.d:484
#, fuzzy
msgid "Networking error"
msgstr "La red no está operativa"

#: errunix.d:490
msgid "Too many processes"
msgstr "Demasiados procesos"

#: errunix.d:496
msgid "Too many users"
msgstr "Demasiados usuarios"

#: errunix.d:502
msgid "Disk quota exceeded"
msgstr "Cuota de disco excedida"

#: errunix.d:509
msgid "Not a stream device"
msgstr "No es un dispositivo de flujo"

#: errunix.d:515
msgid "Timer expired"
msgstr "El temporizador expiró"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:521
msgid "Out of stream resources"
msgstr "Alcanzado el límite de recursos de `streams'"

#: errunix.d:527
msgid "No message of desired type"
msgstr "No hay mensajes del tipo deseado"

#: errunix.d:533
msgid "Not a data message"
msgstr "No es un mensaje de datos"

#: errunix.d:540
msgid "Identifier removed"
msgstr "Identificador desechado"

# Duda: Eso del `inter-bloqueo' ¿estará bien?
#
#: errunix.d:547
msgid "Resource deadlock would occur"
msgstr "Podría ocurrir un interbloqueo entre recursos"

# Duda: Aunque Bruno Haible me ha asegurado que la etiqueta
# sys_errlist[ENOLCK] del glibc.po en español contiene la traduccion que
# yo debiera usar, me he decidido por las indicaciones de Santiago Vila
# en su respuesta a mi mail y he puesto, simplemente: "No quedan
# registros de bloqueo disponibles"
#
#: errunix.d:553
msgid "No record locks available"
msgstr "No quedan registros de bloqueo disponibles"

#: errunix.d:560
msgid "Machine is not on the network"
msgstr "La máquina no está en la red"

#: errunix.d:566 errunix.d:572
msgid "Object is remote"
msgstr "El objeto es remoto"

#: errunix.d:578
msgid "Link has been severed"
msgstr "El enlace ha sido destruído"

#: errunix.d:584
msgid "Advertise error"
msgstr "Error de anuncio"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:590
msgid "Srmount error"
msgstr "Error de `srmount'"

#: errunix.d:596
msgid "Communication error on send"
msgstr "Error de comunicaciones en el envío"

#: errunix.d:602
msgid "Protocol error"
msgstr "Error de protocolo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:608
msgid "Multihop attempted"
msgstr "Se ha intentado un multihop"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:620
msgid "Remote address changed"
msgstr "La dirección remota ha cambiado"

#: errunix.d:627
msgid "Function not implemented"
msgstr "Función no implementada"

#: errunix.d:656
msgid "UNIX error "
msgstr "Error de Unix "

# Cambio librería por el término oficial. sv
#
# Uuuffffff, ..., aquí sí que podríamos discutir hasta la muerte. Pero
# bueno, se queda como tú lo has puesto. cll
#
#: errunix.d:658
#, fuzzy
msgid "POSIX library error "
msgstr "Error de biblioteca Unix "

#: errwin32.d:3873
msgid "Win32 error "
msgstr "Error de Win32 "

#: errwin32.d:3922
msgid "Winsock error "
msgstr "Error de `winsock'"

#: misc.d:108
msgid "This file was produced by another lisp version, must be recompiled."
msgstr "Este fichero fue producido por otra versión de lisp. Debe recompilarse."

#: misc.d:450
#, lisp-format
msgid "~S (~S ~S): out of memory"
msgstr ""

#: misc.d:505
#, lisp-format
msgid "~S: type of attribute ~S is unsupported"
msgstr "~S: el tipo de atributo ~S no está soportado"

#: misc.d:525
msgid "GNU C++ "
msgstr "GNU C++"

#: misc.d:527
msgid "GNU C "
msgstr "GNU C "

#: misc.d:533
msgid "C++ compiler"
msgstr "Compilador de C++"

#: misc.d:535
msgid "C compiler"
msgstr "Compilador de C"

#: misc.d:738
#, fuzzy, lisp-format
msgid "~S: Lisp value ~S is not found in table ~S: ~S"
msgstr "~S: el argumento ~S no es el flujo de un fichero abierto"

#: misc.d:765
#, fuzzy, lisp-format
msgid "~S: C value ~S is not found in table ~S: ~S"
msgstr "~S: el argumento ~S no es un carácter"

#: time.d:869 intlog.d:655
#, lisp-format
msgid "~S: too large shift amount ~S"
msgstr "~S: el tamaño del desplazamiento es muy grande ~S"

#: predtype.d:1793 predtype.d:2031
#, lisp-format
msgid "~S: unidentifiable type!!!"
msgstr "~S: a¡tipo irreconocible!!!"

#: predtype.d:2037
#, lisp-format
msgid "~S: type ~S does not correspond to a class"
msgstr "~S: el tipo ~S no se corresponde con una clase"

#: predtype.d:2065
#, lisp-format
msgid "~S: ~S does not name a class"
msgstr "~S: ~S no es el nombre de una clase"

#: predtype.d:2184
#, lisp-format
msgid "~S: type definition for ~S exceeds depth limit, maybe recursive"
msgstr ""

#: predtype.d:2503 type.lisp:32
#, lisp-format
msgid "~S: invalid type specification ~S"
msgstr "~S: la especificación de tipo ~S es inválida"

#: predtype.d:2511
#, lisp-format
msgid "~S: ~S cannot be coerced to type ~S"
msgstr "~S: ~S no puede convertirse al tipo ~S"

#: symbol.d:17
#, lisp-format
msgid "~S: the property list of ~S has an odd length"
msgstr "~S: la lista de propiedades de ~S tiene longitud impar"

#: symbol.d:89
#, lisp-format
msgid "~S: ~S is not a system function"
msgstr "~S: ~S no es una función del sistema"

#: symbol.d:356
#, lisp-format
msgid "The value of *GENSYM-COUNTER* was not a nonnegative integer. Old value ~S. New value ~S."
msgstr "El valor de *GENSYM-COUNTER* no era un entero no negativo. Valor anterior ~S. Nuevo valor ~S."

#: lisparit.d:323
#, lisp-format
msgid "~S: argument should be a positive fixnum, not ~S"
msgstr "~S: el argumento debe ser un número positivo del tipo FIXNUM, no ~S"

#: lisparit.d:347
#, fuzzy, lisp-format
msgid "~S: ~S is not a number"
msgstr "~S: ~S no es un número de 8 bits"

#: lisparit.d:364
#, fuzzy, lisp-format
msgid "~S: ~S is not a real number"
msgstr "~S: ~S no es un número del tipo `long'"

#: lisparit.d:391
#, fuzzy, lisp-format
msgid "~S: ~S is not a floating-point number"
msgstr "~S: ~S no es un número del tipo `long'"

#: lisparit.d:417
#, fuzzy, lisp-format
msgid "~S: ~S is not a rational number"
msgstr "~S: ~S no es un número del tipo `long'"

#: lisparit.d:1648
#, fuzzy, lisp-format
msgid "~S: argument should be a ~S, not ~S"
msgstr "~S: el argumento debe ser una cadena de caracteres, no ~S"

#: lisparit.d:1660
#, fuzzy, lisp-format
msgid "~S: the value of ~S should be a ~S, not ~S"
msgstr "~S: el valor de ~S debe ser un RANDOM-STATE, no ~S"

#: lisparit.d:1683
#, lisp-format
msgid "~S: argument should be positive and an integer or float, not ~S"
msgstr "~S: el argumento debe ser un número positivo del tipo INTEGER o FLOAT, no ~S"

#: aridecl.d:351
#, fuzzy, lisp-format
msgid "~S: division by zero"
msgstr "división entre cero"

#: aridecl.d:358
#, fuzzy, lisp-format
msgid "~S: floating point overflow"
msgstr "desbordamiento de coma flotante"

# Duda: Lo del desbordamiento inferior de coma flotante ha sido
# traducción super libre mía ;) Este mensaje ocurre cuando el resultado
# (expresado en coma flotante) ocurre mucho más cerca del cero de lo que
# permite la representación de números en coma flotante. Por ejemplo:
# 2.3e-30 * 2.3e-30 sería 5.29e-60 que excedió el límite inferior.
#
#: aridecl.d:365
#, fuzzy, lisp-format
msgid "~S: floating point underflow"
msgstr "desbordamiento inferior de coma flotante"

#: intelem.d:232 intelem.d:328
#, lisp-format
msgid "not a 32-bit integer: ~S"
msgstr "no es un entero de 32 bits: ~S"

#: intelem.d:412 intelem.d:550
#, lisp-format
msgid "not a 64-bit integer: ~S"
msgstr "no es un entero de 64 bits: ~S"

#: intelem.d:1368
msgid "bignum overflow"
msgstr "desbordamiento de números grandes"

#: intlog.d:424
#, lisp-format
msgid "~S: ~S is not a valid boolean operation"
msgstr "~S: ~S no es una operación lógica válida"

#: intlog.d:533
#, lisp-format
msgid "~S: index ~S is negative"
msgstr "~S: el índice ~S es negativo"

# Duda: En Lisp existe un tipo predeterminado: `fixnum'. Por ese motivo,
# dejo sin traducir este término.
#
#: intbyte.d:13
#, lisp-format
msgid "The arguments to BYTE must be fixnums >=0: ~S, ~S"
msgstr "Los argumentos de BYTE deben ser números enteros del tipo FIXNUM >=0: ~S, ~S"

#: intbyte.d:34
#, lisp-format
msgid "~S is not a BYTE specifier"
msgstr "~S no es un especificador de BYTE"

#: intmal.d:6
msgid "overflow during multiplication of large numbers"
msgstr "desbordamiento durante la multiplicación de números grandes"

#: intdiv.d:384
#, lisp-format
msgid "quotient ~S / ~S is not an integer"
msgstr "el cociente ~S / ~S no es un entero"

# Duda: long-float es un tipo, así que lo dejo como `LONG-FLOAT'. Aunque
# Bruno Haible y Marcus Daniels lo han puesto como `long float' se
# refieren al tipo `long-float'
# Sugerencia: `long float'. sv
#
# No estoy de acuerdo con la sugerencia. No se trata de que `long' sea
# un adjetivo de `float', sino que en CLisp existe el tipo "long-float"
# (Common Lisp The Language, 2nd edition, Guy L. Steele, pag. 39). De
# hecho, en muchos otros sitios de CLisp se pone "long-float". Más aún,
# la traducción francesa de este mensaje es: "LONG-FLOAT trop long".
#
# De hecho, en mi opinion, Bruno Haible y Marcus Daniels se equivocaron
# aquí y debían haber puesto el guión. cll
#
#: lfloat.d:5
msgid "long float too long"
msgstr "LONG-FLOAT demasiado largo"

#: flo_konv.d:427
#, fuzzy, lisp-format
msgid "~S: floating point NaN occurred"
msgstr "aparición de NaN en coma flotante"

#: flo_rest.d:39
#, fuzzy, lisp-format
msgid "Floating point operation combines numbers of different precision. See ANSI CL 12.1.4.4 and the CLISP impnotes for details. The result's actual precision is controlled by ~S. To shut off this warning, set ~S to ~S."
msgstr ""
"Las operaciones en coma flotante combinan números de diferentes precisiones.\n"
"Para más detalles, consulte ANSI CL 12.1.4.4 y las notas de implementación de\n"
"CLISP.\n"
"La precisión actual del resultado está controlada por\n"
"~S.\n"
"Para eliminar este aviso, establezca el valor de ~S a ~S."

#: realelem.d:149
#, fuzzy, lisp-format
msgid "Numerical operation combines exact and inexact numbers (rational numbers and floating-point numbers), and the mathematical result is exact. See ANSI CL 12.1.4.1 and the CLISP impnotes for details. The result's actual exactness is controlled by ~S. To shut off this warning, set ~S to ~S."
msgstr ""
"Las operaciones en coma flotante combinan números de diferentes precisiones.\n"
"Para más detalles, consulte ANSI CL 12.1.4.4 y las notas de implementación de\n"
"CLISP.\n"
"La precisión actual del resultado está controlada por\n"
"~S.\n"
"Para eliminar este aviso, establezca el valor de ~S a ~S."

#: funarg.d:107
#, fuzzy, lisp-format
msgid "~S: must not specify both :TEST and :TEST-NOT arguments"
msgstr "~S: Los argumentos :TEST y :TEST-NOT no deben tener valor simultáneamente"

#: foreign.d:27
#, fuzzy, lisp-format
msgid "~S: argument is not a foreign object: ~S"
msgstr "~S: el argumento no es una variable extranjera: ~S"

#: foreign.d:58
#, fuzzy, lisp-format
msgid "~S: argument ~S should be a ~S, ~S or ~S"
msgstr "~S: el argumento ~S debe ser ~S, ~S, ~S, ~S, ~S, ~S o ~S"

#: foreign.d:116
#, lisp-format
msgid "~S: must not invalidate the sole FFI session pointer"
msgstr ""

#: foreign.d:122
#, fuzzy, lisp-format
msgid "~S: cannot resurrect the zombie ~S"
msgstr "~S: no se puede escribir en ~S"

#: foreign.d:198
#, fuzzy, lisp-format
msgid "Foreign variable ~S already exists"
msgstr "La variable extranjera ~S ya existe"

# Duda: he traducido `foreign' por `ajeno/a'.
#
# Lo he pensado mejor y `extranjera' me gusta mucho más, ..., ¿qué os
# parece? cll
#
#: foreign.d:234
#, fuzzy, lisp-format
msgid "Foreign function ~S already exists"
msgstr "La función extranjera ~S ya existe"

#: foreign.d:261
#, fuzzy, lisp-format
msgid "No foreign int type of size ~S"
msgstr "el tipo de datos extranjero ~S es inválido"

#: foreign.d:278
#, fuzzy, lisp-format
msgid "Cannot redefine foreign type ~S from ~S to ~S"
msgstr ";; redefiniendo la función ~S de la biblioteca externa~%;;  de ~S a ~S"

#: foreign.d:308
#, fuzzy, lisp-format
msgid "~S: illegal foreign data type ~S"
msgstr "el tipo de datos extranjero ~S es inválido"

#: foreign.d:316
#, fuzzy, lisp-format
msgid "~S: ~S cannot be converted to the foreign type ~S"
msgstr "~S no puede ser compartido al tipo extranjero ~S"

#: foreign.d:324
#, fuzzy, lisp-format
msgid "~S: 64 bit integers are not supported on this platform and with this C compiler: ~S"
msgstr "los enteros de 64 bits no están soportados en esta arquitectura, para este compilador de C:"

#: foreign.d:338
#, lisp-format
msgid "~S: illegal foreign function type ~S"
msgstr "~S: tipo de función externa inválido ~S"

#: foreign.d:468
#, lisp-format
msgid "~S cannot be converted to a foreign function with another calling convention."
msgstr "~S no puede ser convertido a una función extranjera con otra convención de llamada."

#: foreign.d:1094
#, fuzzy, lisp-format
msgid "~S: element type has size 0: ~S"
msgstr "el tipo del elemento tiene tamaño 0: ~S"

#: foreign.d:1102
#, lisp-format
msgid "~S: trying to read an object of type ~S from NULL address"
msgstr ""

#: foreign.d:1920
#, fuzzy, lisp-format
msgid "~S: trying to write object ~S of type ~S into NULL address"
msgstr "~S: la variable externa ~S del tipo ~S no es una matriz"

#: foreign.d:2429
#, lisp-format
msgid "~S: foreign variable with unknown type, missing DEF-C-VAR: ~S"
msgstr "~S: variable externa de tipo desconocido, se ha omitido DEF-C-VAR: ~S"

#: foreign.d:2445
#, fuzzy, lisp-format
msgid "~S: foreign variable ~S does not exist"
msgstr "La variable extranjera ~S no existe"

#: foreign.d:2446
#, fuzzy
msgid "Skip foreign variable creation"
msgstr "La variable extranjera ~ ya existe"

#: foreign.d:2460
#, lisp-format
msgid "~S: foreign variable ~S does not have the required size or alignment"
msgstr "~S: la variable externa ~S no tiene el tamaño o alineamiento requerido"

#: foreign.d:2471
#, lisp-format
msgid "~S: type specifications for foreign variable ~S conflict: ~S and ~S"
msgstr "~S: conflicto de especificación de tipo de la variable extranjera ~S: ~S y ~S"

#: foreign.d:2498
#, lisp-format
msgid "~S(~S): version ~S without library does not make sense"
msgstr ""

#: foreign.d:2517
#, lisp-format
msgid "~S: foreign variable ~S does not have the required alignment"
msgstr "~S: la variable externa ~S no tiene el alineamiento requerido"

#: foreign.d:2594
#, lisp-format
msgid "~S: foreign variable ~S may not be modified"
msgstr "~S: no se puede modificar la variable externa ~S"

#: foreign.d:2640
#, lisp-format
msgid "~S: foreign variable ~S of type ~S is not an array"
msgstr "~S: la variable externa ~S del tipo ~S no es una matriz"

#: foreign.d:2716
#, lisp-format
msgid "~S: foreign variable ~S of type ~S is not a pointer"
msgstr "~S: la variable externa ~S del tipo ~S no es un puntero"

#: foreign.d:2824
#, lisp-format
msgid "~S: foreign variable ~S of type ~S is not a struct or union"
msgstr "~S: la variable externa ~S del tipo ~S no es, ni una estructura, ni una unión"

#: foreign.d:2831
#, lisp-format
msgid "~S: foreign variable ~S of type ~S has no component with name ~S"
msgstr "~S: la variable externa ~S del tipo ~S no tiene ningún componente con el nombre ~S"

#: foreign.d:3166
#, lisp-format
msgid "~S: ~S has no type, :FULL is illegal"
msgstr ""

#: foreign.d:3192
#, lisp-format
msgid "~S: foreign function with unknown calling convention, missing DEF-CALL-OUT: ~S"
msgstr "~S: función externa con convención de llamada desconocida, se ha omitido DEF-CALL-OUT: ~S"

#: foreign.d:3210
#, fuzzy, lisp-format
msgid "~S: foreign function ~S does not exist"
msgstr "~S: La función extranjera ~S no existe"

# Duda: he traducido `foreign' por `ajeno/a'.
#
# Lo he pensado mejor y `extranjera' me gusta mucho más, ..., ¿qué os
# parece? cll
#
#: foreign.d:3211
#, fuzzy
msgid "Skip foreign function creation"
msgstr "La función extranjera ~ ya existe"

#: foreign.d:3218
#, lisp-format
msgid "~S: calling conventions for foreign function ~S conflict"
msgstr "~S: conflicto en la convención de llamada de la función externa ~S"

#: foreign.d:3545 foreign1.lisp:1196
#, lisp-format
msgid "~S: :OUT argument is not a pointer: ~S"
msgstr "~S: el argumento :OUT no es un puntero: ~S"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: foreign.d:4196
#, fuzzy, lisp-format
msgid "~S: ~S is not supported on this platform."
msgstr "~S: ~S no es un flujo de entrada con buffer"

#: foreign.d:4215
#, fuzzy, lisp-format
msgid "~S: Cannot open library ~S: ~S"
msgstr "~S: No se puede abrir la biblioteca ~S"

#: foreign.d:4217
#, lisp-format
msgid "~S: Cannot open library ~S"
msgstr "~S: No se puede abrir la biblioteca ~S"

#: foreign.d:4287
#, fuzzy, lisp-format
msgid "~S: no dynamic object named ~S in library ~S"
msgstr "~S: No se puede abrir la biblioteca ~S"

#: foreign.d:4288
#, fuzzy, lisp-format
msgid "~S: no dynamic object named ~S (version ~S) in library ~S"
msgstr "~S: No se puede abrir la biblioteca ~S"

#: foreign.d:4289
msgid "Skip foreign object creation"
msgstr ""

#: foreign.d:4558
#, lisp-format
msgid "~S: cannot find ~S in ~S due to lack of dlsym() on this platform"
msgstr ""

#: foreign.d:4622
#, fuzzy, lisp-format
msgid "~S(~S): dladdr() failed: ~S"
msgstr "mprotect() falló."

#: foreign.d:4624
#, fuzzy, lisp-format
msgid "~S(~S): dladdr() failed"
msgstr "mprotect() falló."

#: init.lisp:271 format.lisp:367
#, lisp-format
msgid "The destination argument ~S is invalid (not NIL or T or a stream or a string)."
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

#: init.lisp:301 format.lisp:392 format.lisp:2551
#, lisp-format
msgid "~S: The control-string must be a string, not ~S"
msgstr "~S: La cadena de control debe ser una cadena, y no ~S"

#: init.lisp:314 init.lisp:2186 condition.lisp:1581 reploop.lisp:463
msgid "Continuable Error"
msgstr ""

#: init.lisp:549
#, fuzzy
msgid "special operator"
msgstr "una forma especial"

#: init.lisp:554
msgid "macro"
msgstr "macro"

#: init.lisp:560 trace.lisp:175
msgid "function"
msgstr "función"

#: init.lisp:615
#, fuzzy, lisp-format
msgid "~A: ~S is a special operator and may not be redefined."
msgstr "~S es una forma especial y por ello, no puede ser redefinida"

#: init.lisp:677
#, fuzzy, lisp-format
msgid "~A: redefining ~A ~S in ~A, was defined in ~A"
msgstr "~S: redefiniendo ~S; ¡estaba siendo rastreada!"

#: init.lisp:706
#, fuzzy, lisp-format
msgid "~A: redefining ~S; it was traced!"
msgstr "~S: redefiniendo ~S; ¡estaba siendo rastreada!"

#: init.lisp:720
#, lisp-format
msgid "~S is impossible in compiled code"
msgstr "~S es imposible en código compilado"

#: init.lisp:806
#, lisp-format
msgid "~S is an invalid function environment"
msgstr "~S es un entorno de función inválido"

#: init.lisp:867
#, lisp-format
msgid "~S is an invalid variable environment"
msgstr "~S es un entorno de variable inválido"

#: init.lisp:934
#, lisp-format
msgid "~S: ~S is illegal since ~S is a local macro"
msgstr "~S: ~S es inválido, puesto que ~S es una macro local"

#: init.lisp:937
#, lisp-format
msgid "~S: invalid function environment ~S"
msgstr "~S: ~S es un entorno de función inválido"

#: init.lisp:943
#, lisp-format
msgid "~S: ~S is invalid since ~S is not a symbol"
msgstr "~S: ~S es incorrecto, puesto que ~S no es un símbolo"

#: init.lisp:1091
#, lisp-format
msgid "code after MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de MACROLET contiene una lista punteada que termina con ~S"

#: init.lisp:1105
#, lisp-format
msgid "illegal syntax in MACROLET: ~S"
msgstr "sintaxis inválida en MACROLET: ~S"

#: init.lisp:1127
#, lisp-format
msgid "code after SYMBOL-MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de SYMBOL-MACROLET contiene una lista punteada que termina con ~S"

#: init.lisp:1139 compiler.lisp:5796
#, fuzzy, lisp-format
msgid "~S: symbol ~S must not be declared SPECIAL and a macro at the same time"
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el símbolo ~S no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: init.lisp:1152
#, fuzzy, lisp-format
msgid "~S: symbol ~S is declared special and must not be declared a macro"
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el símbolo ~S no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: init.lisp:1159
#, lisp-format
msgid "illegal syntax in SYMBOL-MACROLET: ~S"
msgstr "sintaxis inválida en SYMBOL-MACROLET: ~S"

#: init.lisp:1185
#, lisp-format
msgid "bad function environment occurred in ~S: ~S"
msgstr "se encontró un entorno de función incorrecto en ~S: ~S"

#: init.lisp:1194
#, lisp-format
msgid "~S: invalid form ~S"
msgstr "~S: forma inválida ~S"

#: init.lisp:1211
#, lisp-format
msgid "code contains a dotted list, ending with ~S"
msgstr "el código contiene una lista punteada que termina con ~S"

#: init.lisp:1287
#, lisp-format
msgid "lambda list must not end with the atom ~S"
msgstr "la lista lambda no debe terminar con el átomo ~S"

#: init.lisp:1316 init.lisp:1333
#, lisp-format
msgid "~S: variable list ends with the atom ~S"
msgstr "~S: la lista de variables termina con el átomo ~S"

#: init.lisp:1430
#, lisp-format
msgid "FLET/LABELS: code contains a dotted list, ending with ~S"
msgstr "FLET/LABELS: el código contiene una lista punteada que termina con ~S"

#: init.lisp:1440
#, lisp-format
msgid "illegal syntax in FLET/LABELS: ~S"
msgstr "sintaxis inválida en FLET/LABELS: ~S"

#: init.lisp:1460
#, fuzzy, lisp-format
msgid "FUNCTION-MACRO-LET: code contains a dotted list, ending with ~S"
msgstr "El código de COND contiene una lista punteada que termina con ~S"

#: init.lisp:1473
#, fuzzy, lisp-format
msgid "illegal syntax in FUNCTION-MACRO-LET: ~S"
msgstr "sintaxis inválida en MACROLET: ~S"

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: init.lisp:1566 condition.lisp:1616
msgid "WARNING:"
msgstr "ATENCIÓN:"

#: init.lisp:1598
#, lisp-format
msgid "~S: compiled file ~A lacks a version marker"
msgstr ""

#: init.lisp:1600
#, lisp-format
msgid "~S: compiled file ~A has a corrupt version marker ~S"
msgstr ""

#: init.lisp:1602
#, fuzzy, lisp-format
msgid "~S: compiled file ~A was created by an older CLISP version and needs to be recompiled"
msgstr "Este fichero fue producido por otra versión de lisp. Debe recompilarse."

#: init.lisp:1714
#, fuzzy, lisp-format
msgid "~S: A file with name ~A does not exist"
msgstr "No existe ningún fichero con el nombre ~A"

#: init.lisp:1736
#, fuzzy, lisp-format
msgid "Loading file ~A ..."
msgstr "Cargando el fichero \""

#: init.lisp:1769 defs1.lisp:499
#, fuzzy, lisp-format
msgid "Loaded file ~A"
msgstr "Cargando el fichero \""

#: init.lisp:1782
#, lisp-format
msgid "~S: missing function name and/or parameter list"
msgstr "~S: no se ha indicado el nombre de la función y/o la lista de parámetros"

#: init.lisp:1792
#, fuzzy, lisp-format
msgid "~S: special operator ~S cannot be redefined."
msgstr "~S: la forma especial ~S no puede ser redefinida."

#: init.lisp:1827 macros1.lisp:155
#, lisp-format
msgid "exit clause in ~S must be a list"
msgstr "la cláusula exit en ~S debe ser una lista"

#: init.lisp:1989
#, fuzzy, lisp-format
msgid "~S: cannot define a function from that: ~S"
msgstr "~: no es posible definir una función a partir de ~S"

#: init.lisp:1995 clos-genfun3.lisp:101 clos-genfun3.lisp:176
#, lisp-format
msgid "~S: the name of a function must be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: init.lisp:2001
#, lisp-format
msgid "~S: function ~S is missing a lambda list"
msgstr "~S: la función ~S debe tener una lista lambda"

#: init.lisp:2193 condition.lisp:1588 reploop.lisp:490
msgid "If you continue (by typing 'continue'): "
msgstr "Si continúa (tecleando `continue'): "

#: backquote.lisp:67
#, lisp-format
msgid "~S: unquotes may occur only in (...) or #(...) forms"
msgstr ""

# Duda: Aquí, igual que en el caso de la traducción francesa, he
# preferido preservar el término `backquote' y ---porque así se ha
# decidido en Spanish GNU Translation Team---, el término está con
# comillas simples.
#
# He tomado esta decisión porque el `backquote' (que es la tilde
# invertida `) es un término muy familiar para todos los programadores
# de Lisp que, con toda seguridad, conocerán.
#
#: backquote.lisp:85
#, lisp-format
msgid "~S: comma is illegal outside of backquote"
msgstr "~S: la coma es inválida fuera del `backquote'"

#: backquote.lisp:90
#, lisp-format
msgid "~S: more commas out than backquotes in, is illegal"
msgstr "~S: no se pueden emplear más comas fuera que apóstrofes invertidos dentro"

#: backquote.lisp:95
#, fuzzy, lisp-format
msgid "~S: unquotes may not occur in structures"
msgstr "~: ~ no es una estructura"

#: backquote.lisp:100
#, lisp-format
msgid "~S: unquotes may not occur in arrays"
msgstr ""

#: backquote.lisp:131
#, fuzzy
msgid "the syntax `,@form is invalid"
msgstr "La sintaxis ,@forma es válida únicamente en las listas"

#: backquote.lisp:132
#, fuzzy
msgid "the syntax `,.form is invalid"
msgstr "La sintaxis ,.forma es válida únicamente en las listas"

#: backquote.lisp:136 backquote.lisp:152
#, lisp-format
msgid "READ: ~@?"
msgstr ""

#: backquote.lisp:147
#, fuzzy
msgid "the syntax `( ... . ,@form) is invalid"
msgstr "La sintaxis ,@forma es válida únicamente en las listas"

#: backquote.lisp:148
#, fuzzy
msgid "the syntax `( ... . ,.form) is invalid"
msgstr "La sintaxis ,.forma es válida únicamente en las listas"

#: defmacro.lisp:50
#, fuzzy, lisp-format
msgid "The macro ~S may not be called with a circular argument list: ~S"
msgstr "La macro ~S no puede ser invocada con ~S argumentos: ~S"

#: defmacro.lisp:56
#, fuzzy, lisp-format
msgid "The macro ~S may not be called with a dotted argument list: ~S"
msgstr "La macro ~S no puede ser invocada con ~S argumentos: ~S"

#: defmacro.lisp:61
#, lisp-format
msgid "The macro ~S may not be called with ~S arguments: ~S"
msgstr "La macro ~S no puede ser invocada con ~S argumentos: ~S"

#: defmacro.lisp:68 defmacro.lisp:427
#, fuzzy, lisp-format
msgid "~S: ~S does not match lambda list element ~:S"
msgstr "Elemento inválido en lista lambda ~S"

#: defmacro.lisp:139 defmacro.lisp:180 defmacro.lisp:268
#, lisp-format
msgid "The rest of the lambda list will be ignored."
msgstr "El resto de la lista lambda será ignorado."

#: defmacro.lisp:140 defmacro.lisp:181
#, fuzzy, lisp-format
msgid "The lambda list of macro ~S contains a dot after ~S."
msgstr "La lista lambda de la macro ~S contiene un punto después de &AUX"

#: defmacro.lisp:147
#, lisp-format
msgid "in macro ~S: ~S may not be used as &AUX variable."
msgstr "en la macro ~S: ~S no debe usarse como una variable &AUX."

#: defmacro.lisp:158
#, fuzzy, lisp-format
msgid "~S: invalid supplied-p variable ~S"
msgstr "~S: especificación inválida de ranura y variable: ~S"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
#: defmacro.lisp:189 defmacro.lisp:344
#, lisp-format
msgid "It will be ignored."
msgstr "Será ignorado."

#: defmacro.lisp:190
#, lisp-format
msgid "The lambda list of macro ~S contains a badly placed ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S mal situado."

#: defmacro.lisp:203
#, lisp-format
msgid "The lambda list of macro ~S contains the invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene el elemento inválido ~S"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# No tengo ni idea de qué significa ese "0*"
#: defmacro.lisp:215
#, lisp-format
msgid "~0*It will be ignored."
msgstr "Será ignorado."

#: defmacro.lisp:216
#, lisp-format
msgid "The lambda list of macro ~S contains an invalid keyword specification ~S"
msgstr "La lista lambda de la macro ~S contiene una especificación de argumento clave inválida: ~S"

#: defmacro.lisp:250
#, lisp-format
msgid "The lambda list of macro ~S is missing a variable after &REST/&BODY."
msgstr "La lista lambda de la macro ~S necesita una variable después de &REST/&BODY."

#: defmacro.lisp:261
#, lisp-format
msgid "The lambda list of macro ~S contains an illegal variable after &REST/&BODY: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable inválida después de &REST/&BODY: ~S"

#: defmacro.lisp:269
#, lisp-format
msgid "The lambda list of macro ~S contains a misplaced dot."
msgstr "La lista lambda de la macro ~S contiene un punto mal situado."

# Ojo. sv
#
# :) Vale :) cll
#
#: defmacro.lisp:273
#, lisp-format
msgid "They will be ignored."
msgstr "Serán ignorados."

#: defmacro.lisp:274
#, lisp-format
msgid "The lambda list of macro ~S contains superfluous elements: ~S"
msgstr "La lista lambda de la macro ~S contiene elementos innecesarios: ~S"

#: defmacro.lisp:324
#, lisp-format
msgid "The lambda list of macro ~S contains an illegal &REST variable: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable &REST inválida: ~S"

#: defmacro.lisp:340
#, lisp-format
msgid "The lambda list of macro ~S contains an invalid &WHOLE: ~S"
msgstr "La lista lambda de la macro ~S contiene un &WHOLE inválido: ~S"

#: defmacro.lisp:345
#, lisp-format
msgid "The lambda list of macro ~S contains a superfluous ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S innecesario."

#: defmacro.lisp:356
#, lisp-format
msgid "The lambda list of macro ~S contains ~S before &KEY."
msgstr "La lista lambda de la macro ~S contiene ~S antes de &KEY."

#: defmacro.lisp:359
#, lisp-format
msgid "The lambda list of macro ~S contains ~S which is illegal here."
msgstr "La lista lambda de la macro ~S contiene ~S, lo cual es incorrecto aquí."

#: defmacro.lisp:378
#, lisp-format
msgid "The lambda list of macro ~S contains an invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene un elemento inválido: ~S"

#: defmacro.lisp:448
#, lisp-format
msgid "In the lambda list of macro ~S, &ENVIRONMENT must be followed by a non-NIL symbol: ~S"
msgstr "En la lista lambda de la macro ~S, &ENVIRONMENT debe estar seguido de un símbolo no nulo: ~S"

#: defmacro.lisp:473
#, lisp-format
msgid "Cannot define a macro from that: ~S"
msgstr "No se puede definir una macro a partir de: ~S"

#: defmacro.lisp:479
#, lisp-format
msgid "The name of a macro must be a symbol, not ~S"
msgstr "El nombre de una macro debe ser un símbolo, no ~S"

#: defmacro.lisp:485
#, lisp-format
msgid "Macro ~S is missing a lambda list."
msgstr "La macro ~S necesita una lista lambda."

#: macros1.lisp:25 macros1.lisp:48
#, lisp-format
msgid "~S: non-symbol ~S cannot be a variable"
msgstr "~S: sólo los símbolos pueden ser variables, y no ~S"

#: macros1.lisp:31 macros1.lisp:54
#, lisp-format
msgid "~S: the constant ~S must not be redefined to be a variable"
msgstr "~S: la constante ~S no debe redefinirse como una variable"

#: macros1.lisp:68
#, fuzzy, lisp-format
msgid "~S: non-symbol ~S cannot be defined constant"
msgstr "~S: ~S no es un símbolo, y por lo tanto no puede definirse como una constante"

#: macros1.lisp:104
#, fuzzy, lisp-format
msgid "~S redefines the constant ~S. Its old value was visually similar though. Set ~S to avoid this warning."
msgstr "~S redefine la constante ~S. Su valor anterior era ~S."

#: macros1.lisp:107
#, lisp-format
msgid "~S redefines the constant ~S. Its old value was ~S."
msgstr "~S redefine la constante ~S. Su valor anterior era ~S."

#: macros1.lisp:161
#, lisp-format
msgid "Invalid syntax in ~S form: ~S."
msgstr "Sintaxis inválida en la forma ~S: ~S."

#: macros1.lisp:261 places.lisp:620 places.lisp:841
#, lisp-format
msgid "~S called with an odd number of arguments: ~S"
msgstr "~S ha sido invocado con un número impar de argumentos: ~S"

#: macros1.lisp:299
#, lisp-format
msgid "~S: missing key list"
msgstr "~S: falta la lista de claves"

#: macros1.lisp:428
#, lisp-format
msgid "Not a list of COND clauses: ~S"
msgstr "No es una lista de cláusulas COND: ~S"

#: macros1.lisp:434
#, lisp-format
msgid "The atom ~S must not be used as a COND clause."
msgstr "El átomo ~S no debe usarse como una cláusula COND."

#: macros2.lisp:13
#, lisp-format
msgid "Invalid clause in ~S: ~S"
msgstr "Cláusula inválida en ~S: ~S"

#: macros2.lisp:26
#, lisp-format
msgid "~A~%The value is: ~S"
msgstr "~A~%El valor es: ~S"

#: macros2.lisp:29
#, lisp-format
msgid "The value of ~S should be ~:[of type ~S~;~:*~A~]."
msgstr "El valor de ~S debe ser ~:[del tipo ~S~;~:*~A~]."

#: macros2.lisp:32
#, fuzzy, lisp-format
msgid "You may input a new value for ~S."
msgstr "Puede introducir un nuevo valor."

#: macros2.lisp:34
#, lisp-format
msgid "You may input a value to be used instead~@[ of ~S~]."
msgstr ""

#: macros2.lisp:36
#, lisp-format
msgid "New ~S: "
msgstr "Nuevo ~S: "

#: macros2.lisp:53
msgid "Retry"
msgstr "Reintentar"

#: macros2.lisp:55
#, fuzzy, lisp-format
msgid "You may input new values for ~@{~S~^, ~}."
msgstr "Puede introducir nuevos valores."

#: macros2.lisp:58
#, lisp-format
msgid "~S must evaluate to a non-NIL value."
msgstr "~S no puede evaluarse como NIL."

#: macros2.lisp:84
#, lisp-format
msgid "The value of ~S must be of one of the types ~{~S~^, ~}"
msgstr "El valor de ~S debe ser de uno de los tipos ~{~S~^, ~}"

#: macros2.lisp:88
#, lisp-format
msgid "The value of ~S must be one of ~{~S~^, ~}"
msgstr "El valor de ~S debe ser uno de los siguientes ~{~S~^, ~}"

#: macros2.lisp:103 condition.lisp:1427
#, lisp-format
msgid "~S used as a key in ~S, it would be better to use parentheses."
msgstr "~S es usado como una clave en ~S, sería mejor utilizar paréntesis."

#: macros2.lisp:176
#, lisp-format
msgid "type name should be a symbol, not ~S"
msgstr "el nombre del tipo debe ser un símbolo, no ~S"

#: macros2.lisp:182
#, lisp-format
msgid "~S is a built-in type and may not be redefined."
msgstr "~S es un tipo predefinido y no puede ser redefinido."

#: macros2.lisp:211
#, lisp-format
msgid "The deftype expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de DEFTYPE para ~S no puede invocarse con ~S argumentos."

#: macros2.lisp:221
#, lisp-format
msgid "~S: the name of a symbol macro must be a symbol, not ~S"
msgstr "~S: el nombre de un símbolo de macro debe ser un símbolo, no ~S"

#: defs1.lisp:97
#, lisp-format
msgid "missing symbol types (~S/~S/~S) in ~S"
msgstr ""

#: defs1.lisp:105
#, fuzzy, lisp-format
msgid "~S: flag must be one of the symbols ~S, ~S, ~S, not ~S"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: defs1.lisp:480
#, lisp-format
msgid "~S: ~S does not name a logical host"
msgstr "~S: ~S no es el nombre de un anfitrión \"lógico\""

#: defs1.lisp:497
#, fuzzy, lisp-format
msgid "Loading logical hosts from file ~A ..."
msgstr "La carga del fichero "

#: defs1.lisp:502 defs1.lisp:510
#, fuzzy, lisp-format
msgid "Defined logical host ~A"
msgstr "La carga del fichero "

#: defs1.lisp:508
#, fuzzy, lisp-format
msgid "Loading logical host from file ~A ..."
msgstr "La carga del fichero "

#: defs1.lisp:538
#, lisp-format
msgid "No translations for logical host ~S found"
msgstr ""

#: defs1.lisp:600
#, lisp-format
msgid "~S: argument ~S should be a nonnegative number"
msgstr "~S: el argumento ~S debe ser un número no negativo"

#: defs1.lisp:760
#, fuzzy, lisp-format
msgid "incorrect date: ~S-~S-~S ~S:~S:~S, time zone ~S"
msgstr "fecha incorrecta: ~S/~S/~S, ~Sh~Sm~Ss, zona horaria ~S"

#: lambdalist.lisp:11
#, lisp-format
msgid "Lambda list marker ~S not allowed here."
msgstr "El marcador de la lista lambda ~S no está permitido aquí."

#: lambdalist.lisp:16
#, fuzzy, lisp-format
msgid "Invalid lambda list element ~S"
msgstr "Elemento inválido en lista lambda ~S"

#: lambdalist.lisp:17
#, fuzzy, lisp-format
msgid "Invalid lambda list element ~S. A lambda list may only contain symbols and lists."
msgstr "la lista lambda sólo puede contener símbolos y listas, no ~S"

#: lambdalist.lisp:31
#, fuzzy, lisp-format
msgid "Lambda list element ~S is superfluous. Only one variable is allowed after ~S."
msgstr "El elemento ~S de la lista lambda es innecesario."

#: lambdalist.lisp:32
#, fuzzy, lisp-format
msgid "Lambda list element ~S is superfluous. No variable is allowed right after ~S."
msgstr "El elemento ~S de la lista lambda es innecesario."

#: lambdalist.lisp:33
#, fuzzy, lisp-format
msgid "Lambda list element ~S (after ~S) is superfluous."
msgstr "El elemento ~S de la lista lambda es innecesario."

#: lambdalist.lisp:115 lambdalist.lisp:271 lambdalist.lisp:413 lambdalist.lisp:482 lambdalist.lisp:571 lambdalist.lisp:621
#, fuzzy, lisp-format
msgid "Missing ~S parameter in lambda list ~S"
msgstr "La lista lambda ~S necesita un parámetro &REST"

#: lambdalist.lisp:200 lambdalist.lisp:327 lambdalist.lisp:498 lambdalist.lisp:587
#, lisp-format
msgid "Lambda lists with dots are only allowed in macros, not here: ~S"
msgstr "Sólo se permiten las listas lambda con puntos en la macros, no aquí: ~S"

#: lambdalist.lisp:242
#, fuzzy, lisp-format
msgid "Duplicate variable name ~S"
msgstr "~S ~S: el nombre de la variable ~S está duplicado"

#: lambdalist.lisp:261
#, lisp-format
msgid "Invalid lambda list element ~S. Optional parameters cannot have default value forms in generic function lambda lists."
msgstr ""

#: lambdalist.lisp:314
#, lisp-format
msgid "Invalid lambda list element ~S. Keyword parameters cannot have default value forms in generic function lambda lists."
msgstr ""

#: places.lisp:24
#, lisp-format
msgid "The function (~S ~S) is hidden by a SETF expander."
msgstr "Una función de expansión de SETF oculta a la función (~S ~S)"

#: places.lisp:78
#, lisp-format
msgid "The argument ~S to ~S should be a keyword."
msgstr "El argumento ~S de ~S debe ser un argumento clave."

# Lo mismo de antes. A lo mejor se puede poner "modificable setf". sv
#: places.lisp:126
#, fuzzy, lisp-format
msgid "~S: Argument ~S is not a SETF place."
msgstr "El argumento ~S no es un lugar `setf' modificable"

#: places.lisp:135
#, fuzzy, lisp-format
msgid "SETF place ~S should produce exactly one store variable."
msgstr "El lugar `setf' ~ genera más de una variable de almacenamiento."

#: places.lisp:343
#, fuzzy, lisp-format
msgid "The name of the accessor must be a symbol, not ~S"
msgstr "El nombre de la función de acceso debe ser un símbolo, no ~S"

# Duda: En esta y otras partes de este archivo .po aparece la expresión
# `expander' (¡expansor es horrible!). Me dio muchisimos quebraderos de
# cabeza, pero muchos y francamente, estaba absolutamente atascado
# cuando lo pregunté en las listas de Spanish GNU y CLisp.
#
# Curiosamente, la única persona que respondió no tiene ni idea de
# español (Bruno Haible):
#
# "expander" or "expansion function", I would say.
#
# ¡Pues leches, eso mismo! Función de expansión me suena
# perfectísimamente, ...
#
#: places.lisp:378
#, lisp-format
msgid "The SETF expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de SETF para ~S no puede invocarse con ~S argumentos."

#: places.lisp:390 places.lisp:406 places.lisp:464
msgid "SETF expander"
msgstr ""

#: places.lisp:416
#, fuzzy, lisp-format
msgid "~S: Too many arguments: ~S"
msgstr "~: se han entregado demasiados argumentos a ~"

#: places.lisp:421
#, fuzzy, lisp-format
msgid "~S: The documentation string must be a string: ~S"
msgstr "~S: La cadena de control debe ser una cadena, y no ~S"

#: places.lisp:440 places.lisp:725 clos-methcomb2.lisp:186
#, fuzzy, lisp-format
msgid "~S ~S: invalid ~S lambda-list: ~A"
msgstr "~S ~S: parte de la lista lambda es inválida: ~S"

#: places.lisp:474
#, fuzzy, lisp-format
msgid "(~S ~S): Illegal syntax."
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: places.lisp:504
#, fuzzy, lisp-format
msgid "~S: index ~S is too large for ~S"
msgstr "~: el índice ~ es demasiado grande para ~"

#: places.lisp:835
#, fuzzy, lisp-format
msgid "~S: Illegal place: ~S"
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: places.lisp:854
#, fuzzy, lisp-format
msgid "~S: too few arguments: ~S"
msgstr "Muy pocos argumentos para ~S"

#: places.lisp:1013 places.lisp:1075
#, fuzzy, lisp-format
msgid "~S is only defined for functions of the form #'symbol."
msgstr "SETF APPLY sólo está definido para funciones de la forma #'símbolo."

# Duda: en Common Lisp existe lo que se denominan los `setf places'. En
# realidad, es una manera bastante correcta de referirse a posiciones de
# memoria (cuyos nombres pueden ser variables, funciones, etc.) que son
# modificables con la primitiva SETF de Lisp. Por ello, traducirlo como
# `modificable' es eminentemente correcto, pero en realidad me da miedo
# porque a los programadores experimentados les mosqueará lo de
# `modificable' a secas. Les resultará mucho más familiar algo como
# `setf modificables', aunque en español esto suene bastante
# regular. cll
#
# En cualquier caso, cuando uno se empeña en emplear la palabra inglesa,
# siempre queda la posibilidad de conservar la sintaxis española,
# por ejemplo: "... no es un lugar modificable `setf'" sv
#
#: places.lisp:1021
#, fuzzy, lisp-format
msgid "~S on ~S is not a SETF place."
msgstr "APPLY de ~S no es un lugar `setf' modificable"

#: places.lisp:1120
#, lisp-format
msgid "SETF place ~S expects different numbers of values in the true and false branches (~D vs. ~D values)."
msgstr ""

#: floatprint.lisp:332
#, lisp-format
msgid "argument is not a float: ~S"
msgstr "el argumento no es un número en coma flotante: ~S"

#: defpackage.lisp:55
#, lisp-format
msgid "~S ~A: the symbol ~A must not be specified more than once"
msgstr "~S ~A: el símbolo ~A no debe especificarse más de una vez"

#: defpackage.lisp:78 defpackage.lisp:86
#, lisp-format
msgid "~S ~A: the ~S option must not be given more than once"
msgstr "~S ~A: no se debe poner la opción ~S más de una vez"

#: defpackage.lisp:135
#, lisp-format
msgid "~S ~A: unknown option ~S"
msgstr "~S ~A: la opción ~S es desconocida"

#: defpackage.lisp:140
#, lisp-format
msgid "~S ~A: invalid syntax in ~S option: ~S"
msgstr "~S ~A: la sintaxis de la opción ~S es inválida: ~S"

#: defpackage.lisp:145
#, lisp-format
msgid "~S ~A: not a ~S option: ~S"
msgstr "~S ~A: no se trata de una opción ~S: ~S"

#: defpackage.lisp:212
#, lisp-format
msgid "This symbol will be created."
msgstr "Este símbolo será creado."

#: defpackage.lisp:213
#, lisp-format
msgid "~S ~A: There is no symbol ~A::~A ."
msgstr "~S ~A: El símbolo ~A::~A no existe."

#: type.lisp:63 compiler.lisp:7055
#, lisp-format
msgid "~S: argument to SATISFIES must be a symbol: ~S"
msgstr "~S: el argumento de SATISFIES debe ser un símbolo: ~S"

#: type.lisp:160 condition.lisp:179
#, lisp-format
msgid "~S: type ~S is not a subtype of ~S"
msgstr "~S: el tipo ~S no es un subtipo de ~S"

# Duda: En este mensaje, el primer "~S" se sustituye por el nombre de una
# función y el segundo "~S" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: type.lisp:352
#, fuzzy, lisp-format
msgid "~S: dimension ~S is invalid"
msgstr "~S no es posible sobre el flujo ~S"

# Duda: En este mensaje, el primer "~S" se sustituye por el nombre de una
# función y el segundo "~S" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: type.lisp:357
#, fuzzy, lisp-format
msgid "~S: rank ~S is invalid"
msgstr "~S no es posible sobre el flujo ~S"

#: type.lisp:402 type.lisp:420
#, lisp-format
msgid "~S: argument to ~S must be *, ~S or a list of ~S: ~S"
msgstr "~S: el argumento de ~S debe ser *, ~S o una lista de ~S: ~S"

#: type.lisp:518
#, lisp-format
msgid "~S: argument to MOD must be an integer: ~S"
msgstr "~S: el argumento de MOD debe ser un entero: ~S"

#: type.lisp:526 type.lisp:535
#, fuzzy, lisp-format
msgid "~S: argument to ~S must be an integer or * : ~S"
msgstr "~S: el argumento de SIGNED-BYTE debe ser un entero o * : ~S"

#: type.lisp:1108 type.lisp:1132
#, fuzzy, lisp-format
msgid "~S is not up-to-date with ~S for element type ~S"
msgstr "el objeto no es del tipo requerido"

#: clos-slotdef1.lisp:198
#, lisp-format
msgid "(~S ~S): The slot name is not specified."
msgstr ""

#: clos-slotdef1.lisp:201
#, fuzzy, lisp-format
msgid "(~S ~S): The slot name should be a symbol, not ~S"
msgstr "~S: el nombre de una macro debe ser un símbolo, no ~S"

#: clos-slotdef1.lisp:204
#, fuzzy, lisp-format
msgid "(~S ~S) for slot ~S: The ~S and ~S arguments can only be specified together."
msgstr "~S ~S: ~S sólo puede especificarse una vez."

#: clos-slotdef1.lisp:209
#, fuzzy, lisp-format
msgid "(~S ~S) for slot ~S: The ~S argument should be a function, not ~S"
msgstr "~S : El argumento debe ser del tipo FIXNUM >=0 y no ~S"

#: clos-slotdef1.lisp:212
#, fuzzy, lisp-format
msgid "(~S ~S) for slot ~S: The ~S argument should be a symbol, not ~S"
msgstr "~S: el argumento debe ser una cadena de caracteres, no ~S"

#
# "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: clos-slotdef1.lisp:215
#, fuzzy, lisp-format
msgid "(~S ~S) for slot ~S: The ~S argument should be a proper list of symbols, not ~S"
msgstr "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S"

#: clos-slotdef1.lisp:218
#, fuzzy, lisp-format
msgid "(~S ~S) for slot ~S: The ~S argument should be a string or NIL, not ~S"
msgstr "~S: el argumento del código debe ser un entero y no ~S"

#
# "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: clos-slotdef1.lisp:243 clos-slotdef1.lisp:246
#, fuzzy, lisp-format
msgid "(~S ~S) for slot ~S: The ~S argument should be a proper list of function names, not ~S"
msgstr "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S"

#: clos-slotdef1.lisp:423
#, fuzzy, lisp-format
msgid "Wrong ~S result for class ~S: not a property list: ~S"
msgstr "~S: la metaclase STRUCTURE-CLASS prohibe más de una superclase directa"

#: clos-slotdef1.lisp:426
#, lisp-format
msgid "Wrong ~S result for class ~S, slot ~S: value of ~S is wrong: ~S"
msgstr ""

#: clos-slotdef1.lisp:436 clos-slotdef1.lisp:442 clos-class3.lisp:1180 clos-class3.lisp:1186 clos-class3.lisp:1601 clos-class3.lisp:1643
#, lisp-format
msgid "Wrong ~S result for class ~S: not a subclass of ~S: ~S"
msgstr ""

#: clos-slotdef1.lisp:462 clos-class3.lisp:213 clos-class3.lisp:224
#, lisp-format
msgid "~S ~S, slot option for slot ~S: ~S is not a valid slot option"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una opción de ranura válida"

#: clos-specializer1.lisp:112
#, lisp-format
msgid "~S: Some methods have been removed from their generic function, but the list in the ~S specializer was not updated."
msgstr ""

#: clos-class1.lisp:316 clos-class1.lisp:339 clos-class1.lisp:350
#, fuzzy, lisp-format
msgid "(~S ~S) for class ~S: The ~S argument should be a proper list, not ~S"
msgstr "~S: el argumento debe ser un entero, no ~S"

#: clos-class1.lisp:323
#, fuzzy, lisp-format
msgid "(~S ~S) for class ~S: The direct-superclasses list should consist of classes, not ~S"
msgstr "~S ~S: la superclase ~S debe pertenecer a la clase STANDARD-CLASS"

#: clos-class1.lisp:328
#, fuzzy, lisp-format
msgid "(~S ~S) for class ~S: The metaclass ~S forbids more than one direct superclass: It does not support multiple inheritance."
msgstr "~S: la metaclase STRUCTURE-CLASS prohibe más de una superclase directa"

#: clos-class1.lisp:344
#, lisp-format
msgid "(~S ~S) for class ~S: The direct slot specification ~S is not in the canonicalized form (slot-name initform initfunction)."
msgstr ""

#: clos-class1.lisp:355
#, lisp-format
msgid "(~S ~S) for class ~S: The direct default initarg ~S is not in canonicalized form (a property list)."
msgstr ""

#: clos-class1.lisp:361
#, fuzzy, lisp-format
msgid "(~S ~S) for class ~S: The ~S argument should be a string or NIL, not ~S"
msgstr "~: el argumento de los bits debe ser un entero y no ~"

#: clos-class2.lisp:98
#, lisp-format
msgid "~S: argument ~S is not a symbol"
msgstr "~S: el argumento ~S no es un símbolo"

#: clos-class2.lisp:109
#, lisp-format
msgid "~S: cannot redefine built-in class ~S"
msgstr "~S: no se puede redefinir la clase predefinida ~S"

#: clos-class2.lisp:114 describe.lisp:69
msgid "class"
msgstr "clase"

#: clos-class3.lisp:51 clos-class3.lisp:448 clos-class3.lisp:570
#, lisp-format
msgid "~S: class name ~S should be a symbol"
msgstr "~S: el nombre de la clase ~S debe ser un símbolo"

#: clos-class3.lisp:59
#, lisp-format
msgid "~S ~S: expecting list of superclasses instead of ~S"
msgstr "~S ~S: se esperaba una lista de superclases en vez de ~S"

#: clos-class3.lisp:66
#, lisp-format
msgid "~S ~S: superclass name ~S should be a symbol"
msgstr "~S ~S: el nombre de la superclase ~S debe ser un símbolo"

#: clos-class3.lisp:79
#, lisp-format
msgid "~S ~S: expecting list of slot specifications instead of ~S"
msgstr "~S ~S: se esperaba una lista de especificación de ranuras en vez de ~S"

#: clos-class3.lisp:89
#, lisp-format
msgid "~S ~S: Every second slot name is a keyword, and these slots have no options. If you want to define a slot with options, you need to enclose all slot specifications in parentheses: ~S, not ~S."
msgstr ""

#: clos-class3.lisp:100
#, lisp-format
msgid "~S ~S: slot name ~S should be a symbol"
msgstr "~S ~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos-class3.lisp:106
#, lisp-format
msgid "~S ~S: There may be only one direct slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura directa con el nombre ~S."

#: clos-class3.lisp:121
#, lisp-format
msgid "~S ~S: slot options for slot ~S must come in pairs"
msgstr "~S ~S: las opciones de ranura para ~S no aparecen por pares"

#: clos-class3.lisp:133 clos-class3.lisp:149
#, fuzzy, lisp-format
msgid "~S ~S, slot option for slot ~S: ~S is not a non-NIL symbol"
msgstr "~S ~S, opción de ranura para ~S: ~S no es un símbolo"

#: clos-class3.lisp:141
#, lisp-format
msgid "~S ~S, slot option for slot ~S: ~S is not a function name"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una función"

#: clos-class3.lisp:158
#, fuzzy, lisp-format
msgid "~S ~S, slot option ~S for slot ~S: ~S is not a symbol"
msgstr "~S ~S, opción de ranura para ~S: ~S no es un símbolo"

#: clos-class3.lisp:164 clos-class3.lisp:180 clos-class3.lisp:189 clos-class3.lisp:197
#, lisp-format
msgid "~S ~S, slot option ~S for slot ~S may only be given once"
msgstr "~S ~S, la opción de ranura ~S para ~S solo debe indicarse una vez"

#: clos-class3.lisp:172
#, lisp-format
msgid "~S ~S, slot option for slot ~S: ~S is not a symbol"
msgstr "~S ~S, opción de ranura para ~S: ~S no es un símbolo"

#: clos-class3.lisp:203
#, lisp-format
msgid "~S ~S, slot option for slot ~S: ~S is not a string"
msgstr "~S ~S, opción de ranura para ~S: ~S no es una cadena de caracteres"

#: clos-class3.lisp:282 clos-class3.lisp:365 clos-methcomb2.lisp:1141 clos-methcomb2.lisp:1155 clos-methcomb2.lisp:1163
#, fuzzy, lisp-format
msgid "~S ~S: option ~S may only be given once"
msgstr "~S ~S, la opción ~S sólo se puede indicar una vez"

#: clos-class3.lisp:292 clos-class3.lisp:319 clos-methcomb2.lisp:1169
#, lisp-format
msgid "~S ~S, option ~S: ~S is not a symbol"
msgstr "~S ~S, opción ~S: ~S no es un símbolo"

#: clos-class3.lisp:301
#, lisp-format
msgid "~S ~S: option ~S should be written ~S"
msgstr "~S ~S: la opción ~S debe escribirse como ~S"

#: clos-class3.lisp:307
#, lisp-format
msgid "~S ~S, option ~S: arguments must come in pairs"
msgstr "~S ~S, opción ~S: los argumentos no aparecen en pares"

#: clos-class3.lisp:325
#, lisp-format
msgid "~S ~S, option ~S: ~S may only be given once"
msgstr "~S ~S, opción ~S: ~S sólo se puede poner una vez"

#: clos-class3.lisp:340
#, lisp-format
msgid "~S ~S, option ~S: ~S is not a string"
msgstr "~S ~S, opción ~S: ~S no es una cadena de caracteres"

#: clos-class3.lisp:351 clos-class3.lisp:372 clos-class3.lisp:396 clos-genfun3.lisp:556
#, lisp-format
msgid "~S ~S: invalid option ~S"
msgstr "~S ~S: la opción ~S es inválida"

#: clos-class3.lisp:455
#, lisp-format
msgid "~S for class ~S: metaclass ~S is neither a class or a symbol"
msgstr ""

#: clos-class3.lisp:459
#, lisp-format
msgid "~S for class ~S: metaclass ~S is not a subclass of CLASS"
msgstr ""

#: clos-class3.lisp:462
#, fuzzy, lisp-format
msgid "~S for class ~S: The ~S argument should be a proper list, not ~S"
msgstr "~S: el argumento del código debe ser un entero y no ~S"

#: clos-class3.lisp:469
#, fuzzy, lisp-format
msgid "~S for class ~S: The direct-superclasses list should consist of classes and symbols, not ~S"
msgstr "~S en ~S: el tipo de una estructura debe ser un símbolo, no ~S"

#: clos-class3.lisp:488
#, fuzzy, lisp-format
msgid "Cannot redefine ~S with a different metaclass ~S"
msgstr "~S: no se puede redefinir la clase predefinida ~S"

#: clos-class3.lisp:577
#, lisp-format
msgid "Wrong ~S result for ~S: not a class: ~S"
msgstr ""

#: clos-class3.lisp:607
#, lisp-format
msgid "Redefining metaobject class ~S has no effect."
msgstr ""

#: clos-class3.lisp:805
#, fuzzy, lisp-format
msgid "(~S ~S): superclass ~S should be of class ~S"
msgstr "~S ~S: la superclase ~S debe pertenecer a la clase STANDARD-CLASS"

#: clos-class3.lisp:828
#, lisp-format
msgid "(~S ~S) for class ~S: ~S does not allow ~S to become a subclass of ~S. You may define a method on ~S to allow this."
msgstr ""

#: clos-class3.lisp:861 clos-class3.lisp:1044 clos-class3.lisp:1245 clos-class3.lisp:1375 clos-class3.lisp:1519
#, lisp-format
msgid "Wrong ~S result for class ~S: not a proper list: ~S"
msgstr ""

#: clos-class3.lisp:865 clos-class3.lisp:1048
#, lisp-format
msgid "Wrong ~S result for class ~S: list element is not a class: ~S"
msgstr ""

#: clos-class3.lisp:868
#, fuzzy, lisp-format
msgid "Wrong ~S result for class ~S: ~S is not a direct superclass of ~S"
msgstr "~S: la metaclase STRUCTURE-CLASS prohibe más de una superclase directa"

#: clos-class3.lisp:994
#, lisp-format
msgid "~S ~S: inconsistent precedence graph, cycle ~S"
msgstr "~S ~S: grafo de precedencia inconsistente, ciclo ~S"

#: clos-class3.lisp:1026
#, lisp-format
msgid "(class-precedence-list ~S) and (class-precedence-list ~S) are inconsistent"
msgstr "(class-precedence-list ~S) y (class-precedence-list ~S) son inconsistentes"

#: clos-class3.lisp:1051
#, lisp-format
msgid "Wrong ~S result for class ~S: list doesn't start with the class itself: ~S"
msgstr ""

#: clos-class3.lisp:1055
#, lisp-format
msgid "Wrong ~S result for class ~S: list doesn't end with ~S: ~S"
msgstr ""

#: clos-class3.lisp:1058
#, lisp-format
msgid "Wrong ~S result for class ~S: list contains duplicates: ~S"
msgstr ""

#: clos-class3.lisp:1066
#, lisp-format
msgid "Wrong ~S result for class ~S: list doesn't contain the superclass~[~;~:;es~] ~{~S~^, ~}."
msgstr ""

#: clos-class3.lisp:1070
#, lisp-format
msgid "Wrong ~S result for class ~S: list contains elements that are not superclasses: ~{~S~^, ~}"
msgstr ""

#: clos-class3.lisp:1098
#, fuzzy, lisp-format
msgid "~S: argument should be a non-empty proper list, not ~S"
msgstr "~S: el argumento debe ser un entero, no ~S"

#: clos-class3.lisp:1102
#, fuzzy, lisp-format
msgid "~S: argument list element is not a ~S: ~S"
msgstr "~S: el argumento ~S no es el flujo de un fichero abierto"

#: clos-class3.lisp:1108
#, fuzzy, lisp-format
msgid "~S: argument list elements should all have the same name, not ~S and ~S"
msgstr "~S: el argumento debe ser un paquete o el nombre de un paquete, no ~S"

#: clos-class3.lisp:1163
#, lisp-format
msgid "Wrong ~S result for ~S: not a list of keyword/value pairs: ~S"
msgstr ""

#: clos-class3.lisp:1169
#, lisp-format
msgid "Wrong ~S result for ~S: missing ~S"
msgstr ""

#: clos-class3.lisp:1171
#, lisp-format
msgid "Wrong ~S result for ~S: invalid ~S value"
msgstr ""

#: clos-class3.lisp:1231
#, lisp-format
msgid "Wrong ~S result for class ~S, slot ~S: not an ~S instance: ~S"
msgstr ""

#: clos-class3.lisp:1250 clos-class3.lisp:1256 clos-class3.lisp:1379
#, lisp-format
msgid "Wrong ~S result for class ~S: list element is not a ~S: ~S"
msgstr ""

#: clos-class3.lisp:1261 clos-class3.lisp:1384
#, lisp-format
msgid "Wrong ~S result for class ~S: list contains duplicate slot names: ~S"
msgstr ""

#: clos-class3.lisp:1283
#, lisp-format
msgid "In class ~S, the slot ~S is constrained by incompatible constraints inherited from the superclasses."
msgstr ""

#: clos-class3.lisp:1288
#, lisp-format
msgid "In class ~S, non-local slot ~S is constrained to be a local slot at offset ~S."
msgstr ""

#: clos-class3.lisp:1298
#, lisp-format
msgid "In class ~S, the slots ~S and ~S are constrained from the superclasses to both be located at offset ~S."
msgstr ""

#: clos-class3.lisp:1309
#, lisp-format
msgid "In class ~S, a slot constrained from a superclass wants to be located at offset ~S, which is impossible."
msgstr ""

#: clos-class3.lisp:1362
#, lisp-format
msgid "In class ~S, constrained slot locations cause holes to appear."
msgstr ""

#: clos-class3.lisp:1390
#, fuzzy, lisp-format
msgid "Wrong ~S result for class ~S: no slot location has been assigned to ~S"
msgstr "~S: la metaclase STRUCTURE-CLASS prohibe más de una superclase directa"

#: clos-class3.lisp:1523
#, lisp-format
msgid "Wrong ~S result for class ~S: list element is not a canonicalized default initarg: ~S"
msgstr ""

#: clos-class3.lisp:1527
#, lisp-format
msgid "Wrong ~S result for class ~S: list contains duplicate initarg names: ~S"
msgstr ""

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: clos-class3.lisp:1546
#, fuzzy
msgid "method"
msgstr "~%Sin ranuras."

#: clos-class3.lisp:1835
#, fuzzy, lisp-format
msgid "(~S ~S): metaclass ~S does not support shared slots"
msgstr "~S: la metaclase STRUCTURE-CLASS no mantiene ranuras compartidas"

#: clos-class3.lisp:1955
#, lisp-format
msgid "~S: class definition circularity: ~S depends on itself"
msgstr ""

#: clos-class3.lisp:1963
#, lisp-format
msgid "~S has a direct-superclasses element ~S, which is invalid."
msgstr ""

#: clos-class3.lisp:2014
#, lisp-format
msgid "~S: Cannot finalize class ~S. ~:{Class ~S inherits from class ~S. ~}Class ~S is not yet defined."
msgstr ""

#: clos-class3.lisp:2094
#, fuzzy, lisp-format
msgid "~S: Class ~S (or one of its ancestors) is being redefined, but its instances cannot be made obsolete"
msgstr "~S: La clase ~S ha sido redefinida, las instancias son obsoletas"

#: clos-class3.lisp:2104
#, fuzzy, lisp-format
msgid "~S: Class ~S (or one of its ancestors) is being redefined, instances are obsolete"
msgstr "~S: La clase ~S ha sido redefinida, las instancias son obsoletas"

#: clos-class3.lisp:2106
#, lisp-format
msgid "~S: instances of class ~S are made obsolete"
msgstr ""

#: defstruct.lisp:369
#, fuzzy, lisp-format
msgid "~S ~S: In ~S argument list: ~A"
msgstr "~S%lista de argumentos: "

#: defstruct.lisp:537
#, fuzzy, lisp-format
msgid "The class ~S is not a structure class: ~S"
msgstr "El valor de ~S no es un flujo: ~S"

#: defstruct.lisp:545
#, fuzzy, lisp-format
msgid "The class ~S has no slot named ~S."
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: defstruct.lisp:553
#, fuzzy, lisp-format
msgid "The structure type ~S has been defined as a class."
msgstr "~ en ~: no se ha definido ninguna estructura del tipo ~"

#: defstruct.lisp:555
#, fuzzy, lisp-format
msgid "The structure type ~S has not been defined."
msgstr "~S ~S: la estructura incluida ~S no ha sido definida."

#: defstruct.lisp:563
#, fuzzy, lisp-format
msgid "The structure type ~S has no slot named ~S."
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: defstruct.lisp:626
#, lisp-format
msgid "~S: invalid syntax for name and options: ~S"
msgstr "~S: la sintáxis del nombre y las opciones es inválida: ~S"

#: defstruct.lisp:650
#, lisp-format
msgid "~S ~S: argument list should be a list: ~S"
msgstr "~S ~S: la lista de argumentos debe ser una lista: ~S"

#: defstruct.lisp:670
#, lisp-format
msgid "~S ~S: At most one :INCLUDE argument may be specified: ~S"
msgstr "~S ~S: Sólo puede especificarse un argumento :INCLUDE como mucho: ~S"

#: defstruct.lisp:677
#, lisp-format
msgid ""
"~S: Use of ~S implicitly applies FUNCTION.~@\n"
"                                     Therefore using ~S instead of ~S."
msgstr ""
"~S: El uso de ~S aplica, implícitamente, FUNCTION.~@\n"
"                                     Por lo tanto, se utilizará ~S en vez de ~S."

#: defstruct.lisp:691 condition.lisp:122
#, lisp-format
msgid "~S ~S: unknown option ~S"
msgstr "~S ~S: opción ~S desconocida"

#: defstruct.lisp:696 clos-genfun3.lisp:446 condition.lisp:128
#, lisp-format
msgid "~S ~S: invalid syntax in ~S option: ~S"
msgstr "~S ~S: la sintaxis de la opción ~S es inválida: ~S"

#: defstruct.lisp:701 clos-genfun3.lisp:320 condition.lisp:133
#, lisp-format
msgid "~S ~S: not a ~S option: ~S"
msgstr "~S ~S: no se trata de una opción ~S: ~S"

# Duda: (y además gorda) Podría parecer que el siguiente mensaje debiera
# traducirse por:
#
# ~S ~S: No hay ningún :PREDICATE sobre estructuras sin nombre.
#
# Sin embargo, el manual "Common Lisp, The Language - 2nd Edition", en
# la página 477 advierte que, en realidad, la opción :PREDICATE no debe
# usarse con estructuras sin nombre:
#
# `A predicate can be defined only if the structure is "named"'
#
# Por lo tanto, he preferido traducir este mensaje de otra manera, tal y
# como veis:
#
#: defstruct.lisp:726
#, fuzzy, lisp-format
msgid "~S ~S: There is no ~S for unnamed structures."
msgstr "~S ~S: No puede definirse un :PREDICATE sobre estructuras sin nombre."

#: defstruct.lisp:749
#, lisp-format
msgid "~S ~S: invalid :TYPE option ~S"
msgstr "~S ~S: opción :TYPE inválida ~S"

#: defstruct.lisp:756
#, lisp-format
msgid "~S ~S: The :INITIAL-OFFSET must be a nonnegative integer, not ~S"
msgstr "~S ~S: El :INITIAL-OFFSET debe ser un entero no negativo, y no ~S"

#: defstruct.lisp:763
#, lisp-format
msgid "~S ~S: :INITIAL-OFFSET must not be specified without :TYPE : ~S"
msgstr "~S ~S: El :INITIAL-OFFSET no debe especificarse sin :TYPE : ~S"

#: defstruct.lisp:785
#, lisp-format
msgid "~S ~S: included structure ~S has not been defined."
msgstr "~S ~S: la estructura incluida ~S no ha sido definida."

#: defstruct.lisp:791
#, fuzzy, lisp-format
msgid "~S ~S: included structure ~S is not a structure type."
msgstr "~S ~S: la estructura incluida ~S debe ser del tipo ~S."

#: defstruct.lisp:804
#, lisp-format
msgid "~S ~S: included structure ~S must be of the same type ~S."
msgstr "~S ~S: la estructura incluida ~S debe ser del tipo ~S."

#: defstruct.lisp:834
#, lisp-format
msgid "~S ~S: included structure ~S has no component with name ~S."
msgstr "~S ~S: la estructura incluida ~S no tiene ninguna componente con el nombre ~S."

#: defstruct.lisp:868
#, lisp-format
msgid "~S ~S: The READ-ONLY slot ~S of the included structure ~S must remain READ-ONLY in ~S."
msgstr "~S ~S: La ranura READ-ONLY ~S de la estructura incluida ~S debe permanecer READ-ONLY en ~S."

#: defstruct.lisp:879
#, lisp-format
msgid "~S ~S: The type ~S of slot ~S should be a subtype of the type defined for the included strucure ~S, namely ~S."
msgstr "~S ~S: El tipo ~S de la ranura ~S debe ser un subtipo del que ha sido definido para la estructura incluida ~S, a saber, ~S."

#: defstruct.lisp:886 defstruct.lisp:993
#, lisp-format
msgid "~S ~S: ~S is not a slot option."
msgstr "~S ~S: ~S no es una opción de ranura."

#: defstruct.lisp:934
#, lisp-format
msgid "~S ~S: structure of type ~S cannot hold the name."
msgstr "~S ~S: una estructura del tipo ~S no puede contener el nombre."

#: defstruct.lisp:979
#, lisp-format
msgid "~S ~S: There may be only one slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura con el nombre ~S."

#: defstruct.lisp:1011
#, fuzzy, lisp-format
msgid "~S ~S: Slot ~S accessor will shadow the predicate ~S."
msgstr "~S ~S: la opción ~S debe escribirse como ~S"

#: format.lisp:73
#, fuzzy
msgid "The control string terminates within a format directive."
msgstr "La cadena de control termina en una directiva."

#: format.lisp:130
#, lisp-format
msgid "~A must introduce a number."
msgstr "~A debe introducir un número."

#: format.lisp:139
msgid "The control string terminates in the middle of a parameter."
msgstr "La cadena de control termina en medio de un parámetro."

#: format.lisp:215
#, fuzzy
msgid "Non-existent format directive"
msgstr "Directiva no existente"

#: format.lisp:222
msgid "Closing '/' is missing"
msgstr ""

#: format.lisp:236
#, fuzzy, lisp-format
msgid "There is no package with name ~S"
msgstr "No hay ningún paquete con el nombre ~"

#: format.lisp:254
#, fuzzy, lisp-format
msgid "The closing format directive '~A' does not have a corresponding opening one."
msgstr "No existe una directiva de apertura para la de cierre `~A'."

#: format.lisp:258
#, fuzzy, lisp-format
msgid "The closing format directive '~A' does not match the corresponding opening one. It should read '~A'."
msgstr "La directiva de cierre `~A' no se corresponde con la de apertura. Debe leerse `~A'."

#: format.lisp:265 format.lisp:1498 format.lisp:2291
#, fuzzy, lisp-format
msgid "The ~~; format directive is not allowed at this point."
msgstr "La directiva ~~; no está permitida aquí."

# Ojo: Estos "ing" no son siempre gerundios.
# Tal vez sea simplemente "...; se esperaba '~A'." sv
#
# Bueno, ..., cuando el mensaje ha salido es que se ha producido un
# error. En tal caso, no se puede estar `esper*ando*', sino que se
# esperaba, ... Si, creo que tienes toda la razón. cll
#
#: format.lisp:289
#, fuzzy, lisp-format
msgid "An opening format directive is never closed; expecting '~A'."
msgstr "No se ha cerrado una directiva; se esperaba `~A'."

#: format.lisp:320
msgid "Current point in control string:"
msgstr "Posición en curso en la cadena de control:"

#: format.lisp:339
#, fuzzy, lisp-format
msgid "The ~A format directive cannot take both modifiers."
msgstr "La directiva ~~[ no puede tomar ambos modificadores."

# Duda: `fill pointer' (puntero de llenado, o de relleno) es un
# recurso que existe en Common Lisp (y por lo tanto, en CLisp) para
# determinar qué parte de un vector está en uso (la que hay desde el
# principio hasta la posición apuntada por el `fill pointer'). Se trata
# de un término que cualquier programador en Lisp debe conocer porque
# esta palabra clave se utiliza en ocasiones, incluso, como palabra
# reservada para indicar una determinada opción en algunas funciones.
#
# Por ese motivo, he decidido dejarla tal cual, sin traducir. Cuando
# pregunté a Bruno Haible sobre esto me respondió:
#
# Imagine a device attached to a bottle or tank, which shows how much full
# the bottle is, in percent. How would you call this device?
#
# ... y francamente, ¡no se me ocurre como!
#
# Bueno, con el tiempo he decidido que (tal y como señala Bruno Haible)
# lo mejor sería: "puntero de relleno".
#
#: format.lisp:362
#, lisp-format
msgid "The destination string ~S should have a fill pointer."
msgstr "La cadena de destino ~S debe tener un puntero de relleno."

#: format.lisp:403
#, fuzzy
msgid "There are not enough arguments left for this format directive."
msgstr "No hay argumentos suficientes para esta directiva."

#: format.lisp:406
#, fuzzy, lisp-format
msgid "The argument list is a dotted list: ~S"
msgstr "~S: el argumento :OUT no es un puntero: ~S"

#: format.lisp:491
#, fuzzy, lisp-format
msgid "The ~~:@R format directive requires an integer in the range 1 - 4999, not ~S"
msgstr "La directiva ~~:@R necesita un entero en el rango 1 - 4999, no ~S"

#: format.lisp:507
#, fuzzy, lisp-format
msgid "The ~~@R format directive requires an integer in the range 1 - 3999, not ~S"
msgstr "La directiva ~~@R necesita un entero en el rango 1 - 3999, no ~S"

#: format.lisp:564
#, fuzzy, lisp-format
msgid "The argument for the ~~R format directive is too large."
msgstr "El argumento de la directiva ~~R es demasiado grande."

#: format.lisp:1195
#, fuzzy, lisp-format
msgid "The ~~R and ~~:R format directives require an integer argument, not ~S"
msgstr "Las directivas ~~R y ~~:R necesitan un argumento entero, no ~S"

#: format.lisp:1215
#, fuzzy, lisp-format
msgid "The ~~C format directive requires a character argument, not ~S"
msgstr "La directiva ~~C necesita un carácter como argumento, no ~S"

#: format.lisp:1443
#, fuzzy, lisp-format
msgid "The control string argument for the ~~? format directive is invalid: ~S"
msgstr "La cadena de control de la directiva ~~? es inválida: ~S"

#: format.lisp:1448
#, fuzzy, lisp-format
msgid "The argument list argument for the ~~? format directive is invalid: ~S"
msgstr "El argumento de la lista de argumentos de la directiva ~~? es inválido: ~S"

#: format.lisp:1503
#, lisp-format
msgid "The ~~[ parameter must be an integer, not ~S"
msgstr "El parámetro para ~~[ debe ser un entero, no ~S"

#: format.lisp:1536
#, fuzzy, lisp-format
msgid "The ~~{ format directive requires a list argument, not ~S"
msgstr "La directiva ~~{ requiere una lista de argumentos, no ~S"

#: format.lisp:1688
msgid "Prefix for logical block must be constant"
msgstr ""

#: format.lisp:1700
msgid "Logical block suffix must be constant"
msgstr ""

#: format.lisp:2052
#, fuzzy
msgid "Too many arguments for this format directive"
msgstr "Demasiados argumentos para esta directiva"

#: international.lisp:46
#, lisp-format
msgid "Language ~S is not defined"
msgstr "El lenguaje ~S no está definido"

#: international.lisp:56
#, lisp-format
msgid "Language ~S inherits from ~S"
msgstr "El lenguaje ~S hereda de ~S"

#: international.lisp:106
#, lisp-format
msgid "~S: Language ~S is not defined"
msgstr "~S: El lenguaje ~S no está definido"

#: international.lisp:129
#, lisp-format
msgid "~S ~S: no value for default language ~S"
msgstr "~S ~S: no hay ningún valor para el lenguaje por defecto ~S"

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#: savemem.lisp:86
#, fuzzy, lisp-format
msgid "Wrote the memory image into ~A (~:D byte~:P)"
msgstr "No es el nombre de una función: ~S"

#: trace.lisp:40
#, fuzzy, lisp-format
msgid "~S: no local name ~S in ~S"
msgstr "~S: anfitrión ~S desconocido en ~S"

#: trace.lisp:53
#, fuzzy, lisp-format
msgid "~S: ~S does not name a closure"
msgstr "~S: ~S no nombra una clase"

#: trace.lisp:161
#, fuzzy, lisp-format
msgid "~S: cannot trace special operator ~S"
msgstr "~S: no es posible rastrear la forma especial ~S"

#: trace.lisp:189
#, lisp-format
msgid ";; Tracing ~:[function~;macro~] ~S."
msgstr ";; Rastreando la ~:[función~;macro~] ~S."

#: trace.lisp:327
#, lisp-format
msgid "~S: ~S was traced and has been redefined!"
msgstr "~S: ¡~S estaba siendo rastreada y ha sido redefinida!"

#: cmacros.lisp:81
#, fuzzy
msgid "compiler macro"
msgstr "Compilador de C"

# Aquí también junto las exclamaciones. sv
#: compiler.lisp:672
#, lisp-format
msgid "Compiler bug!! Occurred in ~A~@[ at ~A~]."
msgstr "aError del compilador!! Ocurrió en ~A~@[ en ~A~]."

#: compiler.lisp:1434
#, lisp-format
msgid "Not a valid optimization level for ~S, should be one of 0, 1, 2, 3: ~S"
msgstr ""

#: compiler.lisp:1436
#, fuzzy, lisp-format
msgid "~S is not a valid ~S quality."
msgstr "~ no es un byte CODE-VECTOR válido"

#: compiler.lisp:1437 compiler.lisp:1544
#, fuzzy, lisp-format
msgid "Not a valid ~S specifier: ~S"
msgstr "~S ~S: la opción ~S es inválida"

# Soy alérgico al verbo "ignorar". Ignorar en español significa no saber.
# Y eso en inglés se dice "not to know".
# Posibilidades: Descartar, no tener en cuenta. sv
#
# :) Bueno, ... :) Lo cierto es que en el diccionario pone:
#
# "No saber una cosa o muchas cosas, o, de lo contrario, no tener
# noticia de ellas."
#
# O sea, que algo se ignora si no se tienen noticias de ello, ... Creo
# que la traducción está, por lo tanto, correcta. Ahora bien, "no tener
# en cuenta" o "descartar" también me parece muy correcto así que, ¿por
# qué no iba a cambiarlo? :) cll
#
#: compiler.lisp:1455
#, lisp-format
msgid "Bad declaration syntax: ~S~%Will be ignored."
msgstr "Sintaxis de la declaración incorrecta:~S~%No se tendrá en cuenta."

#: compiler.lisp:1468 compiler.lisp:1474 compiler.lisp:1480 compiler.lisp:1486
#, fuzzy, lisp-format
msgid "Non-symbol ~S may not be declared ~S."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lisp:1498
#, fuzzy, lisp-format
msgid "Non-symbol ~S may not be subject to a TYPE declaration."
msgstr "El \"no símbolo\" ~S no debe declararse IGNORE."

#: compiler.lisp:1509
#, lisp-format
msgid "~S is not a function name and therefore may not be subject to a FTYPE declaration."
msgstr ""

#: compiler.lisp:1520
#, fuzzy, lisp-format
msgid "~S is not a function name and therefore may not be declared ~S."
msgstr "~S es un tipo predefinido y no puede ser redefinido."

#: compiler.lisp:1555
#, fuzzy, lisp-format
msgid "Non-symbol ~S may not be subject to a DECLARATION declaration."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lisp:1561
#, fuzzy, lisp-format
msgid "The arguments of a COMPILE declaration are ignored: ~S"
msgstr "~S ~S: Sólo la declaraciones ~S están permitidas: ~S"

#: compiler.lisp:1565
#, lisp-format
msgid "Unknown declaration ~S.~%The whole declaration will be ignored."
msgstr "Declaración desconocida ~S.~%La declaración completa será ignorada."

#: compiler.lisp:1905
#, fuzzy, lisp-format
msgid " in file ~S"
msgstr " en la línea ~D"

#: compiler.lisp:1907
#, lisp-format
msgid " in line ~D"
msgstr " en la línea ~D"

#: compiler.lisp:1908
#, lisp-format
msgid " in lines ~D..~D"
msgstr " en las líneas ~D..~D"

#
# Duda: He querido traducir la palabra `warning' por `aviso' que es como
# debería decirse en español, ¿no?. ¿Hay algún término adoptado en
# es@li.org, para esta palabra?.
#
# Sí, atención. sv
#
# Si, si, ya lo he hecho, ... En todas partes he puesto "WARNING" por
# "ATENCIÓN". No es exactamente lo mismo, pero me parece una sugerencia
# genial, de hecho me gusta muchísimo más que aquello de "AVISO:". De
# esta manera, parecía que te estaban hablando los "super-tacañones" :) - cll
#
# Sin embargo, Santiago, este caso es bastante peculiar. Verás, si dejo
# "ATENCIÓN" aquí, entonces, durante la compilación de un proyecto con
# varios ficheros en Lisp, podría salir, por ejemplo, un mensaje como el
# siguiente (tomado de un ejemplo real, que conste, ...):
#
# --------------
# ATENCIÓN en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
# Y yo pregunto, en este caso ¿no es mejor poner "ADVERTENCIA"? La
# verdad es que "ADVERTENCIA" me suena mucho mejor que "ATENCIÓN" y que
# "AVISO". En este caso, lo que se tendría es:
#
# --------------
# ADVERTENCIA en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
#
#: compiler.lisp:1932
#, fuzzy, lisp-format
msgid "WARNING~@[ in ~S~]~A :"
msgstr "ADVERTENCIA~@[ en la función ~S~]~A :~%"

#: compiler.lisp:1953
#, fuzzy, lisp-format
msgid "ERROR~@[ in ~S~]~A :"
msgstr "ERROR~@[ en la función ~S~]~A : ~%~?"

#: compiler.lisp:2097
#, lisp-format
msgid "Code contains dotted list ~S"
msgstr "El código contiene la lista punteada ~S"

# En ocasiones como esta hemos puesto a veces:
# "insuficiente número de argumentos" sv
#
# ¡Pues no me gusta nada!, todavía si dijeses "número insuficiente de
# argumentos". No se, ..., la verdad es que a mí me gusta mucho más "muy
# pocos argumentos" o, si quieres, "pocos argumentos" pero eso de la
# "insuficiencia", ... (me trae otros recuerdos). cll
#
#: compiler.lisp:2099
#, lisp-format
msgid "Form too short, too few arguments: ~S"
msgstr "Forma demasiado corta, muy pocos argumentos: ~S"

#: compiler.lisp:2102
#, lisp-format
msgid "Form too long, too many arguments: ~S"
msgstr "Forma demasiado larga, demasiados argumentos: ~S"

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#: compiler.lisp:2357
#, lisp-format
msgid "Not the name of a function: ~S"
msgstr "No es el nombre de una función: ~S"

#: compiler.lisp:2422 compiler.lisp:2485
#, fuzzy, lisp-format
msgid ""
"~S is neither declared nor bound,~@\n"
"                     it will be treated as if it were declared SPECIAL."
msgstr ""
"~S no está ni declarado ni ligado,~@\n"
"                        será tratado como si hubiese sido declarado SPECIAL."

#: compiler.lisp:2502
#, fuzzy, lisp-format
msgid ""
"The constant ~S may not be assigned to.~@\n"
"                                        The assignment will be ignored."
msgstr ""
"La constante ~S no puede asignarse. ~@\n"
"                                                  La asignación será ignorada."

#: compiler.lisp:2755
#, lisp-format
msgid "argument list to function ~S is dotted: ~S"
msgstr "el argumento de la función ~S es una lista punteada: ~S"

#: compiler.lisp:2760
#, fuzzy, lisp-format
msgid "~S was called with ~S~:[~; or more~] arguments, but it requires ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] argument~:p."
msgstr "~S fue invocado con ~S~:[~; o más~] argumentos, pero requiere ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumentos."

#: compiler.lisp:2770
#, lisp-format
msgid "keyword arguments to function ~S should occur pairwise: ~S"
msgstr "los argumentos clave de la función ~S deben aparecer por pares: ~S"

#
# Afortunadamente, la convención ~#[, para imprimir los términos de una
# lista (en inglés, como dice el estándar) sirve perfectamente para el
# español
#
#: compiler.lisp:2780
#, fuzzy, lisp-format
msgid ""
"keyword ~S is not allowed for function ~S.~\n"
"                             ~%The only allowed keyword~[s are~; is~:;s are~] ~{~S~#[~; and ~S~:;, ~]~}."
msgstr ""
"la palabra clave ~S no está permitida en la función ~S.~\n"
"                              ~%La~:[s~;~] única~:*~:[s~;~] palabra~:*~:[s~;~] clave permitida~:*~:[s son ~{~S~#[~; y ~S~:;, ~]~}~; es ~{~S~}~]."

#: compiler.lisp:2790
#, fuzzy, lisp-format
msgid "argument ~S to function ~S is not a symbol"
msgstr "el argumento ~S para la función ~S no es un argumento clave"

#: compiler.lisp:2812
#, lisp-format
msgid "Run time error expected: ~@?"
msgstr ""

#: compiler.lisp:2963
#, fuzzy, lisp-format
msgid "~S: ignored duplicate keyword ~S ~S"
msgstr "~S no acepta las palabras clave ~S de ~S"

#: compiler.lisp:2966
#, fuzzy, lisp-format
msgid "~S: ignored keyword ~S ~S"
msgstr "~S no acepta las palabras clave ~S de ~S"

#: compiler.lisp:3310
#, fuzzy, lisp-format
msgid "Function ~s is not defined"
msgstr "~: la función ~ no está definida"

#: compiler.lisp:3316
#, fuzzy, lisp-format
msgid "Function ~S is deprecated."
msgstr "~S: la función ~S no está definida"

#: compiler.lisp:3392
#, lisp-format
msgid "Function ~s~% was already defined~a~:[~% with the signature~%~a~% it is being re-defined with a new signature~%~a~;~2*~]"
msgstr ""

#: compiler.lisp:3459
#, lisp-format
msgid "Illegal syntax in LET/LET*: ~S"
msgstr "Sintaxis inválida en LET/LET*: ~S"

#: compiler.lisp:3570
#, fuzzy, lisp-format
msgid "Binding variable ~S can cause side effects despite IGNORE declaration since it is declared SPECIAL."
msgstr "Asociar la variable ~S puede causar otros efectos, a pesar de la declaración~%IGNORE puesto que está declarada como SPECIAL."

#: compiler.lisp:3573
#, fuzzy, lisp-format
msgid "variable ~S is used despite IGNORE declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lisp:3583
#, lisp-format
msgid "variable ~S is not used.~%Misspelled or missing IGNORE declaration?"
msgstr "La variable ~S no está siendo usada.~%¿Está mal escrita o es que falta la declaración IGNORE?"

#: compiler.lisp:3588
#, fuzzy, lisp-format
msgid "The variable ~S is assigned to, despite READ-ONLY declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lisp:3629 compiler.lisp:3744
#, lisp-format
msgid "Constant ~S cannot be bound."
msgstr "La constante ~S no puede ligarse."

#: compiler.lisp:4442
#, lisp-format
msgid "Misplaced declaration: ~S"
msgstr "Declaración situada incorrectamente: ~S"

#: compiler.lisp:4652
#, fuzzy, lisp-format
msgid "~S: assignment to the internal special variable ~S"
msgstr "~S: no es posible rastrear la forma especial ~S"

#: compiler.lisp:4660
#, lisp-format
msgid "Odd number of arguments to SETQ: ~S"
msgstr "Número impar de argumentos de SETQ: ~S"

#: compiler.lisp:4690 compiler.lisp:4719 compiler.lisp:4811
#, lisp-format
msgid "Cannot assign to non-symbol ~S."
msgstr "No se puede asignar a un \"no-símbolo\" ~S."

#: compiler.lisp:4699
#, lisp-format
msgid "Odd number of arguments to PSETQ: ~S"
msgstr "Número impar de argumentos de PSETQ: ~S"

#: compiler.lisp:4936
#, lisp-format
msgid "Only symbols may be used as variables, not ~S"
msgstr "Sólo pueden usarse los símbolos como variables, no ~S"

#: compiler.lisp:5026
#, lisp-format
msgid "Illegal syntax in COMPILER-LET: ~S"
msgstr "Sintaxis inválida en COMPILER-LET: ~S"

#: compiler.lisp:5031
#, lisp-format
msgid "Block name must be a symbol, not ~S"
msgstr "El nombre de un bloque debe ser un símbolo, no ~S"

#: compiler.lisp:5073
#, lisp-format
msgid "RETURN-FROM block ~S is impossible from here."
msgstr "No es posible hacer RETURN-FROM del bloque ~S desde aquí."

#: compiler.lisp:5131
#, lisp-format
msgid "Only numbers and symbols are valid tags, not ~S"
msgstr "Sólo son etiquetas de salto válidas los números y los símbolos, no ~S"

#: compiler.lisp:5203
#, lisp-format
msgid "Tag must be a symbol or a number, not ~S"
msgstr "Una etiqueta de salto debe ser un símbolo o un número, no ~S"

#: compiler.lisp:5206
#, lisp-format
msgid "GO to tag ~S is impossible from here."
msgstr "No es posible ir (GO) a la etiqueta de salto ~S desde aquí."

#: compiler.lisp:5279
#, lisp-format
msgid "~S is not a function. It is a locally defined macro."
msgstr "~S no es una función. Se trata de una macro definida localmente."

#: compiler.lisp:5294
#, lisp-format
msgid "Only symbols and lambda expressions are function names, not ~S"
msgstr "Sólo los símbolos y las expresiones lambda son nombres de funciones válidos, no ~S"

#: compiler.lisp:5350
#, lisp-format
msgid "Illegal function definition syntax in ~S: ~S"
msgstr "La sintaxis para la definición de la función en ~S es inválida: ~S"

#: compiler.lisp:5777
#, fuzzy, lisp-format
msgid "~S: Illegal syntax: ~S"
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: compiler.lisp:5793
#, fuzzy, lisp-format
msgid "~S: symbol ~S is declared SPECIAL and must not be declared a macro"
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S: el símbolo ~S no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: compiler.lisp:5817
#, fuzzy, lisp-format
msgid "~S situation must be ~S, ~S or ~S, but not ~S"
msgstr "~SS: el argumento debe ser ~SS, ~SS o ~SS, pero no ~SS"

#: compiler.lisp:5834
#, lisp-format
msgid "COND clause without test: ~S"
msgstr "Cláusula COND sin prueba condicional: ~S"

#: compiler.lisp:5856
#, lisp-format
msgid "CASE clause without objects: ~S"
msgstr "Cláusula CASE sin objetos: ~S"

#: compiler.lisp:5865
#, lisp-format
msgid "~S: the ~S clause must be the last one: ~S"
msgstr "~S: la clausula ~S debe ser la última: ~S"

#: compiler.lisp:5873
#, lisp-format
msgid "Duplicate ~S label ~S : ~S"
msgstr "~S : La etiqueta ~S se repite: ~S"

#: compiler.lisp:6142
#, lisp-format
msgid "Too many arguments to ~S"
msgstr "Demasiados argumentos para ~S"

#: compiler.lisp:6153
#, lisp-format
msgid "Too few arguments to ~S"
msgstr "Muy pocos argumentos para ~S"

#: compiler.lisp:6592
#, lisp-format
msgid "Arithmetic operand ~s must evaluate to a number, not ~s"
msgstr ""

#: compiler.lisp:7122
#, fuzzy, lisp-format
msgid "The ~S destination is invalid (not NIL or T or a stream or a string with fill-pointer): ~S"
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

#: compiler.lisp:7146
#, fuzzy, lisp-format
msgid "First argument to ~S should be sequence, not ~S"
msgstr "~: el argumento debe ser una cadena de caracteres, no ~"

#: compiler.lisp:7149
#, lisp-format
msgid "~S is destructive, should not be called on a constant ~S"
msgstr ""

#: compiler.lisp:10797
#, fuzzy, lisp-format
msgid "~S cannot be compiled"
msgstr "~S no puede ser editado."

#: compiler.lisp:10847
#, lisp-format
msgid "~S: redefining ~S; it was traced!"
msgstr "~S: redefiniendo ~S; ¡estaba siendo rastreada!"

#: compiler.lisp:10852
#, lisp-format
msgid "~S is already compiled."
msgstr "~S ya está compilada."

#: compiler.lisp:10867 disassem.lisp:9
#, lisp-format
msgid "Undefined function ~S"
msgstr "La función ~S no está definida"

# Sugerencia: No es blabla ni bla bla. sv
# El ni se ponía la segunda pero no la primera vez, ¿no?
#
# ¡No, hombre, no! Creo que estas equivocado, ..., en el diccionario
# Larousse de Inglés-Español pone:
#
# "nor conj. Ni: he is neither big nor small, no es ni grande ni
# pequeño; neither you nor I, ni tú ni yo || ..."
#
# O sea, que es " ... ni ... ni ..." cll
#
#: compiler.lisp:10882
#, lisp-format
msgid "Not a lambda expression nor a function: ~S"
msgstr "Ni es una expresión lambda ni es una función: ~S"

#: compiler.lisp:10940
msgid "A function compiled with errors cannot be executed."
msgstr ""

#: compiler.lisp:11069
#, lisp-format
msgid "[~s was defined~a]"
msgstr ""

#: compiler.lisp:11076
#, lisp-format
msgid "There were errors in the following functions:~%~{~<~%~:; ~S~>~^~}"
msgstr "Ha habido errores en las siguientes funciones:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:11082
#, lisp-format
msgid "The following functions were used but not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "Las siguientes funciones han sido utilizadas pero no definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:11090
#, lisp-format
msgid "The following special variables were not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "Las siguientes variables especiales no han sido definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:11093
#, lisp-format
msgid "The following special variables were defined too late:~%~{~<~%~:; ~S~>~^~}"
msgstr "Las siguientes variables especiales fueron definidas demasiado tarde:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:11096
#, fuzzy, lisp-format
msgid "The following functions were used but are deprecated:~%~:{~<~%~:; ~S - ~@?~>~^~}"
msgstr "Las siguientes funciones han sido utilizadas pero no aprobadas:~%~{~<~%~:; ~S~>~^~}"

#
# Duda: ¡atención a la utilización de la directiva ~P!
#
# La siguiente traducción funcionará si, para el caso del español (como
# para el alemán), se pasa el parámetro (eql *error-count* 1), en
# segundo lugar.
#
# Ya no hace falta. Tal y como está hecho no es necesario pasar ningún
# parámetro extra. Así funciona correctamente.
#
# Aquí dudo porque atención no es tan "pluralizable" como aviso. sv
#
# Claro, de hecho, a mí también me pasa lo mismo. He preferido cambiar
# la traducción de "aviso" por "advertencia", en este mensaje y en aquél
# en el que se sacan los mensajes del compilador. ¿No os suena muchísimo
# mejor esta segunda alternativa? - cll
#
#: compiler.lisp:11101
#, lisp-format
msgid "~D error~:P, ~D warning~:P"
msgstr "~D error~:*~[es~;~:;es~], ~D advertencia~:P"

#: compiler.lisp:11266
#, fuzzy, lisp-format
msgid "Listing of compilation of file ~A~%on ~A by ~A, version ~A"
msgstr "Listado de la compilación del fichero ~A~%el ~@? por ~A, versión ~A"

#: compiler.lisp:11298
#, fuzzy, lisp-format
msgid ";; Compiling file ~A ..."
msgstr "Compilando el fichero ~A ..."

#: compiler.lisp:11333
#, fuzzy, lisp-format
msgid ";; Wrote file ~A"
msgstr " de la fuente ~S"

#: compiler.lisp:11341
#, fuzzy, lisp-format
msgid ";; Deleted file ~A"
msgstr " de la fuente ~S"

#: compiler.lisp:11388
#, fuzzy, lisp-format
msgid "Disassembly of function ~S"
msgstr "Desensamblado de la función "

#: compiler.lisp:11398
#, fuzzy, lisp-format
msgid "~S required argument~:P"
msgstr "~S argumentos obligatorios"

#: compiler.lisp:11400
#, fuzzy, lisp-format
msgid "~S optional argument~:P"
msgstr "~S argumentos opcionales"

#: compiler.lisp:11403
msgid "Rest parameter"
msgstr "Parámetro resto"

#: compiler.lisp:11404
msgid "No rest parameter"
msgstr "Sin parámetro de resto"

#
# aAtención a la utilización de la directiva ~P!!
#
# Bueno, en este caso es perfecta :) No hay ningún problema de ningún
# tipo
#
#: compiler.lisp:11408
#, fuzzy, lisp-format
msgid "~S keyword parameter~:P: "
msgstr "parámetro~P clave: "

#: compiler.lisp:11415
msgid "Other keywords are allowed."
msgstr "Se permiten otras palabras clave."

#: compiler.lisp:11418
msgid "No keyword parameters"
msgstr "Sin parámetros clave"

#: compiler.lisp:11434
#, lisp-format
msgid "reads special variable~P: ~{~S~^ ~}"
msgstr ""

#: compiler.lisp:11438
#, lisp-format
msgid "writes special variable~P: ~{~S~^ ~}"
msgstr ""

#: compiler.lisp:11441
#, lisp-format
msgid "~S byte-code instruction~:P:"
msgstr ""

#: defs2.lisp:61
#, fuzzy, lisp-format
msgid "The object to be destructured should be a list with at most ~S elements, not the circular list ~S"
msgstr "Los objetos a desmontar deben ser una lista ~:[con al menos ~*~S~;de ~:[~S a ~S~;~S~]~] elementos, y no ~4@*~S."

#: defs2.lisp:64
#, lisp-format
msgid "The object to be destructured should be a list with ~:[at least ~*~S~;~:[from ~S to ~S~;~S~]~] elements, not ~4@*~S."
msgstr "Los objetos a desmontar deben ser una lista ~:[con al menos ~*~S~;de ~:[~S a ~S~;~S~]~] elementos, y no ~4@*~S."

#: defs2.lisp:141
#, lisp-format
msgid "~S: macro name should be a symbol, not ~S"
msgstr "~S: el nombre de una macro debe ser un símbolo, no ~S"

#: defs2.lisp:255 defs2.lisp:278
#, lisp-format
msgid "~S: element types of ~S and ~S are ambiguous. Please use ~S or ~S."
msgstr ""

#: loop.lisp:51
#, lisp-format
msgid "~S: syntax error after ~A in ~S"
msgstr "~S: error de sintaxis después de ~A en ~S"

#: loop.lisp:306
#, lisp-format
msgid "~S: variable ~S is used in incompatible clauses~{ ~A ~S~} and~{ ~A ~S~}"
msgstr ""

#: loop.lisp:348
#, fuzzy, lisp-format
msgid "~S: missing variable."
msgstr "~S: variable ausente"

#: loop.lisp:357
#, lisp-format
msgid "~S: After ~S, ~S is interpreted as a type specification"
msgstr "~S: Después de ~S, ~S es interpretado como una especificación de tipo"

#: loop.lisp:378
#, lisp-format
msgid "~S: missing forms after ~A: permitted by CLtL2, forbidden by ANSI CL."
msgstr ""

#: loop.lisp:551
#, fuzzy, lisp-format
msgid "~S: duplicate iteration variable ~S"
msgstr "~S ~S: el nombre de la variable ~S está duplicado"

#: loop.lisp:613
#, lisp-format
msgid "~S: loop keyword immediately after ~A: permitted by CLtL2, forbidden by ANSI CL."
msgstr ""

#: loop.lisp:620
#, lisp-format
msgid "~S: ~A clauses should occur before the loop's main body"
msgstr "~S: las claúsulas ~A deben aparecer antes del cuerpo principal del bucle"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lisp:773
#, lisp-format
msgid "~S: After ~S a plural loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un plural, y no ~A"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lisp:778
#, lisp-format
msgid "~S: After ~S a singular loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un singular, y no ~A"

#: loop.lisp:934
#, lisp-format
msgid "~S: questionable iteration direction after ~A"
msgstr "~S: dirección incierta de la iteración después de ~A"

#: loop.lisp:945
#, lisp-format
msgid "~S: specifying ~A requires FROM or DOWNFROM"
msgstr "~S: especificar ~A requiere FROM o DOWNFROM"

#: loop.lisp:1007
#, lisp-format
msgid "~S: illegal syntax near ~S in ~S"
msgstr "~S: sintaxis inválida cerca de ~S en ~S"

#: loop.lisp:1013
#, fuzzy, lisp-format
msgid "~S: ambiguous result:~:{~%~S from ~@{~{~A ~S~}~^, ~}~}"
msgstr "~S: el resultado del bucle ~S es ambiguo"

#: loop.lisp:1091
#, fuzzy, lisp-format
msgid "~S: accumulation variable ~S is already bound"
msgstr "~S: demasiadas variables ~S en la clausula ~S"

#: loop.lisp:1162
#, lisp-format
msgid "~S is possible only from within ~S"
msgstr "~S sólo es posible desde ~S"

#: loop.lisp:1165
#, lisp-format
msgid "Use of ~S in FINALLY clauses is deprecated because it can lead to infinite loops."
msgstr "La utilización de ~S en las cláusulas FINALLY está desaconsejada puesto que puede provocar bucles infinitos"

#: loop.lisp:1168
#, lisp-format
msgid "~S is not possible here"
msgstr "~S es imposible aquí"

#: clos-specializer2.lisp:15 clos-methcomb3.lisp:33
#, fuzzy, lisp-format
msgid "~S: It is not allowed to reinitialize ~S"
msgstr "~S: el argumento no es una variable extranjera: ~S"

#: clos-class5.lisp:663
#, lisp-format
msgid "~S cannot change a funcallable object to a non-funcallable object: ~S"
msgstr ""

#: clos-class5.lisp:671
#, lisp-format
msgid "~S cannot change a non-funcallable object to a funcallable object: ~S"
msgstr ""

#: clos-class5.lisp:785
#, lisp-format
msgid "~S: The MOP does not allow changing the class of metaobject ~S"
msgstr ""

#: clos-class6.lisp:51
#, fuzzy, lisp-format
msgid "The class ~S has not yet been initialized."
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: clos-class6.lisp:57
#, fuzzy, lisp-format
msgid "The class ~S has not yet been finalized."
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: clos-class6.lisp:82
#, lisp-format
msgid "~S: The name of a class must be a symbol, not ~S"
msgstr "~S: El nombre de una clase debe ser un símbolo, no ~S"

#: clos-class6.lisp:86
#, lisp-format
msgid "~S: The name of the built-in class ~S cannot be modified"
msgstr "~S: No es posible modificar el nombre de la clase predefinida ~S"

#: clos-class6.lisp:112
#, fuzzy, lisp-format
msgid "~S being called on ~S, but class ~S is not yet defined."
msgstr "~S: No es posible modificar el nombre de la clase predefinida ~S"

#: clos-class6.lisp:388
#, lisp-format
msgid "~S: ~S is an abstract class and therefore does not have a direct instance"
msgstr ""

#: clos-slotdef2.lisp:44 clos-method3.lisp:46
#, fuzzy, lisp-format
msgid "~S: The MOP does not allow reinitializing ~S"
msgstr "~S: ~S no nombra una clase"

#: clos-slots1.lisp:143 clos-slots1.lisp:186
#, lisp-format
msgid "~S: not a list of slots: ~S"
msgstr "~S: no es una lista de ranuras: ~S"

#: clos-slots1.lisp:152
#, lisp-format
msgid "~S: invalid slot and variable specification ~S"
msgstr "~S: especificación inválida de ranura y variable: ~S"

#: clos-slots1.lisp:159 clos-slots1.lisp:199
#, lisp-format
msgid "~S: variable ~S should be a symbol"
msgstr "~S: la variable ~S debe ser un símbolo"

#: clos-slots1.lisp:165
#, lisp-format
msgid "~S: slot name ~S should be a symbol"
msgstr "~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos-slots1.lisp:193
#, lisp-format
msgid "~S: invalid slot and accessor specification ~S"
msgstr "~S: especificación inválida de ranura y función de acceso: ~S"

#: clos-slots1.lisp:205
#, lisp-format
msgid "~S: accessor name ~S should be a symbol"
msgstr "~S: el nombre de la función de acceso ~S debe ser un símbolo"

#: clos-slots2.lisp:15
#, lisp-format
msgid "~S: The class ~S has no slot named ~S"
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: clos-slots2.lisp:26
#, fuzzy, lisp-format
msgid "~S: The slot ~S of ~S has no value"
msgstr "~S: Una ranura de ~S no tiene valor"

#: clos-method1.lisp:130 clos-method1.lisp:158
#, fuzzy, lisp-format
msgid "(~S ~S): The ~S argument should be a proper list, not ~S"
msgstr "~S: el argumento debe ser una cadena de caracteres, no ~S"

#: clos-method1.lisp:133
#, lisp-format
msgid "(~S ~S): The qualifiers list should consist of non-NIL atoms, not ~S"
msgstr ""

#: clos-method1.lisp:137 clos-method1.lisp:155 clos-method1.lisp:173 clos-method1.lisp:265
#, fuzzy, lisp-format
msgid "(~S ~S): Missing ~S argument."
msgstr "~S: el argumento de ~S es inválido: ~S"

#: clos-method1.lisp:142
#, fuzzy, lisp-format
msgid "(~S ~S): Invalid ~S argument: ~A"
msgstr "~S: el argumento ~S es inválido"

#: clos-method1.lisp:150
#, lisp-format
msgid "(~S ~S): Lambda-list ~S and signature ~S are inconsistent."
msgstr ""

#: clos-method1.lisp:163
#, lisp-format
msgid "(~S ~S): The element ~S of the ~S argument is not yet defined."
msgstr ""

#: clos-method1.lisp:165
#, fuzzy, lisp-format
msgid "(~S ~S): The element ~S of the ~S argument is not of type ~S."
msgstr "~S: el INITIAL-ELEMENT ~S no es del tipo ~S"

#: clos-method1.lisp:168
#, lisp-format
msgid "(~S ~S): The lambda list ~S has ~S required arguments, but the specializers list ~S has length ~S."
msgstr ""

#: clos-method1.lisp:177 clos-method1.lisp:181
#, fuzzy, lisp-format
msgid "(~S ~S): The ~S argument should be a function, not ~S"
msgstr "~S : El argumento debe ser del tipo FIXNUM >=0 y no ~S"

#: clos-method1.lisp:184
#, fuzzy, lisp-format
msgid "(~S ~S): The ~S argument should be a NIL or T, not ~S"
msgstr "~S: el argumento debe ser una cadena de caracteres, no ~S"

#: clos-method1.lisp:194
#, fuzzy, lisp-format
msgid "(~S ~S): The ~S argument should be a string or NIL, not ~S"
msgstr "~S: el argumento del código debe ser un entero y no ~S"

#: clos-method1.lisp:268
#, fuzzy, lisp-format
msgid "(~S ~S): Argument ~S is not of type ~S."
msgstr "~S: el argumento ~S debe ser un flujo del tipo ~S"

#: clos-method2.lisp:35
#, fuzzy, lisp-format
msgid "Invalid specialized parameter in method lambda list ~S: ~S"
msgstr "La lista lambda ~S necesita un parámetro &REST"

#: clos-method2.lisp:83
#, lisp-format
msgid "~S ~S: missing lambda list"
msgstr "~S ~S: falta la lista lambda"

#: clos-method2.lisp:113
#, fuzzy, lisp-format
msgid "~S ~S: Invalid specializer ~S in lambda list ~S"
msgstr "~S ~S: parte de la lista lambda es inválida: ~S"

#: clos-method3.lisp:81
#, lisp-format
msgid "Invalid ~S result for ~S: ~:S: ~A"
msgstr ""

#: clos-methcomb1.lisp:21
#, fuzzy, lisp-format
msgid "~S: The method combination ~S is not defined."
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos-methcomb2.lisp:81
#, lisp-format
msgid "The method function of ~S cannot be called before the method has been added to a generic function."
msgstr ""

#: clos-methcomb2.lisp:123
#, lisp-format
msgid "For function ~S applied to argument list ~S:~%While computing the effective method through ~S:~%Invalid method: ~S~%~?"
msgstr ""

#: clos-methcomb2.lisp:137
#, lisp-format
msgid "For function ~S applied to argument list ~S:~%While computing the effective method through ~S:~%Impossible to combine the methods:~%~?"
msgstr ""

#: clos-methcomb2.lisp:144 clos-methcomb2.lisp:158
#, fuzzy, lisp-format
msgid "The value of ~S is ~S, should be ~S or ~S."
msgstr "~S: el valor de ~S debe ser un RANDOM-STATE, no ~S"

#: clos-methcomb2.lisp:151
#, lisp-format
msgid "Method ~S has the same specializers and different qualifiers than other methods in method group ~S, and is actually used in the effective method."
msgstr ""

#: clos-methcomb2.lisp:168
#, fuzzy, lisp-format
msgid "~S ~S: Invalid method-combination options ~S for ~S: ~A"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos-methcomb2.lisp:207 clos-methcomb2.lisp:224
#, fuzzy, lisp-format
msgid "~S ~S: Invalid syntax for ~S option: ~S"
msgstr "~S ~S: la sintaxis de la opción ~S es inválida: ~S"

#: clos-methcomb2.lisp:296
#, lisp-format
msgid "~S is possible only from within the context of an effective method function. See ~S."
msgstr ""

#: clos-methcomb2.lisp:305
#, lisp-format
msgid "~S is possible only at particular places from within the context of an effective method function. See ~S."
msgstr ""

#: clos-methcomb2.lisp:312
#, fuzzy, lisp-format
msgid "~S cannot be used here: ~S"
msgstr "~S no puede ser editado."

#: clos-methcomb2.lisp:324
#, lisp-format
msgid "~S: The first argument is neither a method nor a (MAKE-METHOD ...) form: ~S"
msgstr ""

#: clos-methcomb2.lisp:331
#, fuzzy, lisp-format
msgid "~S: The second argument is not a list: ~S"
msgstr "~S: el argumento :OUT no es un puntero: ~S"

#: clos-methcomb2.lisp:338
#, lisp-format
msgid "~S: The second argument is not a list of methods or (MAKE-METHOD ...) forms: ~S"
msgstr ""

#: clos-methcomb2.lisp:485
#, fuzzy, lisp-format
msgid "In ~S ~S lambda list: ~A"
msgstr "Lista lambda inválida en DEFINE-MODIFY-MACRO: ~S"

#: clos-methcomb2.lisp:651
#, fuzzy, lisp-format
msgid "~S ~S: The ~S method combination permits no options: ~S"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos-methcomb2.lisp:728
#, fuzzy, lisp-format
msgid "~S method combination, used by ~S, allows no method qualifiers except ~S: ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos-methcomb2.lisp:731
#, fuzzy, lisp-format
msgid "~S method combination, used by ~S, does not allow method qualifiers: ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos-methcomb2.lisp:735
#, fuzzy, lisp-format
msgid "~S method combination, used by ~S, does not allow more than one method qualifier on a method: ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos-methcomb2.lisp:799
#, fuzzy, lisp-format
msgid "~S method combination, used by ~S, does not allow less than one method qualifier on a method: ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos-methcomb2.lisp:870
#, fuzzy, lisp-format
msgid "~S ~S: invalid method group specifier ~S: ~A"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos-methcomb2.lisp:881
#, fuzzy
msgid "Not a list of length at least 2"
msgstr "una lista de longitud ~S."

#: clos-methcomb2.lisp:890
#, fuzzy, lisp-format
msgid "Not a variable name: ~S"
msgstr "~S ~S: el nombre de la variable ~S está duplicado"

#: clos-methcomb2.lisp:901 clos-methcomb2.lisp:911
#, lisp-format
msgid "In method group ~S: Cannot specify both qualifier patterns and a predicate."
msgstr ""

#: clos-methcomb2.lisp:909
#, lisp-format
msgid "In method group ~S: Cannot specify more than one predicate."
msgstr ""

#: clos-methcomb2.lisp:914
#, lisp-format
msgid "In method group ~S: Neither a qualifier pattern nor a predicate: ~S"
msgstr ""

#: clos-methcomb2.lisp:919
#, fuzzy, lisp-format
msgid "In method group ~S: options must come in pairs"
msgstr "~S ~S, opción ~S: los argumentos no aparecen en pares"

#: clos-methcomb2.lisp:925 clos-methcomb2.lisp:929 clos-methcomb2.lisp:933
#, fuzzy, lisp-format
msgid "In method group ~S: option ~S may only be given once"
msgstr "~S ~S, la opción ~S sólo se puede indicar una vez"

#: clos-methcomb2.lisp:935
#, fuzzy, lisp-format
msgid "In method group ~S: ~S is not a string"
msgstr "~S ~S, opción ~S: ~S no es una cadena de caracteres"

#: clos-methcomb2.lisp:938
#, fuzzy, lisp-format
msgid "In method group ~S: Invalid option ~S"
msgstr "~S ~S: la opción ~S es inválida"

#: clos-methcomb2.lisp:941
#, lisp-format
msgid "In method group ~S: Missing pattern or predicate."
msgstr ""

#: clos-methcomb2.lisp:1104
#, fuzzy, lisp-format
msgid "~S: method combination name ~S should be a symbol"
msgstr "~S: el nombre de la macro ~S debe ser un símbolo"

#: clos-methcomb2.lisp:1109
#, fuzzy
msgid "method combination"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos-methcomb2.lisp:1120 clos-methcomb2.lisp:1131
#, fuzzy, lisp-format
msgid "~S ~S: options must come in pairs"
msgstr "~S ~S, opción ~S: los argumentos no aparecen en pares"

#: clos-methcomb2.lisp:1147
#, fuzzy, lisp-format
msgid "~S ~S: ~S is not a string"
msgstr "~S ~S: ~S no es una opción de ranura."

#: clos-methcomb2.lisp:1176
#, fuzzy, lisp-format
msgid "~S ~S: ~S is not a valid short-form option"
msgstr "~S ~S: ~S no es una opción de ranura."

#: clos-methcomb2.lisp:1198
#, fuzzy, lisp-format
msgid "~S ~S: invalid syntax for long form: ~S"
msgstr "~S ~S: la sintaxis de la opción ~S es inválida: ~S"

#: clos-methcomb2.lisp:1209
#, fuzzy, lisp-format
msgid "~S ~S: invalid lambda-list: ~A"
msgstr "~S ~S: parte de la lista lambda es inválida: ~S"

#: clos-methcomb2.lisp:1278
#, fuzzy, lisp-format
msgid "~S ~S: invalid syntax, neither short form nor long form syntax: ~S"
msgstr "~S ~S: la sintaxis de la opción ~S es inválida: ~S"

#: clos-genfun2a.lisp:154 clos-genfun2b.lisp:58
#, lisp-format
msgid "~S: ~S has ~S required argument~:P, but only ~S arguments were passed to ~S: ~S"
msgstr ""

#
# "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: clos-genfun2a.lisp:170
#, fuzzy, lisp-format
msgid "~S: argument should be a proper list of classes, not ~S"
msgstr "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S"

#: clos-genfun2a.lisp:211
#, lisp-format
msgid "~S: ~S has ~S required argument~:P, but ~S classes were passed to ~S: ~S"
msgstr ""

#
# "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: clos-genfun2a.lisp:229
#, fuzzy, lisp-format
msgid "~S: argument should be a proper list of specifiers, not ~S"
msgstr "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S"

#: clos-genfun2a.lisp:324 clos-genfun2b.lisp:88
#, fuzzy, lisp-format
msgid "~S: ~S has ~S required argument~:P"
msgstr "~S argumentos obligatorios"

#: clos-genfun2a.lisp:335
#, fuzzy, lisp-format
msgid "~S: Invalid method specializer ~S on ~S in ~S"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos-genfun2b.lisp:46
#, lisp-format
msgid "Wrong ~S result for generic function ~S: not a proper list: ~S"
msgstr ""

#: clos-genfun2b.lisp:50
#, lisp-format
msgid "Wrong ~S result for generic function ~S: list element is not a method: ~S"
msgstr ""

#: clos-genfun2b.lisp:508
#, fuzzy, lisp-format
msgid "~S is not one of the required parameters: ~S"
msgstr "~S ~S: ~S no es uno de los parámetros obligatorios: ~S"

#: clos-genfun2b.lisp:518
#, fuzzy, lisp-format
msgid "Some variable occurs twice in ~S"
msgstr "~S ~S: alguna variable ha aparecido dos veces en ~S"

#: clos-genfun2b.lisp:523
#, fuzzy, lisp-format
msgid "The variables ~S are missing in ~S"
msgstr "La variable extranjera ~S ya existe"

#: clos-genfun2b.lisp:540
#, fuzzy, lisp-format
msgid "Invalid generic function lambda-list: ~A"
msgstr "~S ~S: No están permitidas las inicializaciones en la lista lambda de una función genérica: ~S"

#: clos-genfun2b.lisp:549 clos-genfun2b.lisp:565
#, fuzzy, lisp-format
msgid "The ~S argument should be a proper list, not ~S"
msgstr "~S: el argumento debe ser una cadena de caracteres, no ~S"

#: clos-genfun2b.lisp:556
#, fuzzy, lisp-format
msgid "Incorrect ~S argument: ~A"
msgstr "~S: El argumento ~S es inválido"

#: clos-genfun2b.lisp:569
#, fuzzy, lisp-format
msgid "In the ~S argument, only ~S declarations are permitted, not ~S"
msgstr "~S ~S: Sólo la declaraciones ~S están permitidas: ~S"

#: clos-genfun2b.lisp:578
#, fuzzy, lisp-format
msgid "~S has ~D, but ~S has ~D required parameter~:P"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros obligatorios"

#: clos-genfun2b.lisp:582
#, fuzzy, lisp-format
msgid "~S has ~D, but ~S has ~D optional parameter~:P"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros opcionales"

#: clos-genfun2b.lisp:586 clos-genfun2b.lisp:590
#, fuzzy, lisp-format
msgid "~S accepts &REST or &KEY, but ~S does not."
msgstr "~S tiene parámetros &REST o &KEY, pero ~S no."

#: clos-genfun2b.lisp:599
#, fuzzy, lisp-format
msgid "~S does not accept the keywords ~S of ~S"
msgstr "~S no acepta las palabras clave ~S de ~S"

#: clos-genfun2b.lisp:609
#, fuzzy, lisp-format
msgid "~S method combination, used by ~S, does not allow the method qualifiers ~:S: ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos-genfun2b.lisp:630
#, lisp-format
msgid "(~S ~S) for generic function ~S: ~S argument specified without a ~S argument."
msgstr ""

#: clos-genfun2b.lisp:641 clos-genfun2b.lisp:707
#, fuzzy, lisp-format
msgid "(~S ~S) for generic function ~S: ~A"
msgstr "~S no es una función genérica"

#: clos-genfun2b.lisp:659
#, fuzzy, lisp-format
msgid "(~S ~S) for generic function ~S: The ~S argument should be a class, not ~S"
msgstr "~S: el argumento del código debe ser un entero y no ~S"

#: clos-genfun2b.lisp:664
#, fuzzy, lisp-format
msgid "(~S ~S) for generic function ~S: The ~S argument should be a subclass of ~S, not ~S"
msgstr "~SS: el argumento debe ser ~SS, ~SS o ~SS, pero no ~SS"

#: clos-genfun2b.lisp:681
#, fuzzy, lisp-format
msgid "(~S ~S) for generic function ~S: The ~S argument should be a ~S object, not ~S"
msgstr "~S: el argumento debe ser una cadena de caracteres, no ~S"

#: clos-genfun2b.lisp:692
#, fuzzy, lisp-format
msgid "(~S ~S) for generic function ~S: The ~S argument should be a string or NIL, not ~S"
msgstr "~: el argumento de la fuente debe ser un número y no ~"

#: clos-genfun2b.lisp:700
#, lisp-format
msgid "(~S ~S) for generic function ~S: The ~S and ~S arguments cannot be specified together."
msgstr ""

#: clos-genfun2b.lisp:822
#, lisp-format
msgid "Replacing method ~S in ~S"
msgstr "Reemplazando el método ~S de ~S"

#: clos-genfun2b.lisp:829
#, lisp-format
msgid "Wrong ~S behaviour: ~S has not been removed from ~S"
msgstr ""

#: clos-genfun2b.lisp:875
#, lisp-format
msgid "Removing method ~S in ~S"
msgstr "Borrando el método ~S de ~S"

#: clos-genfun2b.lisp:914
#, fuzzy, lisp-format
msgid "~S: the specializers argument is not a list: ~S"
msgstr "~S: el argumento :OUT no es un puntero: ~S"

#: clos-genfun2b.lisp:923
#, fuzzy, lisp-format
msgid "~S: the specializers argument has length ~D, but ~S has ~D required parameter~:P"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros obligatorios"

#: clos-genfun2b.lisp:943
#, fuzzy, lisp-format
msgid "~S has no method with qualifiers ~:S and specializers ~:S"
msgstr "~S no tiene ningún método con cualificadores ~:S y especializadores ~S"

#: clos-genfun2b.lisp:1217
#, lisp-format
msgid "The generic function ~S is being modified, but has already been called."
msgstr "La función genérica ~S está siendo modificada, pero ya ha sido invocada."

#: clos-genfun2b.lisp:1244
#, lisp-format
msgid "Wrong ~S result for generic-function ~S: not a function: ~S"
msgstr ""

#: clos-genfun3.lisp:35
#, lisp-format
msgid "~S in ~S: bug in determination of effective methods"
msgstr ""

#: clos-genfun3.lisp:42
#, lisp-format
msgid "~S in ~S: the new arguments ~S have a different effective method than the old arguments ~S"
msgstr "~S en ~S: los argumentos nuevos ~S tienen un método en vigor diferente que los argumentos antiguos ~S"

#: clos-genfun3.lisp:60 clos-genfun3.lisp:431
#, fuzzy, lisp-format
msgid "~S ~S: invalid ~S option ~S"
msgstr "~S ~S: la opción ~S es inválida"

#: clos-genfun3.lisp:106 clos-genfun3.lisp:120
#, fuzzy, lisp-format
msgid "~S for generic-function ~S: ~S ~S is neither a class or a symbol"
msgstr "~S: el argumento del código debe ser un entero y no ~S"

#: clos-genfun3.lisp:110
#, fuzzy, lisp-format
msgid "~S for generic-function ~S: ~S ~S is not a subclass of ~S"
msgstr "~S: el argumento del código debe ser un entero y no ~S"

#: clos-genfun3.lisp:186 clos-genfun3.lisp:236
#, fuzzy, lisp-format
msgid "~S: ~S does not name a generic function"
msgstr "~S no es una función genérica"

#: clos-genfun3.lisp:195
#, fuzzy, lisp-format
msgid "Wrong ~S result for ~S: not a generic-function: ~S"
msgstr "~S no es una función genérica"

#: clos-genfun3.lisp:349 clos-genfun3.lisp:371
#, lisp-format
msgid "~S ~S: ~S may only be specified once."
msgstr "~S ~S: ~S sólo puede especificarse una vez."

#: clos-genfun3.lisp:357
#, lisp-format
msgid "~S ~S: A string must be specified after ~S : ~S"
msgstr "~S ~S: Debe especificarse una cadena de caracteres después de ~S: ~S"

#: clos-genfun3.lisp:363
#, fuzzy, lisp-format
msgid "~S ~S: Only one ~S string is allowed."
msgstr "~S ~S: Sólo se permite una cadena de caracteres ~S"

#: clos-genfun3.lisp:383
#, fuzzy, lisp-format
msgid "~S ~S: A method combination type name must be specified after ~S : ~S"
msgstr "~S ~S: Debe especificarse una cadena de caracteres después de ~S: ~S"

#: clos-genfun3.lisp:391
#, fuzzy, lisp-format
msgid "~S ~S: Invalid method combination specification: ~S"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos-genfun3.lisp:399 clos-genfun3.lisp:413
#, fuzzy, lisp-format
msgid "~S ~S: A class name must be specified after ~S : ~S"
msgstr "~S ~S: Debe especificarse una cadena de caracteres después de ~S: ~S"

#: clos-genfun3.lisp:405 clos-genfun3.lisp:419 clos-genfun3.lisp:440
#, fuzzy, lisp-format
msgid "~S ~S: Only one ~S option is allowed."
msgstr "~S ~S: Sólo se permite una cadena de caracteres ~S"

#: clos-genfun3.lisp:516
#, fuzzy, lisp-format
msgid "~S ~S: invalid generic function lambda-list: ~A"
msgstr "~S ~S: No están permitidas las inicializaciones en la lista lambda de una función genérica: ~S"

#: clos-genfun3.lisp:639
#, lisp-format
msgid "~S: ~S is not a generic function specification"
msgstr "~S: ~S no es una especificación de función genérica"

#: clos-genfun4.lisp:101 clos-genfun4.lisp:105
#, lisp-format
msgid "~S: When calling ~S with arguments ~S, no method is applicable."
msgstr "~S: No se puede aplicar ningún método al invocar ~S con los argumentos ~S."

#: clos-genfun4.lisp:122 clos-genfun4.lisp:126
#, fuzzy, lisp-format
msgid "~S: When calling ~S with arguments ~S, no method of group ~S (from ~S) is applicable."
msgstr "~S: No se puede aplicar ningún método al invocar ~S con los argumentos ~S."

#: clos-genfun4.lisp:146 clos-genfun4.lisp:150
#, lisp-format
msgid "~S: When calling ~S with arguments ~S, no primary method is applicable."
msgstr "~S: No se puede aplicar ningún método primario al invocar ~S con los argumentos ~S"

# Ojo con el ignorar. sv
#
# No, ya te he puesto antes las acepciones de esta palabra y esta vez,
# viene al caso, ... cll
#
# O sea, que estás 'ignorando ' la sugerencia de sv, ;-) - lsg
#
# Muy bueno, muy bueno, ... :) Santiago, por aquí hay mucho cachondeo :) - cll
#
#
#: clos-genfun4.lisp:159
#, fuzzy, lisp-format
msgid "ignore ~S"
msgstr "Ignorar."

#: clos-genfun4.lisp:165
#, lisp-format
msgid "~S: When calling ~S with arguments ~S, there is no next method after ~S, and ~S was called."
msgstr "~S: Mientras se invoca ~S con los argumentos ~S, no hay ningún método después de ~S, y ~S fue llamado."

#: clos-genfun4.lisp:171
#, fuzzy, lisp-format
msgid "~S: ~S is invalid within ~{~S~^ ~} methods"
msgstr "~S ~S: ~S es inválido dentro de los métodos ~S"

#: clos-genfun4.lisp:174
#, fuzzy, lisp-format
msgid "~S: ~S is invalid within primary methods"
msgstr "~S ~S: ~S es inválido dentro de los métodos ~S"

#: clos-genfun4.lisp:248
#, lisp-format
msgid "~S: Overriding a standardized method is not allowed. You need to call ~S."
msgstr ""

#: clos-genfun4.lisp:253
#, lisp-format
msgid "~S: Extending a standardized method is only allowed if it returns the same values as the next method.~%Original value: ~{~S~^, ~}~%Value returned by the extending method: ~{~S~^, ~}"
msgstr ""

#: clos-genfun4.lisp:254
#, lisp-format
msgid "~S: Extending a standardized method is only allowed if it returns the same values as the next method.~%Original values: ~{~S~^, ~}~%Values returned by the extending method: ~{~S~^, ~}"
msgstr ""

#: clos-genfun4.lisp:349
#, fuzzy, lisp-format
msgid "The generic function ~S has not yet been initialized."
msgstr "La función genérica ~S está siendo modificada, pero ya ha sido invocada."

#: clos-genfun4.lisp:364
#, fuzzy, lisp-format
msgid "~S: The name of a generic function must be a function name, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~S. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#: clos-genfun4.lisp:390
#, fuzzy, lisp-format
msgid "~S: the lambda-list of ~S is not yet known"
msgstr "FUNCTION: falta la lista lambda de ~S"

#: clos-genfun4.lisp:408 clos-genfun4.lisp:464
#, fuzzy, lisp-format
msgid "Invalid ~S result ~S: ~A"
msgstr "Componente ~S inválida: ~S"

#: clos-print.lisp:16
#, lisp-format
msgid "No ~S method for ~S (~S (~S))"
msgstr ""

#: disassem.lisp:56
#, fuzzy, lisp-format
msgid "Cannot disassemble natively compiled function ~S"
msgstr "Desensamblado de la función "

#: disassem.lisp:84
#, lisp-format
msgid "Cannot show machine instructions: gdb not found."
msgstr ""

#: condition.lisp:94
#, lisp-format
msgid "~S: the name of a condition must be a symbol, not ~S"
msgstr "~S: el nombre de una condición debe ser un símbolo, y no ~S"

# En este mensaje, el término `parent-type' se refiere al segundo
# argumento de la macro `define-condition' que, según el estándar, se
# utiliza como lista de super-tipos del que se obtiene una nueva
# condición.
#
# Por ese motivo, he añadido la expresión "super-tipos" - cll
#
#: condition.lisp:100
#, lisp-format
msgid "~S: the parent-type list must be a list of symbols, not ~S"
msgstr "~S: la lista de \"super-tipos\" debe ser una lista de símbolos, y no ~S"

#: condition.lisp:106
#, lisp-format
msgid "~S: the slot description list must be a list, not ~S"
msgstr "~S: la lista de descripción de la ranura debe ser una lista, y no ~S"

#: condition.lisp:190
#, fuzzy, lisp-format
msgid "~S: cannot find a ~S class that is a subtype of ~S"
msgstr "~S: el tipo ~S no es un subtipo de ~S"

#: condition.lisp:204
#, lisp-format
msgid "~S ~S: superfluous arguments ~S"
msgstr "~S ~S: los argumentos ~S son superfluos"

#: condition.lisp:217
#, lisp-format
msgid "~S: the condition argument must be a string, a symbol or a condition, not ~S"
msgstr "~S: el argumento de la condición debe ser una cadena de caracteres, un símbolo o una condición, y no ~S"

#: condition.lisp:669
#, lisp-format
msgid "~S: illegal syntax of clause ~S"
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: condition.lisp:674
#, fuzzy, lisp-format
msgid "~S: multiple ~S clauses: ~S and ~S"
msgstr "~S: la clausula ~S está mal colocada: ~S"

#: condition.lisp:682
#, lisp-format
msgid "~S: too many variables ~S in clause ~S"
msgstr "~S: demasiadas variables ~S en la clausula ~S"

# Duda: ¿y cómo traduzco `restart'?
#
# He decidido dejar `restart' sin traducir, ... :(
#
#: condition.lisp:844
#, lisp-format
msgid "~S: ~S is not a valid restart name here. Use ~S instead."
msgstr "~S: ~S no es válido como nombre de `restart' aquí. En su lugar, use ~S."

#: condition.lisp:866
#, lisp-format
msgid "~S: invalid restart name ~S"
msgstr "~S: ~S es un nombre inválido de `restart'"

#: condition.lisp:871
#, lisp-format
msgid "~S: No restart named ~S is visible."
msgstr "~S: No hay ningún `restart' visible llamado ~S"

#: condition.lisp:927 condition.lisp:987
#, lisp-format
msgid "~S: not a list: ~S"
msgstr "~S: no es una lista: ~S"

#: condition.lisp:938 condition.lisp:998
#, lisp-format
msgid "~S: invalid restart specification ~S"
msgstr "~S: ~S no es una especificación válida de `restart'"

#: condition.lisp:951 condition.lisp:1035
#, lisp-format
msgid "~S: unnamed restarts require ~S to be specified: ~S"
msgstr "~S: es necesario especificar ~S en los `restart' sin nombre: ~S"

#: condition.lisp:1020
#, lisp-format
msgid "~S: missing lambda list in restart specification ~S"
msgstr "~S: falta la lista lambda en la especificación del `restart' ~S"

#: condition.lisp:1041
#, lisp-format
msgid "~S: restart cannot be invoked interactively because it is missing a ~S option: ~S"
msgstr "~S: el `restart' no puede invocarse interactivamente porque falta la opción ~S: ~S"

#: condition.lisp:1207
#, lisp-format
msgid "Use instead~@[ of ~S~]: "
msgstr ""

#: condition.lisp:1216
#, lisp-format
msgid "Use instead of ~S [value ~D of ~D]: "
msgstr ""

#: condition.lisp:1217
#, lisp-format
msgid "New ~S [value ~D of ~D]: "
msgstr ""

#: condition.lisp:1382
#, lisp-format
msgid "try calling ~S again"
msgstr ""

#: condition.lisp:1388
#, fuzzy, lisp-format
msgid "specify return values"
msgstr "Demasiados valores devueltos"

# Duda: Francamente, no sé porqué motivo esto no fué traducido al
# FRANCÉS o al INGLÉS (compruébese en el código, ...) porque en
# realidad, queda pero que muy bien poner `paso' cuando se hace la
# depuración paso a paso, ...
#
# Este mensaje, de hecho, aparece cuando se hace algo del tipo:
#
# > (step (+ 2 3))
# step 1 --> (+ 2 3)
# Step 1>
#
# ..., donde, traduciendo el primer `step' al español, queda algo muy
# propio:
#
# > (step (+ 2 3))
# paso 1 --> (+ 2 3)
# Step 1>
#
# A mi me gusta así, ..., aA SACO!!
#
#: condition.lisp:1404
#, fuzzy, lisp-format
msgid "skip "
msgstr "paso "

#: condition.lisp:1413
#, fuzzy, lisp-format
msgid "stop loading file ~A"
msgstr "Cargando el fichero \""

#: condition.lisp:1545 condition.lisp:1642
#, lisp-format
msgid "Return from ~S loop"
msgstr "Retorno del bucle ~S"

#
# En este caso he tenido que traducir `warning' por `advertencia', en
# vez de `atención'. ¿No querreis que diga algo así como "Esto es más
# serio que un toque de atención"? Así parecería que el compilador le va
# a meter una paliza al pobre programador, ... :) - cll
#
#: condition.lisp:1626
#, lisp-format
msgid "~S: This is more serious than a warning: ~A"
msgstr "~S: Esto es más serio que una advertencia: ~A"

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: condition.lisp:1632
#, fuzzy
msgid "WARNING: "
msgstr "ATENCIÓN:"

#: loadform.lisp:42
#, lisp-format
msgid "A method on ~S for class ~S is necessary for externalizing the object ~S, according to ANSI CL 3.2.4.4, but no such method is defined."
msgstr ""

#: xcharin.lisp:57
#, fuzzy, lisp-format
msgid "~S: the font argument should be an integer, not ~S"
msgstr "~: el argumento de la fuente debe ser un número y no ~"

#: xcharin.lisp:65
#, fuzzy, lisp-format
msgid "~S: the bits argument should be an integer, not ~S"
msgstr "~: el argumento de los bits debe ser un entero y no ~"

# Ya, ya se que eso de "los nombres de bit" puede sonar muy raro, pero
# es que realmente es así en Common Lisp.  Consúltese el Cltl2, 13.5
# Character Control-Bit Functions, página 385
#
#: xcharin.lisp:85
#, fuzzy, lisp-format
msgid "~S: the only bit names are ~S, ~S, ~S, ~S, not ~S"
msgstr "~: los únicos nombres de bit son :CONTROL, :META, :SUPER y :HYPER, y no ~"

#: runprog.lisp:162
#, lisp-format
msgid "~S: File ~S already exists"
msgstr "~S: El fichero ~S ya existe"

# Con un poco de suerte, aquí se podría poner directamente " (s/n) ".
# En fileutils ya se puede. sv
#
# Bueno, pues sí, ..., sí podría hacerse. Ahora bien, para eso es
# necesario modificar el código fuente del clisp (lo cual no es nada
# complicado gracias a la localizacion de codigo fuente del modo .PO
# desde Emacs :). De momento, lo dejo tal cual (aunque queda pachín,
# pachán, ... :( ) y luego lo modificaré, ..., ¿vale?. cll
#
#: query.lisp:12
msgid " (y/n) "
msgstr " (si(y)/no(n)) "

#: query.lisp:22
msgid "Please answer with y or n : "
msgstr "Por favor, responda con y(si) o n(no) : "

#: query.lisp:32
msgid " (yes/no) "
msgstr " (si(yes)/no(no)) "

#: query.lisp:41
msgid "Please answer with yes or no : "
msgstr "Por favor, responda con yes(si) o no(no) : "

# paquete (?) sv
#
# Bueno, podría parecer muy conveniente. Sin embargo, verás, ..., lo de
# *package* está puesto a nivel de programa. Es decir, Bruno Haible y
# compañÂía lo tienen puesto así desde su propio programa. Por lo tanto,
# si lo cambio en un par de mensajes seguirá apareciendo en muchos otros
# sitios. Prefiero ser consistente y dejarlo así. cll
#
# Además, no está traducido ni en alemán ni en inglés. cll
#
#: reploop.lisp:77
msgid "[*package* invalid]"
msgstr "[*package* inválido]"

#: reploop.lisp:108
#, lisp-format
msgid "Reset *PACKAGE* to ~s"
msgstr ""

#: reploop.lisp:202
#, lisp-format
msgid "Printed ~D frame~:P"
msgstr ""

#: reploop.lisp:244
#, fuzzy
msgid "The last error:"
msgstr "Formato de programa no ejecutable"

# Me suele gustar más "utilice" (porque me parece más "fino"). sv
#
# De acuerdo, ..., cambiado `use' por `utilice'. A mí también me gusta más. cll
#
# Y además, (recomendación tuya, Santiago), `command' por `orden', en
# vez de `comando' - cll
#
#: reploop.lisp:267
#, fuzzy
msgid ""
"You are in the top-level Read-Eval-Print loop.\n"
"Help (abbreviated :h) = this list\n"
"Use the usual editing capabilities.\n"
"(quit) or (exit) leaves CLISP."
msgstr ""
"\n"
"Help = esta lista\n"
"Utilice las órdenes de edición habituales"

#: reploop.lisp:278
msgid ""
"\n"
"Commands may be abbreviated as shown in the second column.\n"
"COMMAND        ABBR     DESCRIPTION\n"
"Help           :h, ?    this command list\n"
"Error          :e       Print the last error message\n"
"Inspect        :i       Inspect the last error\n"
"Abort          :a       abort to the next recent input loop\n"
"Unwind         :uw      abort to the next recent input loop\n"
"Reset          :re      toggle *PACKAGE* and *READTABLE* between the\n"
"                          local bindings and the sane values\n"
"Quit           :q       quit to the top-level input loop\n"
"Where          :w       inspect this frame\n"
"Up             :u       go up one frame, inspect it\n"
"Top            :t       go to top frame, inspect it\n"
"Down           :d       go down one frame, inspect it\n"
"Bottom         :b       go to bottom (most recent) frame, inspect it\n"
"Mode mode      :m       set stack mode for Backtrace: 1=all the stack elements\n"
"             2=all the frames                         3=only lexical frames\n"
"             4=only EVAL and APPLY frames (default)   5=only APPLY frames\n"
"Frame-limit n  :fl      set the frame-limit for Backtrace. This many frames\n"
"                          will be printed in a backtrace at most.\n"
"Backtrace [mode [limit]] :bt  inspect the stack\n"
"Break+         :br+     set breakpoint in EVAL frame\n"
"Break-         :br-     disable breakpoint in EVAL frame\n"
"Redo           :rd      re-evaluate form in EVAL frame\n"
"Return value   :rt      leave EVAL frame, prescribing the return values"
msgstr ""

#: reploop.lisp:349
#, fuzzy
msgid ""
"\n"
"Continue       :c       continue evaluation"
msgstr ""
"\n"
"Continue = continuar la evaluación"

# ¿form no era formulario? (o a lo mejor es algo de lisp que no sé). sv
#
# En Visual Basic (y los lenguajes orientados a eventos), form es formulario.
# Sin embargo, en Lisp form es forma. Se refiere a las sentencias Lisp. cll
#
#: reploop.lisp:356
#, fuzzy
msgid ""
"\n"
"Step           :s       step into form: evaluate this form in single step mode\n"
"Next           :n       step over form: evaluate this form at once\n"
"Over           :o       step over this level: evaluate at once up to the next return\n"
"Continue       :c       switch off single step mode, continue evaluation\n"
"-- Step-until :su, Next-until :nu, Over-until :ou, Continue-until :cu --\n"
"           same as above, specify a condition when to stop"
msgstr ""
"\n"
"Step     = entrar en una forma: evaluar esta forma en el modo paso a paso\n"
"Next     = saltarse una forma: evaluar esta forma en un solo paso\n"
"Over     = saltarse este nivel: evaluar hasta el siguiente retorno\n"
"Continue = desactivar el modo paso a paso y continuar la evaluación\n"
"Step-until, Next-until, Over-until, Continue-until:\n"
"           lo mismo que antes, especifique una condición de parada"

#: reploop.lisp:417
msgid "Abort main loop"
msgstr ""

#: reploop.lisp:484
msgid "You can continue (by typing 'continue')."
msgstr "Puede continuar (tecleando `continue')."

#: reploop.lisp:498
#, fuzzy
msgid "The following restarts are also available:"
msgstr "Es posible continuar en los siguientes puntos:"

#: reploop.lisp:499
msgid "The following restarts are available:"
msgstr "Es posible continuar en los siguientes puntos:"

#: reploop.lisp:548
msgid "Abort debug loop"
msgstr ""

# Duda: Francamente, no sé porqué motivo esto no fué traducido al
# FRANCÉS o al INGLÉS (compruébese en el código, ...) porque en
# realidad, queda pero que muy bien poner `paso' cuando se hace la
# depuración paso a paso, ...
#
# Este mensaje, de hecho, aparece cuando se hace algo del tipo:
#
# > (step (+ 2 3))
# step 1 --> (+ 2 3)
# Step 1>
#
# ..., donde, traduciendo el primer `step' al español, queda algo muy
# propio:
#
# > (step (+ 2 3))
# paso 1 --> (+ 2 3)
# Step 1>
#
# A mi me gusta así, ..., aA SACO!!
#
#: reploop.lisp:595 reploop.lisp:636
msgid "step "
msgstr "paso "

#: reploop.lisp:599
msgid "no values"
msgstr "sin valores"

#: reploop.lisp:600
msgid "value: "
msgstr "valor: "

#: reploop.lisp:603
msgid " values: "
msgstr " valores: "

#: reploop.lisp:648
msgid "Abort stepper"
msgstr ""

#: reploop.lisp:665
msgid "condition when to stop: "
msgstr "condición de parada: "

#: dribble.lisp:34
#, fuzzy, lisp-format
msgid "~S: ~S should be a ~S"
msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

# Nota: La utilización de dribbling viene de la función dribble de Lisp.
#       Dicha función graba una sesión Lisp en el archivo que se indique en la
#       llamada a la función.
#
# La traducción no juega, de esa manera, con las palabras.
#
#: dribble.lisp:45
#, fuzzy, lisp-format
msgid "Already dribbling ~S to ~S"
msgstr "Ya se está grabando la sesión en ~S"

# Nota: `is finished' debería traducirse por `está finalizado' o `est
#       finalizada'. Sin embargo, esta parte se compondrá con otras
#       donde la traducción `ha finalizado' sigue siendo igualmente válida y,
#       además, nos evitamos la utilización de una forma eminentemente
#       masculina o fememina.
#
#: dribble.lisp:47
#, fuzzy, lisp-format
msgid "~&;; Dribble of ~S finished on ~A.~%"
msgstr " ha finalizado."

# Nota: `is finished' debería traducirse por `está finalizado' o `est
#       finalizada'. Sin embargo, esta parte se compondrá con otras
#       donde la traducción `ha finalizado' sigue siendo igualmente válida y,
#       además, nos evitamos la utilización de una forma eminentemente
#       masculina o fememina.
#
#: dribble.lisp:59
#, fuzzy, lisp-format
msgid ";; Dribble of ~S started on ~A.~%"
msgstr " ha finalizado."

#: dribble.lisp:62
#, fuzzy, lisp-format
msgid "Currently not dribbling from ~S."
msgstr "En este momento, no se está grabando la sesión."

#: describe.lisp:54
msgid "symbol-macro"
msgstr ""

#: describe.lisp:57
msgid "constant"
msgstr "constante"

#: describe.lisp:58
msgid "variable"
msgstr "variable"

#: describe.lisp:64
msgid "type"
msgstr "tipo"

# Duda: Lo que he dicho unos pocos mensajes más arriba --> Slot por
# slot, ...
#
# Pues no, ... A partir de la versión 1.4, `slot' es "ranura", tal y
# como se propone en la lista de spanglish.
#
#: describe.lisp:90
#, fuzzy, lisp-format
msgid "Slots:"
msgstr "Ranuras:"

#: describe.lisp:97
#, lisp-format
msgid "unbound"
msgstr "sin asociar"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: describe.lisp:102
#, fuzzy, lisp-format
msgid "No slots."
msgstr "Sin ranuras."

#: describe.lisp:130
#, fuzzy, lisp-format
msgid "a foreign pointer."
msgstr "una puntero externo"

#: describe.lisp:133
#, fuzzy, lisp-format
msgid "a foreign address."
msgstr "una dirección externa"

#: describe.lisp:136
#, lisp-format
msgid "a foreign variable of foreign type ~S."
msgstr "una variable externa del tipo extranjero ~S."

#: describe.lisp:140
#, lisp-format
msgid "a server socket accepting connections."
msgstr ""

#: describe.lisp:142
#, lisp-format
msgid "a byte specifier, denoting the ~S bits starting at bit position ~S of an integer."
msgstr "un especificador de byte que denota los ~S bits que comienzan en el bit ~S de un entero"

#: describe.lisp:145
#, lisp-format
msgid "a special form handler."
msgstr "un manipulador de forma especial."

#: describe.lisp:147
#, lisp-format
msgid "a load-time evaluation promise."
msgstr "una promesa de evaluación en tiempo de carga."

#: describe.lisp:149
#, fuzzy, lisp-format
msgid "a symbol macro handler."
msgstr "un manipulador de forma especial."

#: describe.lisp:151
#, fuzzy, lisp-format
msgid "a global symbol macro handler."
msgstr "un manipulador de forma especial."

#: describe.lisp:153
#, fuzzy, lisp-format
msgid "a macro expander."
msgstr "un manipulador de forma especial."

#: describe.lisp:157 describe.lisp:357 describe.lisp:567
#, fuzzy, lisp-format
msgid "For more information, evaluate ~{~S~^ or ~}."
msgstr "Para más información, evalúe ~{~S~^ o ~}."

#: describe.lisp:160
#, lisp-format
msgid "a function with alternative macro expander."
msgstr ""

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: describe.lisp:162
#, fuzzy, lisp-format
msgid "an encoding."
msgstr "un cons."

#: describe.lisp:167
#, lisp-format
msgid "a GC-invisible pointer to ~S."
msgstr ""

#: describe.lisp:170
#, lisp-format
msgid "a GC-invisible pointer to a now defunct object."
msgstr ""

#: describe.lisp:174
#, lisp-format
msgid "a list of GC-invisible pointers to ~{~S~^, ~}."
msgstr ""

#: describe.lisp:176
#, lisp-format
msgid "a list of GC-invisible pointers, all defunct by now."
msgstr ""

#: describe.lisp:180
#, lisp-format
msgid "a weak \"and\" relation between ~{~S~^, ~}."
msgstr ""

#: describe.lisp:182
#, lisp-format
msgid "a weak \"and\" relation, no longer referring to its objects."
msgstr ""

#: describe.lisp:186
#, lisp-format
msgid "a weak \"or\" relation between ~{~S~^, ~}."
msgstr ""

#: describe.lisp:188
#, lisp-format
msgid "a weak \"or\" relation, all elements defunct by now."
msgstr ""

#: describe.lisp:192
#, lisp-format
msgid "a weak association from ~S to ~S."
msgstr ""

#: describe.lisp:193
#, lisp-format
msgid "a weak association, the key value being defunct by now."
msgstr ""

#: describe.lisp:197
#, lisp-format
msgid "a weak \"and\" mapping from ~:S to ~S."
msgstr ""

#: describe.lisp:198
#, lisp-format
msgid "a weak \"and\" mapping, some key value being defunct by now."
msgstr ""

#: describe.lisp:202
#, lisp-format
msgid "a weak \"or\" mapping from ~:S to ~S."
msgstr ""

#: describe.lisp:203
#, lisp-format
msgid "a weak \"or\" mapping, all keys being defunct by now."
msgstr ""

#: describe.lisp:207
#, lisp-format
msgid "a weak association list, of type ~S "
msgstr ""

#: describe.lisp:209
#, lisp-format
msgid "(i.e. a list of ~S key/value pairs)"
msgstr ""

#: describe.lisp:210
#, lisp-format
msgid "(i.e. a list of ~S value/key pairs)"
msgstr ""

#: describe.lisp:211 describe.lisp:212
#, lisp-format
msgid "(i.e. a list of (key . value) pairs each combined into a ~S)"
msgstr ""

#: describe.lisp:214
#, lisp-format
msgid ", containing ~S."
msgstr ""

#: describe.lisp:215
#, lisp-format
msgid ", no longer referring to any pairs."
msgstr ""

#: describe.lisp:217
#, lisp-format
msgid "a label used for resolving #~D# references during READ."
msgstr "una etiqueta para resolver #~D# referencias en READ."

#: describe.lisp:221
#, lisp-format
msgid "a pointer into the stack. It points to:"
msgstr "Un puntero a la pila. Apunta a:"

#: describe.lisp:224
#, lisp-format
msgid "a special-purpose object."
msgstr "un objeto de propósito especial."

#: describe.lisp:226
#, lisp-format
msgid "a machine address."
msgstr "una dirección de máquina."

#: describe.lisp:228
#, lisp-format
msgid "an instance of the CLOS class ~S."
msgstr "una instancia de la clase CLOS ~S."

#: describe.lisp:232
#, fuzzy, lisp-format
msgid "an instance of the CLOS class ~S, can be used as a function."
msgstr "una instancia de la clase CLOS ~S."

#: describe.lisp:236
#, lisp-format
msgid "a structure of type ~S."
msgstr "una estructura del tipo ~S."

#: describe.lisp:241
#, lisp-format
msgid "As such, it is also a structure of type ~{~S~^, ~}."
msgstr "Como tal, también es una estructura del tipo ~{~S~^, ~}."

#: describe.lisp:249
#, lisp-format
msgid "a dotted list of length ~S."
msgstr "una lista punteada de longitud ~S."

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: describe.lisp:252
#, lisp-format
msgid "a cons."
msgstr "un cons."

#: describe.lisp:255
#, lisp-format
msgid "a list of length ~S."
msgstr "una lista de longitud ~S."

#: describe.lisp:257
#, lisp-format
msgid "a cyclic list."
msgstr "una lista cíclica."

#: describe.lisp:259
#, lisp-format
msgid "the empty list, "
msgstr "la lista vacía, "

#: describe.lisp:262
#, fuzzy, lisp-format
msgid "the symbol ~S, "
msgstr "el símbolo ~S"

#: describe.lisp:266
#, lisp-format
msgid "lies in ~S"
msgstr "está en el ~S"

# Duda: He traducido al estilo del mensaje en francés: "n'appartient
# aucun paquetage"
#
#: describe.lisp:269
#, lisp-format
msgid "is uninterned"
msgstr "no aparece en ningún paquete"

# Nota: Caso brillante de la generación de mensajes diferentes gracias a las
#       directivas condicionales del Clisp (y del Common Lisp en general).
#
#: describe.lisp:283
#, fuzzy, lisp-format
msgid ", is accessible in ~:d package~:p ~{~A~^, ~}"
msgstr " y es accesible desde ~:[el paquete~;los paquetes~] ~{~A~^, ~}"

#: describe.lisp:288
#, fuzzy, lisp-format
msgid ", is a keyword"
msgstr ", una palabra clave"

#: describe.lisp:290
#, lisp-format
msgid ", symbol-macro expanding to: ~S"
msgstr ""

#: describe.lisp:295
#, lisp-format
msgid ", a constant"
msgstr ", una constante"

#: describe.lisp:297
#, lisp-format
msgid ", a variable declared SPECIAL"
msgstr ", una variable declarada SPECIAL"

#: describe.lisp:298
#, lisp-format
msgid ", a variable"
msgstr ", una variable"

#: describe.lisp:299
#, fuzzy, lisp-format
msgid ", value: ~s"
msgstr " valores: "

#: describe.lisp:302
#, fuzzy, lisp-format
msgid ", an unbound variable declared SPECIAL"
msgstr ", una variable declarada SPECIAL"

#: describe.lisp:304
#, lisp-format
msgid ", names "
msgstr ", nombra "

#: describe.lisp:306
#, fuzzy, lisp-format
msgid "a special operator"
msgstr "una forma especial"

# Sugerencia: definición de macro. sv
#
# Hmmm, ..., lo de macro definición es bastante típico en informática
# (ya sabes, ...) Sin embargo, en Lisp se suele decir definición de
# macro, tal y como tú propones, ..., pues vale, ¡sugerencia
# completamente aceptada! cll
#
#: describe.lisp:308
#, lisp-format
msgid " with macro definition"
msgstr " con definición de macro"

#: describe.lisp:310
#, fuzzy, lisp-format
msgid "a~:[~; deprecated~] function"
msgstr "una función ~:[interpret~;compil~]ada."

#: describe.lisp:313
#, fuzzy, lisp-format
msgid "a~:[~; deprecated~] macro"
msgstr "una función ~:[interpret~;compil~]ada."

#: describe.lisp:317
#, fuzzy, lisp-format
msgid " (use ~S instead)"
msgstr "Función no implementada"

#: describe.lisp:322
#, lisp-format
msgid ", names a type"
msgstr ", nombra un tipo"

#: describe.lisp:326
#, lisp-format
msgid ", names a class"
msgstr ", nombra una clase"

#: describe.lisp:332
#, fuzzy, lisp-format
msgid ", names a built-in foreign type"
msgstr ", nombra un tipo"

#: describe.lisp:333
#, fuzzy, lisp-format
msgid ", names a foreign type"
msgstr ", nombra un tipo"

#: describe.lisp:340
#, fuzzy, lisp-format
msgid ", has ~:D propert~@:P ~{~S~^, ~}"
msgstr ", tiene ~[~;la propiedad~:;las propiedades~] ~{~S~^, ~}"

#: describe.lisp:343 describe.lisp:385 describe.lisp:419 describe.lisp:441 describe.lisp:516
#, lisp-format
msgid "."
msgstr "."

#: describe.lisp:348
#, fuzzy, lisp-format
msgid "Documentation as a ~A:"
msgstr "documentación: ~A"

#: describe.lisp:352 describe.lisp:354 describe.lisp:464
#, fuzzy, lisp-format
msgid "~%~A Documentation is at~% ~S"
msgstr "documentación: ~SA"

#: describe.lisp:361
#, fuzzy, lisp-format
msgid "an integer, uses ~S bit~:P, is represented as a ~:[bignum~;fixnum~]."
msgstr "un entero que usa ~S bits y se representa como un ~(~A~)."

#: describe.lisp:364
#, lisp-format
msgid "a rational, not integral number."
msgstr "un racional, no un número entero."

#: describe.lisp:366
#, lisp-format
msgid "a float with ~S bits of mantissa (~(~A~))."
msgstr "un número en coma flotante con ~S bits de mantisa (~(~A~))."

#: describe.lisp:369
#, lisp-format
msgid "a complex number "
msgstr "un número complejo "

#: describe.lisp:374
#, lisp-format
msgid "at the origin"
msgstr "en el origen"

#: describe.lisp:375
#, lisp-format
msgid "on the ~:[posi~;nega~]tive real axis"
msgstr "en el eje real ~:[posi~;nega~]tivo"

#: describe.lisp:378
#, lisp-format
msgid "on the ~:[posi~;nega~]tive imaginary axis"
msgstr "en el eje imaginario ~:[posi~;nega~]tivo"

#: describe.lisp:380
#, fuzzy, lisp-format
msgid "in the ~:[~:[first~;fourth~]~;~:[second~;third~]~] quadrant"
msgstr "en el ~:[~:[primer~;cuarto~]~;~:[segundo~;tercer~]~] cuadrante"

# Si es lo que me imagino, tal vez sería mejor poner "del plano complejo".
# (como matemático que soy, me suena mejor :-). sv
#
# Pues sí, es exactamente lo que te imaginas, ..., "el plano de los números
# gaussianos" era una >>horrible<< traducción, ... ¡Gracias! cll
#
#: describe.lisp:382
#, lisp-format
msgid " of the Gaussian number plane."
msgstr " del plano complejo."

#: describe.lisp:384
#, lisp-format
msgid "a character"
msgstr "un carácter"

#: describe.lisp:390
#, lisp-format
msgid "Unicode name: ~A"
msgstr ""

#: describe.lisp:391
#, lisp-format
msgid "It is not defined by the Unicode standard."
msgstr ""

#: describe.lisp:393
#, lisp-format
msgid "It is a ~:[non-~;~]printable character."
msgstr "Se trata de un carácter ~:[no ~;~]imprimible."

#: describe.lisp:397
#, lisp-format
msgid "Its use is non-portable."
msgstr "Su utilización no es portable."

#: describe.lisp:399
#, lisp-format
msgid "a~:[~:[ closed ~;n output-~]~;~:[n input-~;n input/output-~]~]stream."
msgstr "un flujo ~:[~:[cerrado~;de salida~]~;~:[de entrada~;de entrada/salida~]~]."

#: describe.lisp:405
#, lisp-format
msgid " It reads from ~S from ~:D to ~:D at ~:D."
msgstr ""

#: describe.lisp:408
#, lisp-format
msgid " It appends to ~S."
msgstr ""

#: describe.lisp:413
#, lisp-format
msgid "the package named ~A"
msgstr "el paquete ~A"

#: describe.lisp:417
#, fuzzy, lisp-format
msgid ". It has ~:D nickname~:P ~{~A~^, ~}"
msgstr ". Tiene los apodos ~{~A~^, ~}"

# Duda: Debo comprobarlo en el código fuente de CLisp pero estoy casi
# seguro que esto es mucho mejor dejarlo sin traducir, ... cll
#
#: describe.lisp:423
#, lisp-format
msgid "It "
msgstr ""

#: describe.lisp:425
#, fuzzy, lisp-format
msgid "imports the external symbols of ~:D package~:P ~{~A~^, ~} and "
msgstr "importa los símbolos externos de~:[l paquete~; los paquetes~] ~{~A~^, ~} y "

#: describe.lisp:431
#, fuzzy, lisp-format
msgid "exports ~[no symbols~:;~:*~:D symbol~:P~]"
msgstr "~:[no exporta ningún símbolo~;exporta los símbolos~:*~{~<~%~:; ~S~>~^~}~]"

#: describe.lisp:434
#, lisp-format
msgid "~{ ~S~^,~}"
msgstr ""

#: describe.lisp:437
#, fuzzy, lisp-format
msgid " to ~:D package~:P ~{~A~^, ~}"
msgstr " ~:[al paquete~;a los paquetes~]: ~{~A~^, ~}"

#: describe.lisp:440
#, lisp-format
msgid ", but no package uses these exports"
msgstr ""

#: describe.lisp:450
#, lisp-format
msgid "It is a modern case-sensitive package."
msgstr ""

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: describe.lisp:453
#, fuzzy, lisp-format
msgid "ATTENTION: "
msgstr "ATENCIÓN:"

#: describe.lisp:456
#, lisp-format
msgid "It is a modern case-sensitive package, but uses the symbols from the traditional ~S!"
msgstr ""

#: describe.lisp:458
#, lisp-format
msgid "It is case-inverted, but not case-sensitive!"
msgstr ""

#: describe.lisp:460
#, lisp-format
msgid "It is case-sensitive, but not case-inverted!"
msgstr ""

#: describe.lisp:461
#, lisp-format
msgid "It is a traditional ANSI CL compatible package, but uses the symbols from the modern ~S!"
msgstr ""

#: describe.lisp:465
#, lisp-format
msgid "a deleted package."
msgstr "un paquete borrado."

#: describe.lisp:468
#, lisp-format
msgid "an ~S hash table with ~[no entries~:;~:*~:D entr~@:P~]."
msgstr ""

# Este mensaje tiene una especial dificultad, porque de el deberían
# salir cosas del tipo: "una tabla de lectura" (con `tabla de lectura'
# al final del mensaje) o "la tabla de lectura de Common Lisp" (con
# `tabla de lectura' al principio).
#
# Afortunadamente, la situación puede salvarse sin ningún problema
# gracias a la directiva ~:* de format
#
#: describe.lisp:471
#, lisp-format
msgid "~:[a~;the Common Lisp~] readtable."
msgstr "~:[una~;la~] tabla de lectura~:*~:[~; de Common Lisp~]"

#: describe.lisp:474
#, lisp-format
msgid "a ~:[~;portable ~]pathname~:[.~;~:*, with the following components:~{~A~}~]"
msgstr "una trayectoria~:[~; portátil~]~:[.~;~:*, constituída por: ~{~A~}~]"

#: describe.lisp:488
#, lisp-format
msgid "a random-state."
msgstr "un estado aleatorio."

#: describe.lisp:492
#, lisp-format
msgid "a~:[~; simple~] ~A dimensional array"
msgstr "una matriz~:[~; simple~] de dimensión ~A"

#: describe.lisp:495
#, lisp-format
msgid " (vector)"
msgstr " (vector)"

#: describe.lisp:498
msgid " with no storage"
msgstr ""

#: describe.lisp:499
#, fuzzy, lisp-format
msgid " of ~As"
msgstr " de ~(~A~)s"

#: describe.lisp:501
#, lisp-format
msgid ", adjustable"
msgstr ", ajustable"

#: describe.lisp:503
#, lisp-format
msgid ", of size ~{~S~^ x ~}"
msgstr ", de tamaño ~{~S~^ x ~}"

#: describe.lisp:506
#, lisp-format
msgid " and current length (fill-pointer) ~S"
msgstr " y longitud actual (fill-pointer) ~S"

#: describe.lisp:510
#, fuzzy, lisp-format
msgid " (a string)"
msgstr "buscar una cadena de caracteres"

#: describe.lisp:513
#, lisp-format
msgid " (a~:[~;n immutable~] ~:[~;reallocated ~]~A string)"
msgstr ""

#: describe.lisp:518
#, fuzzy, lisp-format
msgid "a generic function."
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~S no es una función genérica\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"~SS no es una función genérica"

#: describe.lisp:521 describe.lisp:646
#, fuzzy, lisp-format
msgid "Argument list: ~:S"
msgstr "lista de argumentos: ~S"

#: describe.lisp:526
#, fuzzy, lisp-format
msgid "Method combination: ~S"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: describe.lisp:531
#, lisp-format
msgid "Methods:"
msgstr ""

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: describe.lisp:542
#, fuzzy, lisp-format
msgid "No methods."
msgstr "~%Sin ranuras."

#: describe.lisp:547
#, fuzzy, lisp-format
msgid "a foreign function of foreign type ~S."
msgstr "una variable externa del tipo extranjero ~S."

#: describe.lisp:556
msgid "a built-in system function."
msgstr "una función predefinida del sistema."

#: describe.lisp:557
#, fuzzy
msgid "a compiled function."
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"una función ~:[interpret~;compil~]ada.\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"una función ~S:[interpret~S;compil~S]ada."

#: describe.lisp:572
#, fuzzy, lisp-format
msgid "an interpreted function."
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"una función ~:[interpret~;compil~]ada.\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"una función ~S:[interpret~S;compil~S]ada."

#: describe.lisp:583
#, lisp-format
msgid "~A [see above]"
msgstr ""

#: describe.lisp:587
#, lisp-format
msgid "~A is "
msgstr ""

#: describe.lisp:592
#, fuzzy, lisp-format
msgid "Documentation:"
msgstr ""
"#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"documentación: ~A\n"
"#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
"documentación: ~SA"

#: describe.lisp:654
#, fuzzy, lisp-format
msgid "Documentation: ~A"
msgstr "documentación: ~A"

#: describe.lisp:666
#, fuzzy, lisp-format
msgid "~S: file ~S does not exist - adjust ~S"
msgstr "~S: el fichero ~S no existe"

#: room.lisp:17
#, lisp-format
msgid "~S: argument must be ~S, ~S or ~S, not ~S"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: room.lisp:51 room.lisp:218
msgid "Total"
msgstr "Total"

#: room.lisp:60
#, lisp-format
msgid "Bytes permanently allocated:   ~9D~%Bytes currently in use:        ~9D~%Bytes available until next GC: ~9D"
msgstr "Bytes permanentemente asignados:   ~9D~%Bytes actualmente en uso:        ~9D~%Bytes disponibles hasta el próximo GC: ~9D"

#: edit.lisp:28
msgid "No external editor installed."
msgstr "No hay ningún editor externo instalado"

#: edit.lisp:82
#, lisp-format
msgid "~S cannot be edited."
msgstr "~S no puede ser editado."

#: edit.lisp:101
#, lisp-format
msgid "~S: source code for ~S not available."
msgstr "~S: el código fuente de ~S no está disponible."

#: macros3.lisp:13
#, lisp-format
msgid ""
"The form ~S yielded ~:[no values~;~:*~{~S~^ ; ~}~] ,~@\n"
"                       that's not of type ~S."
msgstr ""
"La forma ~S ~:[no produjo ningún valor~;produjo ~:*~{~S~^ ; ~}~] ,~@\n"
"                       que no es del tipo ~S."

#: macros3.lisp:65
#, lisp-format
msgid "LETF* code contains a dotted list, ending with ~S"
msgstr "El código del LETF* contiene una lista punteada que termina con ~S"

#: macros3.lisp:87
#, lisp-format
msgid "illegal syntax in LETF* binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF*: ~S"

#: macros3.lisp:244
#, lisp-format
msgid "LETF code contains a dotted list, ending with ~S"
msgstr "El código de LETF contiene una lista punteada que termina con ~S"

#: macros3.lisp:266
#, lisp-format
msgid "illegal syntax in LETF binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF: ~S"

#: clhs.lisp:177
#, fuzzy, lisp-format
msgid "~S: error ~D: ~S"
msgstr "~S en ~S: ~S es incorrecto"

#: clhs.lisp:238
#, fuzzy, lisp-format
msgid "~S is not found"
msgstr "~S: ~S no es el nombre de una función"

# Ya, ya se que eso de "los nombres de bit" puede sonar muy raro, pero
# es que realmente es así en Common Lisp.  Consúltese el Cltl2, 13.5
# Character Control-Bit Functions, página 385
#
#: clhs.lisp:253 clhs.lisp:293
#, fuzzy, lisp-format
msgid "~S returns invalid value ~S, fix it, ~S, ~S, or ~S"
msgstr "~: los únicos nombres de bit son :CONTROL, :META, :SUPER y :HYPER, y no ~"

#: clhs.lisp:317
#, fuzzy, lisp-format
msgid "~S: invalid symbol ~S with id ~S: ~A"
msgstr "~S ~S: parte de la lista lambda es inválida: ~S"

#: clhs.lisp:320
#, fuzzy, lisp-format
msgid "~S: invalid id ~S for symbol ~S"
msgstr "~S: forma inválida ~S"

#: threads.lisp:26
msgid "[Timed out] "
msgstr ""

#: threads.lisp:56
#, fuzzy, lisp-format
msgid "~S: ~S does not own ~S"
msgstr "~S: ~S no nombra una clase"

# Creo que si ~S es un sólo carácter, te cabe en la misma línea :-) sv
#
#: foreign1.lisp:106
#, lisp-format
msgid "Cannot map string ~S to C since it contains a character ~S"
msgstr "La cadena ~S no puede convertirse a C puesto que contiene el carácter ~S"

#: foreign1.lisp:144
#, lisp-format
msgid "Invalid ~S component: ~S"
msgstr "Componente ~S inválida: ~S"

#: foreign1.lisp:210
#, lisp-format
msgid "Incomplete FFI type ~S is not allowed here."
msgstr "El tipo incompleto FFI ~S no está permitido aquí"

#: foreign1.lisp:214
#, lisp-format
msgid "FFI type should be a symbol, not ~S"
msgstr "Un tipo FFI debe ser un símbolo, no ~S"

# Duda: pues un poco lo de siempre. FFI significa Foreign Function
# Interface y todo el mundo sabe que es el módulo de llamadas a
# funciones escritas en otro lenguaje (lo que yo he traducido como
# llamadas extranjeras). Los programadores avanzados en Lisp (y sólo
# ellos podrían ver un mensaje como este, ...) saben muy bien lo que es
# FFI. ¿Lo dejo así?, ...
#
# Uno de nuestros revisores (César Ballardini) dijo en cierta ocasión:
# "No es necesario explicar la terminología dentro de su propio contexto."
# Es decir: Si finalmente te decides por FFI (que por lo que dices
# parece lo más razonable), pon cuidado de no explicarlo tanto, por ejemplo,
# en el mensaje anterior al anterior a este. sv
#
# Vale, pues entonces se queda como FFI ¡y listo! cll
#
#: foreign1.lisp:217
#, lisp-format
msgid "Invalid FFI type: ~S"
msgstr "Tipo FFI inválido: ~S"

#: foreign1.lisp:322
#, lisp-format
msgid "Invalid option in ~S: ~S"
msgstr "Opción inválida en ~S: ~S"

#: foreign1.lisp:325
#, lisp-format
msgid "Only one ~S option is allowed: ~S"
msgstr "Sólo se permite una opción ~S: ~S"

#: foreign1.lisp:381
#, lisp-format
msgid "Invalid parameter specification in ~S: ~S"
msgstr "Especificación de parámetro inválida en ~S: ~S"

#: foreign1.lisp:395
#, fuzzy, lisp-format
msgid "~S argument ~S is not a pointer in ~S"
msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#: foreign1.lisp:420
#, lisp-format
msgid "~S: No ~S argument and no ~S form in this compilation unit; ~S assumed now and for the rest of this unit"
msgstr ""

#: foreign1.lisp:426
#, lisp-format
msgid "The name must be a string, not ~S"
msgstr "El nombre debe ser una cadena, no ~S"

#: foreign1.lisp:430
#, lisp-format
msgid "The name ~S is not a valid C identifier"
msgstr "El nombre ~S no es un identificador válido en C"

#: foreign1.lisp:679
#, lisp-format
msgid "illegal foreign data type ~S"
msgstr "el tipo de datos extranjero ~S es inválido"

#: foreign1.lisp:890
#, lisp-format
msgid "~S(~S ~S) requires writing to a C file"
msgstr ""

#: foreign1.lisp:925
#, fuzzy, lisp-format
msgid "~S(~S): CPP constant ~A is not defined"
msgstr "~S: El lenguaje ~S no está definido"

#: foreign1.lisp:941
#, lisp-format
msgid "~S: ~S option missing in ~S"
msgstr "~S: falta la opción ~S en ~S"

#: foreign1.lisp:1064 foreign1.lisp:1121
#, fuzzy, lisp-format
msgid "~S is deprecated, use ~S instead"
msgstr "Función no implementada"

#: foreign1.lisp:1230
#, lisp-format
msgid "~S (~S): value ~S will be assigned to both ~S and ~S"
msgstr ""

#: foreign1.lisp:1239
#, fuzzy, lisp-format
msgid "~S does not name a C enum type"
msgstr "~S no es una función genérica"

#: foreign1.lisp:1242
#, fuzzy, lisp-format
msgid "~S is not of C enum type ~S"
msgstr "el objeto no es del tipo requerido"

#: foreign1.lisp:1246
#, lisp-format
msgid "~S symbol value (~S) does not match its table value (~S) in ~S"
msgstr ""

#: foreign1.lisp:1251
#, fuzzy, lisp-format
msgid "~S is not a valid value of type ~S"
msgstr "~ no es un byte CODE-VECTOR válido"

#: foreign1.lisp:1269
#, lisp-format
msgid "~S is only allowed after ~S: ~S"
msgstr "Sólo se puede poner ~S después de ~S: ~S"

#, fuzzy
#~ msgid "Argument list: ~A"
#~ msgstr "~%lista de argumentos: "

#, fuzzy
#~ msgid "~s is deprecated, use ~s instead"
#~ msgstr "Función no implementada"

#~ msgid "~S ~S, option ~S may only be given once"
#~ msgstr "~S ~S, la opción ~S sólo se puede indicar una vez"

#, fuzzy
#~ msgid "~S ~S: invalid ~S option: ~S"
#~ msgstr "~S ~S: la opción ~S es inválida"

#, fuzzy
#~ msgid "~%CLISP Documentation is at~% ~S"
#~ msgstr "documentación: ~SA"

#, fuzzy
#~ msgid "~s situation must be ~s, ~s or ~s, but not ~s"
#~ msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#, fuzzy
#~ msgid "(~S ~S): The slot-definition argument is not of type ~S."
#~ msgstr "~S: el INITIAL-ELEMENT ~S no es del tipo ~S"

#, fuzzy
#~ msgid "~S: ~A"
#~ msgstr "~S: incorrecto ~S"

#, fuzzy
#~ msgid "~S is neither declared nor bound, it will be treated as if it were declared SPECIAL."
#~ msgstr ""
#~ "~S no está ni declarado ni ligado,~@\n"
#~ "                        será tratado como si hubiese sido declarado SPECIAL."

#, fuzzy
#~ msgid "Lambda list element ~S is superfluous. Only one variable is allowed after &ENVIRONMENT."
#~ msgstr "El elemento ~S de la lista lambda es innecesario."

#, fuzzy
#~ msgid "Missing &ENVIRONMENT parameter in lambda list ~S"
#~ msgstr "La lista lambda ~S necesita un parámetro &REST"

#, fuzzy
#~ msgid "Missing &WHOLE parameter in lambda list ~S"
#~ msgstr "La lista lambda ~S necesita un parámetro &REST"

#~ msgid "~S: :update must not be specified without :initial-element"
#~ msgstr "~S: no debe especificarse :update sin :initial-element"

#~ msgid "~S: :start-index ~S must not be greater than :end-index ~S"
#~ msgstr "~S: El índice :start ~S no debe ser mayor que el índice :end ~S"

#~ msgid "~S: :start1-index ~S must not be greater than :end1-index ~S"
#~ msgstr "~S: El índice start1 ~S no debe ser mayor que el índice :end1 ~S"

#~ msgid "~S: :start2-index ~S must not be greater than :end2-index ~S"
#~ msgstr "~S: El índice :start2 ~S no debe ser mayor que el índice :end2 ~S"

#, fuzzy
#~ msgid "~S: the symbol ~S names a global special variable"
#~ msgstr "~S: el símbolo ~S nombra una variable global"

#~ msgid "The lambda list of macro ~S contains a dot after &KEY."
#~ msgstr "La lista lambda de la macro ~S contiene un punto después de &KEY"

#, fuzzy
#~ msgid "The ~~newline format directive cannot take both modifiers."
#~ msgstr "La directiva ~~newline no puede tomar ambos modificadores."

#, fuzzy
#~ msgid "~s: no local name ~s in ~s"
#~ msgstr "~: anfitrión ~ desconocido en ~"

#~ msgid "Non-symbol ~S may not be declared IGNORE."
#~ msgstr "El \"no símbolo\" ~S no debe declararse IGNORE."

#~ msgid "Non-symbol ~S may not be declared IGNORABLE."
#~ msgstr "El \"no-símbolo\" ~S no debe declararse IGNORABLE."

#, fuzzy
#~ msgid "Non-symbol ~S may not be declared READ-ONLY."
#~ msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#~ msgid "dotted list given to ~S : ~S"
#~ msgstr "lista punteada entregada a ~S: ~S"

#~ msgid "~S: invalid code-vector ~S"
#~ msgstr "~S: CODE-VECTOR inválido ~S"

#, fuzzy
#~ msgid "~S: ~S should be a symbol"
#~ msgstr "~S: la variable ~S debe ser un símbolo"

#, fuzzy
#~ msgid "~A is not a number. Try again."
#~ msgstr "~: ~ no es un número de 8 bits"

#, fuzzy
#~ msgid "Values: "
#~ msgstr "valores: "

#
# "%s fuera de intervalo\n"
# No me gusta del todo. A lo mejor:
# "%s fuera de limites\n" - lsg
#
# Al final me he decidido por:
#
# "%s se ha salido del rango\n"
#
# ¿No te mola más? - cll
#
#~ msgid "%s out of range"
#~ msgstr "%s se ha salido del rango"

#~ msgid "~S: ~S is not an 8-bit number"
#~ msgstr "~S: ~S no es un número de 8 bits"

#~ msgid "~S: ~S is not a 16-bit number"
#~ msgstr "~S: ~S no es un número de 16 bits"

#, fuzzy
#~ msgid "~S: ~S is not a 32-bit number"
#~ msgstr "~S: ~S no es un número de 32 bits"

#, fuzzy
#~ msgid "~S: ~S is not a 64-bit number"
#~ msgstr "~S: ~S no es un número de 64 bits"

#~ msgid "~S: invalid argument ~S"
#~ msgstr "~S: el argumento ~S es inválido"

#~ msgid "~S: Unsupported call mechanism: ~S"
#~ msgstr "~S: mecanismo de llamado no soportado: ~S"

#~ msgid "~S: Bad function prototype: ~S"
#~ msgstr "~S: Prototipo de función incorrecto: ~S"

#~ msgid "~S: Wrong number of arguments for prototype ~S"
#~ msgstr "~S: número incorrecto de argumentos para el prototipo ~S"

#~ msgid "~S: Bad argument for prototype ~S: ~S"
#~ msgstr "~S: Argumento incorrecto para el prototipo ~S: ~S"

#~ msgid "~S: Bad argument: ~S"
#~ msgstr "~S: El argumento ~S es inválido"

#~ msgid "~S: ~S is not a valid address"
#~ msgstr "~S: ~S no es una dirección válida"

#~ msgid "~S: argument to UNSIGNED-BYTE must be an integer or * : ~S"
#~ msgstr "~S: el argumento de UNSIGNED-BYTE debe ser un entero o * : ~S"

#, fuzzy
#~ msgid "Unprintable error message."
#~ msgstr "Mensaje de error no imprimible"

#~ msgid "Basename ~S not a keyword or libraryname ~S not a string"
#~ msgstr "La base ~S no es una palabra clave o el nombre de la biblioteca ~S no es una cadena de caracteres"

#~ msgid "Library redefinition: old ~S, new ~S"
#~ msgstr "La biblioteca llamada ~S ha sido redefinida como ~S"

#~ msgid "Unknown library: ~S"
#~ msgstr "Biblioteca desconocida: ~S"

#~ msgid "Library ~S is not open"
#~ msgstr "La biblioteca ~S no está abierta"

#~ msgid "Unknown function of library ~S: ~S"
#~ msgstr "No se conoce ninguna función en la biblioteca ~S con el nombre ~S"

#~ msgid "Offset must be a fixnum: ~S"
#~ msgstr "El desplazamiento no es del tipo FIXNUM: ~S"

#~ msgid ";; redefining foreign library function ~S~%;;  from ~S to ~S"
#~ msgstr ";; redefiniendo la función ~S de la biblioteca externa~%;;  de ~S a ~S"

#~ msgid "Unknown register: ~S"
#~ msgstr "Registro desconocido: ~S"

#~ msgid "Invalid parameter specification ~S in function ~S"
#~ msgstr "La especificación de parámetros ~S de la función ~S es incorrecta"

#~ msgid "Unknown library function: ~S"
#~ msgstr "La función de biblioteca ~S no está definida"

#~ msgid "Bad number of arguments for ~S: ~S"
#~ msgstr "El número de argumentos de ~S es incorrecto: ~S"

#~ msgid "~S: package SCREEN is not implemented"
#~ msgstr "~S: el paquete SCREEN no está implementado"

#, fuzzy
#~ msgid "~S: variable specification after ~S too long : ~S"
#~ msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~S"

#~ msgid "~S from ~S: bit vector is longer than the explicitly given length ~S"
#~ msgstr "~S en ~S: la longitud del vector de bits es mayor que la longitud explícitamente indicada ~S"

#~ msgid "~S from ~S: must specify element of bit vector of length ~S"
#~ msgstr "~S en ~S: debe especificar un elemento para el vector de bits de longitud ~S"

#, fuzzy
#~ msgid "~S from ~S: invalid bit-vector length ~S"
#~ msgstr "~S: la longitud de BIT-VECTOR ~S es inválida"

# Junto las ¡! sv
# Sugerencia "¡Se estaba trazando!" (es como más "en español") sv
#
# Sí, tu sugerencia me gusta. Como se nota que tienes experiencia, ...,
# ¿eh? cll
#
#~ msgid "DEFUN/DEFMACRO: redefining ~S; it was traced!"
#~ msgstr "DEFUN/DEFMACRO: redefiniendo ~S; ¡se estaba rastreando!"

#~ msgid "~S: ~S is not a library"
#~ msgstr "~S: ~S no es una biblioteca"

#~ msgid "too long sequence ~S"
#~ msgstr "secuencia demasiado larga ~S"

# Duda: En Common Lisp existe lo que se denominan "Listas de asociación"
# (Common Lisp, The Language, 2nd Edition - Guy L. Steel, página 431) o,
# en inglés, "Association Lists" que abreviadamente se conocen como
# "alist" o "a-list". En realidad, aunque en español, mucha gente dice
# "alistas", esto no me parece correcto y me parece mucho más formal
# decir "listas de asociación".
#
# De hecho, el término "listas de asociación" será facílisimamente
# reconocible por el programador, mientras que "alista" exige estar un
# poquito más experimentado con el Lisp.
#
# Más aún, los traductores del libro "Lisp" (3ra edición) de Winston y
# Horn, utilizan la expresión "lista de asociación" en la presentación
# de la función ASSOC en la página 34, aunque luego también se refieran
# a ellas como "listas-a".
#
#~ msgid "~S from ~S: the value of ~S has been altered arbitrarily, it is not an alist: ~S"
#~ msgstr "~S en ~S: el valor de ~S ha sido modificado arbitrariamente, no es una lista de asociación: ~S"

#~ msgid "~S: array ~S has no fill-pointer"
#~ msgstr "~S: la matriz ~S no tiene ningún puntero de relleno"

#, fuzzy
#~ msgid "Argument list: ~A."
#~ msgstr "~%lista de argumentos: "

#, fuzzy
#~ msgid "~: argument ~S is not a character"
#~ msgstr "~: el argumento ~ no es un carácter"

#, fuzzy
#~ msgid "~S: argument ~S is neither an open SOCKET-STREAM nor a positive FIXNUM"
#~ msgstr "~S: el argumento ~S no es un SOCKET-STREAM"

#~ msgid "~S: argument ~S should be a vector of type (ARRAY (UNSIGNED-BYTE 8) (*))"
#~ msgstr "~S: el argumento ~S debe ser un vector del tipo (ARRAY (UNSIGNED-BYTE 8) (*)) "

#, fuzzy
#~ msgid "Loading logical host ~S from file ~A ..."
#~ msgstr "La carga del fichero "

#~ msgid "~S ~S, slot option for slot ~S must have the value ~S or ~S, not ~S"
#~ msgstr "~S ~S, la opción de ranura para ~S debe tener el valor ~S o ~S, y no ~S"

#, fuzzy
#~ msgid "service does not exist: ~A/~A"
#~ msgstr "el fichero ~ no existe"

#, fuzzy
#~ msgid "Invalid ~S declaration ~S"
#~ msgstr "~S: declaración incorrecta ~S"

#, fuzzy
#~ msgid "~S: ~S is not a 1:1 encoding"
#~ msgstr "~S: ~S no es un registro"

#~ msgid "~S from ~S: label #~S? too large"
#~ msgstr "~S en ~S: la etiqueta #~S? es demasiado grande"

#, fuzzy
#~ msgid " (macro: ~s)"
#~ msgstr " (macro)"

#~ msgid "stack size"
#~ msgstr "tamaño de la pila"

#~ msgid "no doc-strings allowed here: ~S"
#~ msgstr "no se permite la utilización de cadenas de documentación aquí: ~S"

#~ msgid "~S: :VERSION-argument should be NIL or :WILD or :NEWEST, not ~S"
#~ msgstr "~S: el argumento :VERSION debe ser o bien NIL, o :WILD o :NEWEST, pero no ~S"

#~ msgid "~S: stream must be a generic-stream, not ~S"
#~ msgstr "~S: el flujo debe ser un `generic-stream', no ~S"

#~ msgid "~S: stream must be a socket-stream, not ~S"
#~ msgstr "~S: el flujo debe ser un `socket-stream' y no ~S"

# "~S: ~S no es una formación" - lsg
#
# Aunque en la lista de spanglish.txt pone "formación", en este caso
# creo que será mucho más conveniente poner "matriz" porque de hecho,
# los mensajes se refieren a matrices, ... - cll
#
#~ msgid "~S: ~S is not an array"
#~ msgstr "~S: ~S no es una matriz"

#~ msgid "ANSI C program"
#~ msgstr "programa ANSI C"

#, fuzzy
#~ msgid "~s: compiled file ~s was created by an older CLISP version and needs to be recompiled"
#~ msgstr "Este fichero fue producido por otra versión de lisp. Debe recompilarse."

#~ msgid "~S: ~S is not a symbol."
#~ msgstr "~S: ~S no es un símbolo."

#, fuzzy
#~ msgid "~S: Missing store variable."
#~ msgstr "~S: variable ausente"

#, fuzzy
#~ msgid "~S ~S: &REST variable ~S should be a symbol."
#~ msgstr "~S: la variable ~S debe ser un símbolo"

#, fuzzy
#~ msgid "~S(~S): Only one variable is allowed after &REST, not ~S"
#~ msgstr "Sólo se permite una variable después de &REST, no ~S"

#, fuzzy
#~ msgid "~s: ~s is not a function name"
#~ msgstr "~: ~ no es el nombre de una función"

#, fuzzy
#~ msgid "Function ~s is deprecated~@[, use ~s instead~]"
#~ msgstr "Función no implementada"

# eso de función "a compilar" siempre
# me pareció un vicio moderno.
# Sugerencia: El nombre de la función que hay que compilar ... sv
#
# Perfecto, ... cll
#
#~ msgid "Name of function to be compiled must be a symbol, not ~S"
#~ msgstr "El nombre de una función que hay que compilar debe ser un símbolo, no ~S"

#, fuzzy
#~ msgid "~S: missing forms after ~A"
#~ msgstr "~S: variable ausente"

#~ msgid "~S ~S: The only valid generic function class name is ~S : ~S"
#~ msgstr "~S ~S: El único nombre válido de una clase de función genérica es ~S : ~S"

#~ msgid "~S ~S: The only valid method class name is ~S : ~S"
#~ msgstr "~S ~S: El único nombre válido de una clase de métodos es ~S : ~S"

#~ msgid "~S ~S: ~S is missing some required parameter"
#~ msgstr "~S ~S: ~S necesita algunos parámetros obligatorios"

#~ msgid "~S ~S: variable name ~S should be a symbol"
#~ msgstr "~S ~S: el nombre de la variable ~S debe ser un símbolo"

#, fuzzy
#~ msgid "~S is not a valid a ~S designator"
#~ msgstr "~: ~ no es un índice válido en ~"

#~ msgid "Cannot disassemble ~S"
#~ msgstr "No se puede desensamblar ~S"

#, fuzzy
#~ msgid "~%Argument list: ~A"
#~ msgstr "~%lista de argumentos: "

#, fuzzy
#~ msgid "~: ~ should be a lambda expression"
#~ msgstr "~S: ~S debe ser una expresión lambda"

#, fuzzy
#~ msgid "~: symbol ~ is declared special and must not be declared a macro"
#~ msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#~ msgid "~: symbol ~ must not be declared SPECIAL and a macro at the same time"
#~ msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#~ msgid "~: the ~ clause must be the last one"
#~ msgstr "~: la clausula ~ debe ser la última"

#, fuzzy
#~ msgid "~: file ~ already exists"
#~ msgstr "~: El fichero ~ ya existe"

#, fuzzy
#~ msgid "~ from ~: character read should be a character: ~"
#~ msgstr "~ en ~: el carácter leído debe ser un STRING-CHAR: ~"

#~ msgid "~: input stream ~ ends within read macro beginning to ~"
#~ msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba una macro de lectura en ~"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#~ msgid "~ from ~: After ~ is ~ an undefined dispatch macro character"
#~ msgstr "~ en ~: Después de ~ está ~, que no es un macro carácter secundario"

#~ msgid "~: index ~ too large for ~"
#~ msgstr "~: el índice ~ es demasiado grande para ~"

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~S.",
# pienso que "No hay ningún paquete con el nombre ~S" es ligeramente
# mejor, ¿qué te parece? - cll
#
#, fuzzy
#~ msgid "~: There is no package with name ~"
#~ msgstr "~S: No hay ningún paquete con el nombre ~S."

#~ msgid "~: ~ is not a closure"
#~ msgstr "~: ~ no es una cerradura"

#, fuzzy
#~ msgid "~: ~ is not a class"
#~ msgstr "~S: ~S no es una clase"

#~ msgid "~: index should be an integer, not ~"
#~ msgstr "~: el índice debe ser un entero, no ~"

#~ msgid "~: User break"
#~ msgstr "~: Interrupción del usuario"

#, fuzzy
#~ msgid "~: ~ is not a symbol"
#~ msgstr "~S: ~S no es un símbolo."

#, fuzzy
#~ msgid "~: argument ~ is not a character"
#~ msgstr "~: el argumento ~ no es un carácter"

#~ msgid "~: undefined function ~"
#~ msgstr "~: la función ~ no está definida"

#, fuzzy
#~ msgid "~: invalid type specification ~"
#~ msgstr "~S: la especificación de tipo ~S es inválida"

#~ msgid "illegal foreign data type ~"
#~ msgstr "el tipo de datos extranjero ~ es inválido"

#~ msgid "~: :OUT argument is not a pointer: ~"
#~ msgstr "~: el argumento :OUT no es un puntero: ~"

#, fuzzy
#~ msgid "~: ~ is not an output ~"
#~ msgstr "~: ~ no es un par"

#, fuzzy
#~ msgid "~: argument ~ should be ~."
#~ msgstr "~: el argumento ~ debe ser un flujo"

#~ msgid "Please choose:"
#~ msgstr "Por favor, escoja:"

#~ msgid "Please choose one of ~:{~A~:^, ~} ."
#~ msgstr "Por favor, elija uno/a de ~:{~A~:^, ~} ."

#~ msgid "uninterning ~S from ~S uncovers a name conflict."
#~ msgstr "Al sacar ~S de ~S se ha puesto de manifiesto un conflicto entre nombres."

#~ msgid "You may choose how to proceed."
#~ msgstr "Puede elegir cómo continuar."

#~ msgid "You may choose in favour of which symbol to resolve the conflict."
#~ msgstr "Puede elegir en favor de qué símbolo se debe resolver el conflicto."

#~ msgid "Which symbol should be accessible in ~S ?"
#~ msgstr "¿ Qué símbolo debe ser accesible en ~S ?"

#~ msgid "You may choose for every conflict in favour of which symbol to resolve it."
#~ msgstr "Puede elegir en favor de qué símbolo se debe resolver cada conflicto."

#
# Es una traducción un poco libre (literalmente sería "el nombre = ~S
# entra en conflicto...."), pero ésta me parece más corta y correcta. - lsg
#
#~ msgid "~S name conflicts while executing USE-PACKAGE of ~S into package ~S."
#~ msgstr "Conflicto de nombre ~S al ejecutar USE-PACKAGE de ~S al paquete ~S"

#
# Si fuera inglés corriente, estaría bien tu traducción, pero es inglés
# 'telegráfico', y en realidad quieren decir lo que te he escrito, es
# decir, 'nuevo' afecta a 'nombre', no a 'paquete'.
#
# Eres un gran maestro, algo así como un quinto dan de las traducciones,
# ... ¡Tienes toda la razón! :) - cll
#
#~ msgid "Please input new package name:"
#~ msgstr "Por favor, introduzca un nuevo nombre de paquete:"

#~ msgid "Please input new package nickname:"
#~ msgstr "Por favor, introduzca un nuevo apodo de paquete:"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# A partir de la versión 1997-05-03, este mensaje ha cambiado y se
# refiere a elementos que serán ignorados. Como no puede anticiparse
# cual será el género del objeto que se ignora, he preferido poner lo de
# os/as. ¿Qué os parece?
#
#~ msgid "Both will be ignored."
#~ msgstr "Ambos/as serán ignorados/as."

#~ msgid "Invalid keyword-value-pair: ~S ~S"
#~ msgstr "Par argumento clave y valor inválido: ~S ~S"

#~ msgid "COND code contains a dotted list, ending with ~S"
#~ msgstr "El código de COND contiene una lista punteada que termina con ~S"

#, fuzzy
#~ msgid " from file "
#~ msgstr ""
#~ "#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
#~ " de la fuente ~S\n"
#~ "#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
#~ " de la fuente ~SS"

#, fuzzy
#~ msgid "Error: ~~:@> not implemented"
#~ msgstr "función no implementada"

#, fuzzy
#~ msgid "~S: ~S must name a closure"
#~ msgstr "~: ~ no es una cerradura"

#, fuzzy
#~ msgid "~S: ~S must be a closure"
#~ msgstr "~: ~ no es una cerradura"

#~ msgid "instance ~S of class ~S has no slots (wrong metaclass)"
#~ msgstr "la instancia ~S de la clase ~S no tiene ranuras (metaclase errónea)"

#~ msgid "Too few arguments to ~S: ~S"
#~ msgstr "Muy pocos argumentos para ~S: ~S"

#, fuzzy
#~ msgid "~: malloc() failed"
#~ msgstr "mprotect() falló."

#
# Muy bueno el apunte sobre ese acento en "cómo". Gracias, Santiago - cll
#
#, fuzzy
#~ msgid ""
#~ "Internal error: statement in file ~, line ~ has been reached!!\n"
#~ "Please send the authors of the program a description how you produced this error!"
#~ msgstr ""
#~ "error interno: aen la sentencia del fichero ~, línea ~!!\n"
#~ "¡Por favor, envíe a los autores del programa una descripción de cómo\n"
#~ "se produjo este error!"

#
# "EVAL: la variable ~ no tiene asignado ningún valor" - lsg
#
# Bueno, he quitado lo de "asignado" porque parece de "perogrullo", pero
# lo demás se queda - cll
#
#~ msgid "EVAL: variable ~ has no value"
#~ msgstr "EVAL: la variable ~ no tiene ningún valor"

#~ msgid "Too many documentation strings in ~"
#~ msgstr "Demasiadas cadenas de documentación en ~"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#, fuzzy
#~ msgid "~: lambda-list for ~ is missing"
#~ msgstr "FUNCTION: falta la lista lambda de ~"

#
# "FUNCTION: la lista lambda de ~ debe ser una lista, no un(a) ~" - lsg
#
# Lo de "un(a)" no me mola, aunque sin esa palabra el mensaje queda más
# "telegráfico", me parece más apropiado para tratarse del "diálogo con
# un ordenador" :) - cll
#
#, fuzzy
#~ msgid "~: lambda-list for ~ should be a list, not ~"
#~ msgstr "FUNCTION: la lista lambda de ~ debe ser una lista, no ~"

#, fuzzy
#~ msgid "~: illegal declaration ~"
#~ msgstr "FUNCTION: declaración inválida ~"

#, fuzzy
#~ msgid "~: variable specification after ~ too long: ~"
#~ msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#, fuzzy
#~ msgid "~: ~ var must be followed by ~ or ~ or end of list: ~"
#~ msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~"

#
# Igualmente: "FUNCTION: &REST debe ir seguido de una variable: ~" - lsg
#
# Pues si, es que cuando uno está mucho tiempo traduciendo del inglés,
# llega un momento en que empieza coger los hábitos de ese lenguaje y
# empieza a expresarse de una manera extraña, ... - cll
#
#, fuzzy
#~ msgid "~: ~ must be followed by a variable: ~"
#~ msgstr "FUNCTION: &REST debe ir seguido de una variable: ~"

#, fuzzy
#~ msgid "~: incorrect variable specification after ~: ~"
#~ msgstr "FUNCTION: especificación de variable incorrecta después de &KEY: ~"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#, fuzzy
#~ msgid "~: ~ must be followed by ~ or end of list: ~"
#~ msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~"

#, fuzzy
#~ msgid "~: variable specification after ~ too long : ~"
#~ msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~"

#, fuzzy
#~ msgid "~: badly placed lambda-list keyword ~: ~"
#~ msgstr "La palabra clave ~ de la lista lambda está mal situada: ~"

#, fuzzy
#~ msgid "~: too many parameters in the lambda-list ~"
#~ msgstr "FUNCTION: demasiados parámetros en la lista lambda ~"

#, fuzzy
#~ msgid "~: a dot in a lambda-list is allowed only for macros, not here: ~"
#~ msgstr "FUNCTION: sólo en las macros se permite utilizar un punto en la lista lambda, no aquí: ~"

#, fuzzy
#~ msgid "~: ~ is a special operator, not a function"
#~ msgstr "APPLY: ~ es una forma especial, no una función"

#~ msgid "~: ~ is a macro, not a function"
#~ msgstr "~: ~ es una macro, no una función"

#
# "EVAL/APPLY: no se han pasado suficientes argumentos a ~" - lsg
#
# Hmmm, ... Si me gusta, es más "explicativo". Si, me gusta, si, si
# Lo único que te trastoco es lo de "pasado" por "entregado". Ya sabes,
# un toque de distinción :) - cll
#
#~ msgid "EVAL/APPLY: too few arguments given to ~"
#~ msgstr "EVAL/APPLY: no se han entregado suficientes argumentos a ~"

#
# 'Se han pasado demasiados argumentos a ~" - lsg
#
# Bueno, tu traducción es absolutamente válido. Tal vez, algo más
# informal que la mía, por aquello de "pasado" en vez de
# "entregado". Bueno, pues si te parece, esta vez lo dejo como lo tenía
# yo - cll
#
#~ msgid "EVAL/APPLY: too many arguments given to ~"
#~ msgstr "EVAL/APPLY: se han entregado demasiados argumentos a ~"

# "EVAL: no se han pasado suficientes argumentos a la forma especial ~:~" - lsg
#
# Bueno, pues te digo lo mismo que en el mensaje eval.d:2572, ... - cll
#
#, fuzzy
#~ msgid "EVAL: too few parameters for special operator ~: ~"
#~ msgstr "EVAL: no se han entregado suficientes argumentos a la forma especial ~: ~"

#
# "Se han pasado demasiados parámetros a la forma especial ~: ~" - lsg
#
# O sea, que quite lo de "para" y ponga "a". Pues vale, tienes toda la
# razón del mundo - cll
#
#, fuzzy
#~ msgid "EVAL: too many parameters for special operator ~: ~"
#~ msgstr "EVAL: se han entregado demasiados parámetros a la forma especial ~: ~"

#, fuzzy
#~ msgid "EVAL: dotted parameter list for special operator ~: ~"
#~ msgstr "EVAL: la lista de parámetros para la forma especial ~ está punteada: ~"

#
# "EVAL: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Una vez más, te digo lo mismo que en el mensaje eval.d:2572 - cll
#
#~ msgid "EVAL: too few arguments given to ~: ~"
#~ msgstr "EVAL: no se han entregado suficientes argumentos a ~: ~"

#
# "Se han pasado demasiados argumentos a ~: ~" - lsg
#
# Me gusta más "entregado" que "pasado" - cll
#
#~ msgid "EVAL: too many arguments given to ~: ~"
#~ msgstr "EVAL: se han entregado demasiados argumentos a ~: ~"

#
# "EVAL: la lista de argumentos pasada a ~ es punteada: ~" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#~ msgid "EVAL: argument list given to ~ is dotted: ~"
#~ msgstr "EVAL: la lista de argumentos entregada a ~ está punteada: ~"

#
# "EVAL: la lista de argumentos pasada a ~ es punteada: ~" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#, fuzzy
#~ msgid "~: argument list given to ~ is dotted (terminated by ~)"
#~ msgstr "EVAL: la lista de argumentos entregada a ~ está punteada: ~"

#
# "Se han pasado demasiados argumentos a ~" - lsg
#
# Una vez más, me gusta más "entregar" que "pasar" - cll
#
#~ msgid "APPLY: too many arguments given to ~"
#~ msgstr "APPLY: se han entregado demasiados argumentos a ~"

#
# "APPLY: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Pues eso, que me gusta más "entregar" - cll
#
#~ msgid "APPLY: too few arguments given to ~"
#~ msgstr "APPLY: se han entregado pocos argumentos a ~"

#
# "el símbolo ~ no tiene valor asignado" - lsg
#
# En algún otro sitio ha aparecido algo parecido a esto. Verás, como me
# parece evidente que si un símbolo no tiene valor, es que no tiene
# valor asignado, pues prefiero omitir lo de "asignado" y evitar que el
# usuario lea términos innecesarios - cll
#
#, fuzzy
#~ msgid "~: symbol ~ has no value"
#~ msgstr "el símbolo ~ no tiene valor"

#, fuzzy
#~ msgid "~: assignment to constant symbol ~ is impossible"
#~ msgstr "no pueden realizarse asignaciones sobre el símbolo constante ~"

#
# "~: se ha invocado ~ con demasiados argumentos" - lsg
#
# a¡ Traducción brillantísima !!! Te ha quedado perfecto. Lo que yo había puesto:
#
# "~: se han entregado demasiados argumentos a ~"
#
# queda como más "indio". Tu traducción me encanta - cll
#
#~ msgid "~: too many arguments given to ~"
#~ msgstr "~: se ha invocado ~ con demasiados argumentos"

# Duda: tagbody es de muy difícil traducción.
#       Echando un ojo a la traducción en francés me he encontrado con que est
#       tal cual, ... De momento se queda así hasta que otros miembros del
#       equipo decidan cualquier otra cosa, ...
#
# No es que sepa lo que es, pero, si tag es etiqueta, tagbody podría ser
# "el cuerpo de la etiqueta" (¿tiene sentido esto?), con lo cual, una
# posibilidad sería (para simplificar) "el cuerpo de las etiquetas..." sv
#
# Otra de las propuestas a esta cuestión en la lista de correo
# es@li.org, ha sido: "el contenido de las etiquetas ~ ya ha sido
# abandonado". Esta traducción me gusta, ... cll
#
# ( Desafortunadamente, no recuerdo el nombre de la persona que lo
# sugirió, ... cll )
#
# "(~ ~): ya se ha salido del cuerpo de etiquetas ~" - lsg
#
# Debo rendirme a la evidencia, ... La propuesta de Leo, no solo para
# este término sino todos cuanto se refieren a la traducción de `tag' y
# `tagbody' es perfecta y, además, sigue los pasos de la de Santiago, de
# modo que "moción aceptada" :)
#
#~ msgid "(~ ~): the tagbody of the tags ~ has already been left"
#~ msgstr "(~ ~): ya se ha salido del cuerpo de etiquetas ~"

#~ msgid "~: there is no CATCHer for tag ~"
#~ msgstr "~: No hay ningún capturador (CATCH) para la etiqueta de salto ~"

#~ msgid "~: ~ is not a correct index into ~"
#~ msgstr "~: ~ no es un índice correcto en ~"

#~ msgid "undefined bytecode in ~ at byte ~"
#~ msgstr "Código de octeto ~ indefinido en el octeto ~"

#~ msgid "Corrupted STACK in ~ at byte ~"
#~ msgstr "Pila corrupta en ~ en el byte ~"

#~ msgid "~: ~ has no dynamic value"
#~ msgstr "~: ~ no tiene ningún valor dinámico"

#, fuzzy
#~ msgid "~: odd number of arguments: ~"
#~ msgstr "~ invocado con un número impar de argumentos: ~"

#~ msgid "dotted list given to ~ : ~"
#~ msgstr "lista punteada entregada a ~: ~"

#, fuzzy
#~ msgid "~: the special operator definition of ~ must not be removed"
#~ msgstr "~: no se debe desechar la definición de la forma especial de ~"

#~ msgid "~: doc-strings are not allowed here: ~"
#~ msgstr "~: aquí no se permiten cadenas de documentación: ~"

#~ msgid "~: illegal variable specification ~"
#~ msgstr "~: especificación inválida de variable ~"

#~ msgid "~: too many variables and/or declarations"
#~ msgstr "~: demasiadas variables y/o declaraciones"

#~ msgid "~: ~ is not a function specification"
#~ msgstr "~: ~ no es la especificación de una función"

#~ msgid "~: ~ is not a macro specification"
#~ msgstr "~: ~ no es la especificación de una macro"

#~ msgid "~: macro name ~ should be a symbol"
#~ msgstr "~: el nombre de la macro ~ debe ser un símbolo"

#, fuzzy
#~ msgid "~: ~ is not a function and macro specification"
#~ msgstr "~: ~ no es la especificación de una función"

#, fuzzy
#~ msgid "~: function and macro name ~ should be a symbol"
#~ msgstr "~: el nombre de la función ~ debe ser un símbolo"

#~ msgid "~: clause ~ should be a list"
#~ msgstr "~: la clausula ~ debe ser una lista"

#~ msgid "~: missing key list: ~"
#~ msgstr "~: falta la lista de claves: ~"

#~ msgid "~: the block named ~ has already been left"
#~ msgstr "~: el bloque de nombre ~ ya ha sido abandonado"

#~ msgid "~: no block named ~ is currently visible"
#~ msgstr "~: no hay ningún bloque visible con el nombre ~"

#~ msgid "~: ~ is neither tag nor form"
#~ msgstr "~: ~ no es ni una etiqueta de salto ni una forma"

#~ msgid "~: illegal tag ~"
#~ msgstr "~: etiqueta de salto inválida ~"

#~ msgid "~: tagbody for tag ~ has already been left"
#~ msgstr "~: ya se ha salido del cuerpo de etiquetas de ~"

#~ msgid "~: no tag named ~ is currently visible"
#~ msgstr "~: no hay ninguna etiqueta de salto visible con el nombre ~"

#~ msgid "~: too many values"
#~ msgstr "~: demasiados valores"

#~ msgid "~: too many arguments to ~"
#~ msgstr "~: se han entregado demasiados argumentos a ~"

#~ msgid "Argument ~ is not a macroexpansion environment"
#~ msgstr "El argumento ~ no es un entorno para la expansión de macros"

#~ msgid "declarations ~ are not allowed here"
#~ msgstr "las declaraciones ~ no están permitidas aquí"

#~ msgid "~: ~ evaluated to the values ~, not of type ~"
#~ msgstr "~: La forma ~ ha producido los valores ~, ninguno de los cuales es del tipo ~"

#~ msgid "~: bad declaration ~"
#~ msgstr "~: declaración incorrecta ~"

#~ msgid "no doc-strings allowed here: ~"
#~ msgstr "no se permite la utilización de cadenas de documentación aquí: ~"

#~ msgid "keyword argument list ~ has an odd length"
#~ msgstr "la lista de argumentos clave ~ tiene longitud impar"

#, fuzzy
#~ msgid ""
#~ "Illegal keyword/value pair ~, ~ in argument list.\n"
#~ "The allowed keywords are ~"
#~ msgstr "par argumento clave/valor inválido ~, ~ en la lista de argumentos. Los parámetros clave permitidos son ~"

#~ msgid "~: illegal ~ argument ~"
#~ msgstr "~: el argumento de ~ es inválido: ~"

#, fuzzy
#~ msgid "~: ~ is not a 1:1 encoding"
#~ msgstr "~: ~ no es un registro"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#
#~ msgid "~: host should be NIL or a string, not ~"
#~ msgstr "~: el anfitrión debe ser, o bien NIL, o una cadena, pero no ~"

#
# Duda: he traducido hostname por "nombre del `host'". ¿Qué os parece?
#
#~ msgid "~: illegal hostname ~"
#~ msgstr "~: nombre de anfitrión inválido ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#~ msgid "~: host should be NIL, not ~"
#~ msgstr "~: el anfitrión debe ser NIL, no ~"

#, fuzzy
#~ msgid "~: argument ~ should be a pathname designator ~"
#~ msgstr "~: el argumento ~ debe ser un flujo"

#~ msgid "~: filename for ~ is unknown"
#~ msgstr "~: el nombre de fichero de ~ es desconocido"

#~ msgid "~: there is no user named ~"
#~ msgstr "~: no hay ningún usuario con el nombre ~"

#~ msgid "~: there is no environment variable ~"
#~ msgstr "~: no hay ninguna variable de entorno ~"

#~ msgid "~: syntax error in filename ~ at position ~"
#~ msgstr "~: error de sintáxis en el nombre del fichero ~, en la posición ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#~ msgid "~: hosts ~ and ~ of ~ should coincide"
#~ msgstr "~: los anfitriones ~ y ~ de ~ deben coincidir"

#~ msgid "~: argument ~ is not a logical pathname, string, stream or symbol"
#~ msgstr "~: el argumento ~ no es un PATHNAME \"lógica\", una cadena de caracteres, un flujo o un símbolo"

#~ msgid "~: endless loop while resolving ~"
#~ msgstr "~: bucle infinito para ~"

#~ msgid "~: unknown logical host ~ in ~"
#~ msgstr "~: anfitrión ~ desconocido en ~"

#~ msgid "~: No replacement rule for ~ is known."
#~ msgstr "~: No se conoce ninguna regla de sustitución para ~."

#~ msgid "~: :VERSION-argument should be NIL or a positive fixnum or :WILD or :NEWEST, not ~"
#~ msgstr "~: el argumento :VERSION debe ser NIL, un número positivo del tipo fixnum, :WILD o :NEWEST pero no ~"

#~ msgid "~: :VERSION-argument should be NIL or :WILD or :NEWEST, not ~"
#~ msgstr "~: el argumento :VERSION debe ser o bien NIL, o :WILD o :NEWEST, pero no ~"

# Duda: Wildcard por comodín, ..., está bien, ¿no?
#
#~ msgid "wildcards are not allowed here: ~"
#~ msgstr "Aquí no están permitidos los comodines: ~"

#~ msgid "~: argument ~ should be ~, ~, ~, ~, ~, ~ or ~"
#~ msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#~ msgid "~: replacement pieces ~ do not fit into ~"
#~ msgstr "~: las piezas de intercambio ~ no caben en ~"

#~ msgid "~: ~ is not a specialization of ~"
#~ msgstr "~: ~ no es una especialización de ~"

#~ msgid "(~ ~ ~ ~) is ambiguous: ~"
#~ msgstr "(~ ~ ~ ~) es ambiguo: ~"

#~ msgid "nonexistent directory: ~"
#~ msgstr "directorio inexistente: ~"

#~ msgid "no directory ~ above ~"
#~ msgstr "no existe el directorio ~ bajo ~"

#~ msgid "\"..\\\\\" after \"...\\\\\" is invalid: ~"
#~ msgstr "\"..\\\\\" después de \"...\\\\\" es inválido: ~"

# Casi lo mismo. Bueno, al menos aquí hay dos puntos. sv
#
# Tienes razón. Ahora que veo este mensaje me lío a poner dos puntos en
# los mensajes anteriores. cll
#
#~ msgid "UNIX error while GETWD: ~"
#~ msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Si la tildecilla se sustituye por aquello que devolvió la orden GETWD,
# la frase resultante no tiene mucho sentido.
# Sugerencia: "La ejecución de GETWD en Unix devolvió ~" sv
#
# Hmmm, ..., podría ser, pero verás: en primer lugar, el texto que est
# asociado con la etiqueta "UNIX GETWD returned ~" es "UNIX error while
# GETWD" (fichero pathname.d, línea 6176); segundo, en CLisp se sigue la
# convención de colocar primero un mensaje y después, al final, aquello
# que originó el mensaje y, francamente, no quiero cambiar esta
# convención. Es decir, no quiero faltar al estilo original de los
# autores del programa. cll
#
# Por este motivo, creo que lo más conveniente es dejarlo como está. cll
#
#~ msgid "UNIX GETWD returned ~"
#~ msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Lo mismo. sv
#
# Lo mismo también ;) cll
#
#~ msgid "UNIX REALPATH returned ~"
#~ msgstr "Se produjo un error UNIX durante la ejecución de REALPATH: ~"

#~ msgid "~: ~ names a directory, not a file"
#~ msgstr "~: ~ es el nombre de un directorio, no de un fichero"

#~ msgid "no file name given: ~"
#~ msgstr "no se ha entregado ningún nombre de fichero: ~"

#~ msgid "not a directory: ~"
#~ msgstr "no es un directorio: ~"

#~ msgid "~: file ~ does not exist"
#~ msgstr "~: el fichero ~ no existe"

#~ msgid "~: pathname with type but without name makes no sense: ~"
#~ msgstr "~: un PATHNAME con tipo, pero sin nombre, no tiene ningún sentido: ~"

#~ msgid "cannot delete file ~ since there is file stream open to it"
#~ msgstr "no se puede borrar el fichero ~ puesto que hay un flujo abierto sobre el"

#~ msgid "cannot rename file ~ since there is file stream open to it"
#~ msgstr "no se puede renombrar el fichero ~ puesto que hay un flujo abierto sobre el"

#~ msgid "root directory not allowed here: ~"
#~ msgstr "el directorio raíz no está permitido aquí: ~"

# Duda: En este mensaje, el primer "~" se sustituye por el nombre de una
# función y el segundo "~" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#~ msgid "~ on ~ is illegal"
#~ msgstr "~ no es posible sobre el flujo ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#, fuzzy
#~ msgid "Return value ~ of call to ~ should be an integer between ~ and ~."
#~ msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

#~ msgid "~: the last character read from ~ was not ~"
#~ msgstr "~: el último carácter leído de ~ no era ~"

# Duda: A continuación vienen muchos mensajes que empiezan por "~ from
# ~". Para ayudar en su trabajo a quienes estén revisando este trabajo
# (no me canso de darte las gracias, Santiago, ..., y a quienes se
# animen) aclaro que el primer "~" se sustituye por el nombre de una
# función cuya evaluación (o ejecución, pero esto no es correcto en
# Lisp, ... se prefiere el término evaluación porque se está a nivel de
# intérprete) produce el error; el segundo "~" se refiere al nombre del
# flujo desde el cual se leyó dicha función. Luego, a continuación,
# viene el mensaje de error propiamente dicho.
#
# Por ejemplo, la siguiente instrucción en CLisp:
#
# > (read)
#
# ..., si se teclea:
#
# #<...>
#
# ..., produce el siguiente error: (en español, ya traducido)
#
# *** - READ en #<TERMINAL-STREAM>: los objetos escritos de la manera
# #<...> no pueden volverse a leer
#
# ¿De acuerdo?
#
# A continuación reproduzco un par de mails donde se explica el
# mecanismo general de estos mensajes, a propósito de la pregunta que
# puse en la lista de correo de CLisp:
#
# Mi pregunta fue:
#
# > 21. There are a few messages which begin with "~ from ~". They are
# > very easy to translate but they use a lot of prepositions, and words
# > that could be translated in masculine or feminine. So, I need some
# > real examples of their use.
#
# Las respuestas fueron:
#
#
# ---------------------------------------------------------------------------
# Look in io.d:
#     { pushSTACK(*stream_); # Wert fu:r Slot STREAM von STREAM-ERROR
#       pushSTACK(ch); # Character
#       pushSTACK(*stream_); # Stream
#       pushSTACK(S(read));
#       //: DEUTSCH "~ von ~: Gelesenes Zeichen ist kein String-Char: ~"
#       //: ENGLISH "~ from ~: character read should be a string-char: ~"
#       //: FRANCAIS "~ de ~ : le caracte!re lu n'est pas de type STRING-CHAR."
# The first ~ is the function name, the second the stream that was being
# read from or written to and the third is the character that was read/written.
#
# So it says something like "READ from #<STREAM ...>: illegal character"
#
# 						(Joerg Hoehle)
#
# ---------------------------------------------------------------------------
# A general question here: I thought gettext was coming with an Emacs
# mode called "po-mode", which helps you in translating the messages.
# In particular, there are keystroke commands for showing the C/Lisp source
# surrounding the original reference to a message. From this context,
# you should at least be able to guess the meaning of the objects which
# are substituted for the ~. Note, however, that the first ~ corresponds
# the last pushSTACK command before the string, the second ~ to the
# second-to-last pushSTACK command etc.
#
# 						(Bruno Haible)
#
# ---------------------------------------------------------------------------
#
#~ msgid "~ from ~ without ~ before it"
#~ msgstr "~ en ~ sin ~ antes de él"

#~ msgid "~: cannot output to ~"
#~ msgstr "~: no se puede escribir en ~"

#, fuzzy
#~ msgid "~: cannot output ~ into ~, not of type ~"
#~ msgstr "~: no se puede escribir en ~"

#~ msgid "integer ~ is out of range, cannot be output onto ~"
#~ msgstr "el entero ~ está fuera del dominio, no puede imprimirse en ~"

#, fuzzy
#~ msgid "~: argument ~ should be an input stream"
#~ msgstr "~: el argumento ~ debe ser un flujo"

#, fuzzy
#~ msgid "~: argument ~ should be an output stream"
#~ msgstr "~: el argumento ~ debe ser un flujo"

#, fuzzy
#~ msgid "~: argument should be a symbol, not ~"
#~ msgstr "~: el argumento debe ser una cadena de caracteres, no ~"

#~ msgid "~ is beyond the end because the string ~ has been adjusted"
#~ msgstr "~ está más allá del final porque la cadena ~ ha sido ajustada"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#, fuzzy
#~ msgid "~: ~ is not a string input stream"
#~ msgstr "~: ~ no es un flujo de entrada con buffer"

#, fuzzy
#~ msgid "~: ~ argument must be a subtype of ~, not ~"
#~ msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#, fuzzy
#~ msgid "~: ~ is not a string output stream"
#~ msgstr "~: ~ no es un flujo de entrada con buffer"

# Duda: He traducido `fill pointer' por "puntero de relleno". En
# realidad, los `fill-pointer' son exactamente, eso:
#
# "The fill pointer constitutes the "active length" of the vector; all
# vector elements whose index is less than the fill pointer are active,
# and the others are inactive." (Guy L. Steele, Jr; Common Lisp, The
# Language - 2nd Edition; pag. 454).
#
#~ msgid "~: argument ~ should be a string with fill pointer"
#~ msgstr "~: El argumento ~ debe ser una cadena con un puntero de relleno"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#~ msgid "~: ~ is not a buffered input stream"
#~ msgstr "~: ~ no es un flujo de entrada con buffer"

#~ msgid "~: stream must be a generic-stream, not ~"
#~ msgstr "~: el flujo debe ser un `generic-stream', no ~"

#~ msgid "~: Ctrl-C: User break"
#~ msgstr "~: Ctrl-C: Interrupción del usuario"

#, fuzzy
#~ msgid "unknown character set ~"
#~ msgstr "Registro desconocido: ~S"

#~ msgid "Closed ~ because disk is full."
#~ msgstr "Se ha cerrado ~ porque el disco está lleno."

#~ msgid "cannot position ~ beyond EOF"
#~ msgstr "no es posible colocarse en ~ más allá de EOF"

# Duda: lo del fichero `regular' por `normal'. De hecho, yo juraría que
# en la asignatura de Sistemas Operativos, en mi Facultad, los
# llamábamos "ficheros normales". ¿Qué tal os suena?.
#
#, fuzzy
#~ msgid "~: argument ~ ~ was specified, but ~ is not a regular file."
#~ msgstr "~: ~ no es un fichero normal."

# Duda: aqui he traducido de la version francesa (no se frances, pero
# por lo que parece que pone, ...)
#
#~ msgid "file ~ is not an integer file"
#~ msgstr "el fichero ~ no tiene el formato de un fichero de enteros"

#, fuzzy
#~ msgid "Return value ~ of call to ~ is not a list."
#~ msgstr "El valor de ~ no es un flujo: ~"

#, fuzzy
#~ msgid "Return value ~ of call to ~ contains ~ which is not a ~."
#~ msgstr "El valor de ~ no es un flujo: ~"

#~ msgid "~: argument ~ should be a window stream"
#~ msgstr "~: el argumento ~ debe ser un WINDOW-STREAM"

#~ msgid "terminal type ~ unknown to termcap"
#~ msgstr "No existe ninguna entrada para el tipo de terminal ~ en termcap"

#~ msgid "~: package SCREEN is not implemented"
#~ msgstr "~: el paquete SCREEN no está implementado"

# Duda: he dejado `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#~ msgid "host should be string, not ~"
#~ msgstr "el anfitrión debe ser una cadena de caracteres y no ~"

# Duda: Pues otra vez como siempre, ..., he dejado `display' tal
# cual. Pienso que todo el mundo sabe lo que es un `display' ¿no?
#
# Por otra parte (como ya sucedió en un mensaje anterior), ..., `fixnum'
# por ser el nombre de un subtipo (o tipo, si se quiere) en Lisp, est
# sin traducir, ...
#
#~ msgid "display should be a nonnegative fixnum, not ~"
#~ msgstr "el `display' debe ser un entero del tipo FIXNUM >=0, y no ~"

#~ msgid "~: stream must be a socket-stream, not ~"
#~ msgstr "~: el flujo debe ser un `socket-stream' y no ~"

#~ msgid "~: argument ~ should be a vector of type (ARRAY (UNSIGNED-BYTE 8) (*))"
#~ msgstr "~: el argumento ~ debe ser un vector del tipo (ARRAY (UNSIGNED-BYTE 8) (*)) "

#~ msgid "~: input stream ~ has reached its end"
#~ msgstr "~: el flujo de entrada ~ ha alcanzado su final"

#, fuzzy
#~ msgid "~: ~ is not a ~"
#~ msgstr "~: ~ no es un par"

#, fuzzy
#~ msgid "~: argument ~ is neither an open SOCKET-STREAM nor a positive FIXNUM"
#~ msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#, fuzzy
#~ msgid "~: argument ~ is not an open SOCKET-STREAM"
#~ msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#~ msgid "~: argument ~ is not a SOCKET-STREAM"
#~ msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#, fuzzy
#~ msgid "~: argument ~ is not an open stream"
#~ msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#, fuzzy
#~ msgid "~: list ~ is too long (~ maximum)"
#~ msgstr "~: la secuencia ~ es demasiado larga"

#, fuzzy
#~ msgid "~: argument ~ should be of type ~."
#~ msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#, fuzzy
#~ msgid "Invalid direction ~ for accessing ~"
#~ msgstr "Sintaxis inválida en la forma ~S: ~S."

#, fuzzy
#~ msgid "~: ~ should be a handle, handle stream, or one of ~, ~, ~"
#~ msgstr "~S: ~S debe ser una expresión lambda"

#~ msgid "The value of ~ is not a stream: ~"
#~ msgstr "El valor de ~ no es un flujo: ~"

#~ msgid "The value of ~ is not an appropriate stream: ~"
#~ msgstr "El valor de ~ no es un flujo apropiado: ~"

#, fuzzy
#~ msgid "The value of ~ was not an appropriate stream: ~. It has been changed to ~."
#~ msgstr "El valor de ~ no era un flujo: ~. Ha sido cambiado por ~."

#, fuzzy
#~ msgid "~: The ~ of ~ cannot be changed from ~ to ~."
#~ msgstr "~: ~ no puede convertirse al tipo ~"

#, fuzzy
#~ msgid "Return value ~ of call to ~ is not a string."
#~ msgstr "El valor de ~ no es un flujo: ~"

#, fuzzy
#~ msgid "~: illegal endianness argument ~"
#~ msgstr "~: el argumento de ~ es inválido: ~"

#, fuzzy
#~ msgid "~: argument ~ does not contain a valid OS stream handle"
#~ msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#, fuzzy
#~ msgid "~: ~: stream of wrong direction"
#~ msgstr "~: ~ no es una función"

#, fuzzy
#~ msgid "~ is not a ~, cannot be output onto ~"
#~ msgstr "~ no es un entero, no puede escribirse en ~"

#, fuzzy
#~ msgid "~: argument ~ is not an open file stream"
#~ msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#, fuzzy
#~ msgid "~: position argument should be ~ or ~ or a nonnegative integer, not ~"
#~ msgstr "~: el argumento de posición debe ser ~, ~ o un número no negativo del tipo FIXNUM, pero no ~"

#~ msgid "The value of ~ was not a readtable. It has been reset."
#~ msgstr "El valor de ~ no es una tabla de lectura. Ha sido inicializado/a."

#, fuzzy
#~ msgid "~: argument ~ is not a ~"
#~ msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
# Al final, por iniciativa de Leo, he cambiado `# macro carácter', que
# no me gustaba demasiado por `macro carácter secundario', que me parece
# mucho mejor. - cll
#
#~ msgid "~: ~ is a dispatch macro character"
#~ msgstr "~: ~ es un macro carácter secundario"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#~ msgid "~: ~ is not a dispatch macro character"
#~ msgstr "~: ~ no es un macro carácter secundario"

#~ msgid "~: digit $ not allowed as sub-char"
#~ msgstr "~: el dígito $ no está permitido como un sub-carácter"

#~ msgid "~: new value ~ should be ~, ~, ~ or ~."
#~ msgstr "~: el nuevo valor ~ debe ser ~, ~, ~ o ~."

#~ msgid ""
#~ "The value of ~ should be an integer between 2 and 36, not ~.\n"
#~ "It has been reset to 10."
#~ msgstr ""
#~ "El valor de ~ debe ser un entero entre 2 y 36, no ~.\n"
#~ "Ha sido inicializado a 10."

#~ msgid "~: input stream ~ ends within an object. Last opening parenthesis probably in line ~."
#~ msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto. El último paréntesis abierto es, probablemente, el de la línea ~."

#~ msgid "~: input stream ~ ends within an object"
#~ msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto"

#~ msgid "~ from ~: illegal character ~"
#~ msgstr "~ en ~: carácter inválido ~"

#
# Duda: Lo mismo de antes, he dejado `token' sin traducir
#
#~ msgid "~: input stream ~ ends within a token after single escape character"
#~ msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape simple"

#
# Duda: A ver, ¿la palabra `token'?
#       Mientras no se os ocurra algo mejor, lo he dejado en inglés, ...
#
#~ msgid "~: input stream ~ ends within a token after multiple escape character"
#~ msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape múltiple"

#~ msgid "~ from ~: ~ has no macro character definition"
#~ msgstr "~ en ~: ~ no tiene ninguna definición de macro carácter"

#~ msgid "~ from ~: macro character definition for ~ may not return ~ values, only one value."
#~ msgstr "~ en ~: la definición del macro carácter para ~ no puede devolver ~ valores, sólo puede ser uno."

#~ msgid "~ from ~: dispatch macro character definition for ~ after ~ may not return ~ values, only one value."
#~ msgstr "~ en ~: la definición del macro carácter secundario de ~ después de ~ sólo puede devolver un valor, no ~"

# Duda: He traducido `token' tal cual, ... Santiago, imagino que la
# palabra token se queda tal cual. Quiero decir, ¿es necesario lo de las
# comillas? - cll
#
#~ msgid "~ from ~: a token consisting only of dots cannot be meaningfully read in"
#~ msgstr "~ en ~: no puede leerse correctamente un `token' que consiste únicamente en puntos"

# Duda: Todo el mundo sabe que `colon' es el signo de dos puntos
# `:'. Bueno, pues la traducción del siguiente mensaje podría ser algo
# del estilo: "demasiados signos de dos puntos en el token ...", sin
# embargo, me ha parecido mejor poner los dos puntos directamente, ...
#
#~ msgid "~ from ~: too many colons in token ~"
#~ msgstr "~ en ~: demasiados `:' en el `token' ~"

#~ msgid "~ from ~: there is no package with name ~"
#~ msgstr "~ en ~: no existe ningún paquete con el nombre ~"

#~ msgid "~ from ~: ~ has no external symbol with name ~"
#~ msgstr "~ en ~: ~ no tiene ningún símbolo externo con el nombre ~"

#~ msgid "~ from ~: token \".\" not allowed here"
#~ msgstr "~ en ~: el `token' \".\" no está permitido aquí"

#~ msgid "~: the value of ~ has been arbitrarily altered"
#~ msgstr "~: el valor de ~ ha sido arbitrariamente alterado"

#~ msgid "~: no entry for ~ from ~ in ~ = ~"
#~ msgstr "~: no existe ninguna entrada para ~ de ~ en ~ = ~"

#~ msgid "~ from ~: illegal end of dotted list"
#~ msgstr "~ en ~: fin de lista punteada inválido"

#~ msgid "~ from ~: an object cannot start with ~"
#~ msgstr "~ en ~: un objeto no puede comenzar por ~"

#~ msgid "~: input stream ~ ends within a string"
#~ msgstr "~: el flujo de entrada ~ termina con una cadena"

#~ msgid "~ from ~: no number allowed between # and $"
#~ msgstr "~ en ~: no debe haber ningún número entre # y $"

#~ msgid "~: input stream ~ ends within a comment #$ ... $#"
#~ msgstr "~: el flujo de entrada ~ termina dentro un comentario #$ ... $#"

#, fuzzy
#~ msgid "~ from ~: font number ~ for character is too large, should be = 0"
#~ msgstr "~ en ~: el número ~ para la fuente de caracteres es demasiado grande, debe ser < ~"

#~ msgid "~ from ~: there is no character with name ~"
#~ msgstr "~ en ~: no hay ningún carácter con el nombre ~"

#~ msgid "~ from ~: token ~ after #$ is not a rational number in base ~"
#~ msgstr "~ en ~: el `token' ~ después de #$ no es un número racional en base ~"

#~ msgid "~ from ~: the number base must be given between # and R"
#~ msgstr "~ en ~: el número de la base debe estar entre # y R"

#~ msgid "~ from ~: The base ~ given between # and R should lie between 2 and 36"
#~ msgstr "~ en ~: La base ~ entre # y R debe estar entre 2 y 36"

#~ msgid "~ from ~: bad syntax for complex number: #C~"
#~ msgstr "~ en ~: sintaxis incorrecta del número complejo: #C~"

#~ msgid "~ from ~: token expected after #:"
#~ msgstr "~ en : ~: se esperaba un `token' después de #:"

#~ msgid "~ from ~: token ~ after #: should contain no colon"
#~ msgstr "~ en ~: el `token' ~ después de #: no debe contener dos puntos"

#~ msgid "~ from ~: only zeroes and ones are allowed after #*"
#~ msgstr "~ en ~: sólo se permiten ceros y unos después de #*"

#~ msgid "~ from ~: bit vector is longer than the explicitly given length ~"
#~ msgstr "~ en ~: la longitud del vector de bits es mayor que la longitud explícitamente indicada ~"

#~ msgid "~ from ~: must specify element of bit vector of length ~"
#~ msgstr "~ en ~: debe especificar un elemento para el vector de bits de longitud ~"

#~ msgid "~ from ~: vector is longer than the explicitly given length ~"
#~ msgstr "~ en ~: el vector tiene una longitud mayor que la explícitamente indicada ~"

#~ msgid "~ from ~: must specify element of vector of length ~"
#~ msgstr "~ en ~: debe especificar un elemento para el vector de longitud ~"

#~ msgid "~ from ~: bad syntax for array: #A~"
#~ msgstr "~ en ~: sintaxis incorrecta en la matriz: #A~"

#~ msgid "~ from ~: ~ = ~ does not allow the evaluation of ~"
#~ msgstr "~ en ~: ~ = ~ no permite la evaluación de ~"

#~ msgid "~ from ~: a number must be given between # and $"
#~ msgstr "~ en ~: debe indicarse un número entre # y $"

#~ msgid "~ from ~: label #~? too large"
#~ msgstr "~ en ~: la etiqueta #~? es demasiado grande"

# Duda: En Common Lisp existe lo que se denominan "Listas de asociación"
# (Common Lisp, The Language, 2nd Edition - Guy L. Steel, página 431) o,
# en inglés, "Association Lists" que abreviadamente se conocen como
# "alist" o "a-list". En realidad, aunque en español, mucha gente dice
# "alistas", esto no me parece correcto y me parece mucho más formal
# decir "listas de asociación".
#
# De hecho, el término "listas de asociación" será facílisimamente
# reconocible por el programador, mientras que "alista" exige estar un
# poquito más experimentado con el Lisp.
#
# Más aún, los traductores del libro "Lisp" (3ra edición) de Winston y
# Horn, utilizan la expresión "lista de asociación" en la presentación
# de la función ASSOC en la página 34, aunque luego también se refieran
# a ellas como "listas-a".
#
#~ msgid "~ from ~: the value of ~ has been altered arbitrarily, it is not an alist: ~"
#~ msgstr "~ en ~: el valor de ~ ha sido modificado arbitrariamente, no es una lista de asociación: ~"

#~ msgid "~ from ~: label #~= may not be defined twice"
#~ msgstr "~ en ~: la etiqueta #~= no puede definirse dos veces"

#~ msgid "~ from ~: #~= #~# is illegal"
#~ msgstr "~ en ~: #~= #~# no está permitido"

#~ msgid "~ from ~: undefined label #~#"
#~ msgstr "~ en ~: la etiqueta #~# no está definida"

#~ msgid "~ from ~: objects printed as #<...> cannot be read back in"
#~ msgstr "~ en ~: los objetos escritos de la manera #<...> no pueden volverse a leer"

#~ msgid "~ from ~: objects printed as # in view of ~ cannot be read back in"
#~ msgstr "~ en ~: los objetos escritos como # a causa de ~ no pueden volverse a leer"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#~ msgid "~ from ~: illegal feature ~"
#~ msgstr "~ en ~: propiedad inválida ~"

#~ msgid "~ from ~: #S must be followed by the type and the contents of the structure, not ~"
#~ msgstr "~ en ~: #S debe estar seguido del tipo y contenidos de la estructura, no ~"

#~ msgid "~ from ~: the type of a structure should be a symbol, not ~"
#~ msgstr "~ en ~: el tipo de una estructura debe ser un símbolo, no ~"

#~ msgid "~ from ~: bad ~"
#~ msgstr "~ en ~: ~ es incorrecto"

#~ msgid "~ from ~: bad ~ for ~"
#~ msgstr "~ en ~: ~ es incorrecto en ~"

#~ msgid "~ from ~: structures of type ~ cannot be read in, missing constructor function"
#~ msgstr "~ en ~: las estructuras del tipo ~ no pueden leerse, no se conoce la función de construcción"

#~ msgid "~ from ~: a structure ~ may not contain a component \".\""
#~ msgstr "~ en ~: una estructura ~ no debe contener un componente \".\""

#~ msgid "~ from ~: ~ is not a symbol, not a slot name of structure ~"
#~ msgstr "~ en ~: ~ no es un símbolo, ni el nombre de una ranura ni una estructura ~"

#~ msgid "~ from ~: missing value of slot ~ in structure ~"
#~ msgstr "~ en ~: falta el valor de la ranura ~ en la estructura ~"

#
# Duda: slots se queda tal cual, ...
#
# De acuerdo con la lista spanglish, `slot' se traducirá, en todo el
# CLisp, como "ranura".
#
#~ msgid "~ from ~: too many slots for structure ~"
#~ msgstr "~ en ~: hay demasiadas ranuras en la estructura ~"

#
# "~ en ~: sintaxis inválida del vector de código de recinto tras #~Y" - lsg
#
# Hmmm, no me acaba de gustar, ... - cll
#
#~ msgid "~ from ~: illegal syntax of closure code vector after #~Y"
#~ msgstr "~ en ~: sintaxis inválida del vector de código de la cerradura después de #~Y"

#~ msgid "~ from ~: object #Y~ has not the syntax of a compiled closure"
#~ msgstr "~ en ~: el objeto #Y~ no tiene la sintaxis de una cerradura compilada"

#
# pathname NO es array!
# "~ en ~: sintaxis incorrecta en nombre de path: #A~" - lsg
#
# Si, es verdad, aquí se me había ido la mano, ...
#
# Además, PATHNAME no se traduce puesto que, o bien se refiere al tipo
# de datos PATHNAME o a la función PATHNAME (en este caso, al tipo de
# datos). Como ambos términos están definidos en el estándar de Common
# Lisp: Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr., pues
# no se traduce y se pone en mayúsculas para distinguirlo de otros
# términos. - cll
#
#~ msgid "~ from ~: bad syntax for pathname: #P~"
#~ msgstr "~ en ~: la sintaxis del PATHNAME: #P~ es incorrecta"

# Nota: El siguiente mensaje se debe a la función PEEK-CHAR (Common
# Lisp, The Language - 2nd Edition; Guy L. Steele, Jr; pag. 574), que
# realiza la lectura del siguiente objeto de un flujo de caracteres
# según el valor de su primer argumento opcional `peek-type' que solo
# puede valer, como reza el mensaje, NIL, T o un carácter.
#
#~ msgid "~: peek type should be NIL or T or a character, not ~"
#~ msgstr "~: el tipo del PEEK solo puede ser NIL, T o un carácter, y no ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#~ msgid "~: ~ argument should be an integer between 2 and 36, not ~"
#~ msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

# "~: la cadena ~ no tiene sintaxis de entero" - lsg
#
# He cambiado lo "de entero" por "de un número entero", que parece más
# inteligible - cll
#
#, fuzzy
#~ msgid "~: substring ~ does not have integer syntax at position ~"
#~ msgstr "~: la cadena ~ no tiene la sintaxis de un número entero"

#, fuzzy
#~ msgid "~: Despite ~, ~ cannot be printed readably."
#~ msgstr "~: A pesar de ~, ~ no puede imprimirse de manera legible."

#~ msgid ""
#~ "~: the value ~ of ~ is neither ~ nor ~ nor ~.\n"
#~ "It is reset to ~."
#~ msgstr ""
#~ "~: el valor ~ de ~ no es ~ ni ~ ni ~.\n"
#~ "Ha sido inicializado a ~."

#~ msgid "~: must be a positive integer or NIL, not ~"
#~ msgstr "~: debe ser un número positivo entero o NIL, pero no ~"

# "~: espacio insuficiente en la pila para realizar un análisis de circularidad" - lsg
#
# Vale - cll
#
#~ msgid "~: not enough stack space for carrying out circularity analysis"
#~ msgstr "~: no hay espacio suficiente en la pila para realizar un análisis de circularidad"

#~ msgid "~: bad ~"
#~ msgstr "~: incorrecto ~"

#~ msgid "~: an unknown record type has been generated!"
#~ msgstr "~: se ha generado un tipo de registro desconocido!"

#, fuzzy
#~ msgid "~: argument ~ is too large"
#~ msgstr "~: el argumento ~ no es un string"

#, fuzzy
#~ msgid "~: argument ~ should be ~ or ~."
#~ msgstr "~: el argumento ~ debe ser un flujo"

#, fuzzy
#~ msgid "~: argument ~ should be ~, ~, ~ or ~."
#~ msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

# "~: ~ no es una formación" - lsg
#
# Aunque en la lista de spanglish.txt pone "formación", en este caso
# creo que será mucho más conveniente poner "matriz" porque de hecho,
# los mensajes se refieren a matrices, ... - cll
#
#~ msgid "~: ~ is not an array"
#~ msgstr "~: ~ no es una matriz"

#~ msgid "~: got ~ subscripts, but ~ has rank ~"
#~ msgstr "~: se encontraron ~ subíndices, pero ~ tiene rango ~"

#~ msgid "~: subscripts ~ for ~ are not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
#~ msgstr "~: los subíndices ~ de ~ no son del tipo '(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#~ msgid "~: subscripts ~ for ~ are out of range"
#~ msgstr "~: los subíndices ~ de ~ han excedido el rango"

#~ msgid "~: index ~ for ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
#~ msgstr "~: el índice ~ de ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#~ msgid "~: index ~ for ~ is out of range"
#~ msgstr "~: el índice ~ de ~ ha excedido el rango"

#, fuzzy
#~ msgid "~: cannot store values in an array of element type NIL"
#~ msgstr "~: ~ no puede convertirse al tipo ~"

#, fuzzy
#~ msgid "~: cannot access values of an array of element type NIL"
#~ msgstr "~: ~ no puede convertirse al tipo ~"

#~ msgid "~: ~ does not fit into ~, bad type"
#~ msgstr "~: ~ no cabe en ~, tipo incorrecto"

#, fuzzy
#~ msgid "~: ~ cannot be stored in an array of element type NIL"
#~ msgstr "~: ~ no puede convertirse al tipo ~"

#~ msgid "~: ~ is not an nonnegative integer less than the rank of ~"
#~ msgstr "~: ~ no es un entero no negativo menor que el rango de ~"

#~ msgid "~: ~ is not an array of bits"
#~ msgstr "~: ~ no es una matriz de bits"

#~ msgid "~: The arguments ~ and ~ should be arrays of bits with the same dimensions"
#~ msgstr "~: Los argumentos ~ y ~ deben ser matrices de bits de la misma dimensión"

#~ msgid "~: The arguments ~, ~ and ~ should be arrays of bits with the same dimensions"
#~ msgstr "~: Los argumentos ~, ~ y ~ deben ser matrices de bits de la misma dimensión"

#~ msgid "~: vector ~ has no fill pointer"
#~ msgstr "~: el vector ~ no tiene ningún puntero de relleno"

#~ msgid "~: ~ has length zero"
#~ msgstr "~: ~ tiene longitud nula"

#~ msgid "~: extending the vector by ~ elements makes it too long"
#~ msgstr "~: ampliar el vector en ~ elementos, lo hace muy grande"

#~ msgid "~ works only on adjustable arrays, not on ~"
#~ msgstr "~ funciona sólo con matrices ajustables, no con ~"

#~ msgid "~: extension ~ should be a positive fixnum"
#~ msgstr "~: la extensión ~ debe ser un número positivo del tipo FIXNUM"

#~ msgid "~: cannot push ~ into array ~ (bad type)"
#~ msgstr "~: no se puede introducir ~ en la matriz ~ (tipo incorrecto)"

#~ msgid "~: dimension ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
#~ msgstr "~: la dimensión ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#~ msgid "~: dimensions ~ produce too large total-size"
#~ msgstr "~: las dimensiones ~ producen un tamaño total demasiado grande"

#~ msgid "~: ambiguous, more than one initialization specified"
#~ msgstr "~: ambiguo, se ha especificado más de una inicialización"

#~ msgid "~: the initial-element ~ is not of type ~"
#~ msgstr "~: el INITIAL-ELEMENT ~ no es del tipo ~"

#~ msgid "~: ~ is of incorrect length"
#~ msgstr "~: ~ no tiene la longitud correcta"

#~ msgid "~: ~-argument ~ is not an array"
#~ msgstr "~: El ~ argumento ~ no es una matriz"

#~ msgid "~: ~-argument ~ does not have element type ~"
#~ msgstr "~: El ~ argumento ~ no tiene como tipo de elemento ~"

#~ msgid "~: ~-argument ~ is not of type `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"
#~ msgstr "~: El ~ argumento ~ no es del tipo `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"

#~ msgid "~: array-total-size + displaced-offset (= ~) exceeds total size ~ of ~-argument"
#~ msgstr "~: array-total-size + displaced-offset (= ~) excede el tamaño total ~ del ~ argumento"

#~ msgid "~: fill-pointer ~ should be a nonnegative fixnum"
#~ msgstr "~: El puntero de relleno ~ debe ser un número no negativo del tipo FIXNUM"

#~ msgid "~: fill-pointer argument ~ is larger than the length ~"
#~ msgstr "~: El argumento FILL-POINTER ~ es mayor que la longitud ~"

#
# "~: el rango intentado ~ es demasiado grande" - lsg
#
# De acuerdo - cll
#
#~ msgid "~: attempted rank ~ is too large"
#~ msgstr "~: el rango intentado ~ es demasiado grande"

#~ msgid "~: ~ may not be specified for an array of rank ~"
#~ msgstr "~: ~ no debe especificarse para una matriz de rango ~"

#~ msgid "~: rank ~ of array ~ cannot be altered: ~"
#~ msgstr "~: no es posible cambiar el rango ~ de la matriz ~: ~"

#
# "~: los elementos de la formación ~ no son de tipo ~" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#~ msgid "~: array ~ does not have element-type ~"
#~ msgstr "~: los elementos de la matriz ~ no son del tipo ~"

#~ msgid "~: cannot displace array ~ to itself"
#~ msgstr "~: no se puede desplazar la matriz ~ hacia ella misma"

#~ msgid "~: array ~ has no fill-pointer"
#~ msgstr "~: la matriz ~ no tiene ningún puntero de relleno"

#~ msgid "~: the fill-pointer of array ~ is ~, greater than ~"
#~ msgstr "~: el puntero de relleno de la matriz ~ es ~ que es mayor que ~"

# ... de la misma forma que uno no pone "START Índice" sv
#
# Si, si, ..., tienes toda la razón, ... cll
#
#~ msgid "Illegal START index ~ for ~"
#~ msgstr "Índice START ~ inválido en ~"

#~ msgid "Illegal END index ~ for ~"
#~ msgstr "Índice END ~ inválido en ~"

#~ msgid "~: invalid bit-vector length ~"
#~ msgstr "~: la longitud de BIT-VECTOR ~ es inválida"

# Duda: hash lo he traducido por hash. ¿Alguna sugerencia? ¿Tablas de
# acceso rápido, o algo así?. Tened en cuenta que en Common Lisp, las
# tablas hash son una estructura bien definida que cuenta con sus
# propias instrucciones. A mí me gusta tal cual, ...
# Sugerencia: tabla de `hash'. sv
#
# No, no, no, no, ... :) `hash table' es `tabla hash'. Si se quiere,
# podríamos traducir la palabra `hash' pero si se deja es `tabla
# hash'. Todos los informáticos las llamamos así. Jamás he oído `Tabla
# *de* hash' cll
#
#~ msgid "Hash table size ~ too large"
#~ msgstr "La tabla hash ~ es demasiado grande"

#
# "error interno al redimensionar ~" - lsg
#
# Me gusta, salvo que el error ocurre "durante" - cll
#
#~ msgid "internal error occured while resizing ~"
#~ msgstr "error interno durante el redimensionamiento de ~"

#, fuzzy
#~ msgid "~: argument ~ should be ~, ~, ~, ~ or ~."
#~ msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#, fuzzy
#~ msgid "~: ~ argument should be a fixnum >=0, not ~"
#~ msgstr "~ : El argumento debe ser del tipo FIXNUM >=0 y no ~"

#, fuzzy
#~ msgid "~: ~ argument should be an integer or a float > 1, not ~"
#~ msgstr "~: el argumento debe ser un entero, no ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#, fuzzy
#~ msgid "~: ~ argument should be a real between 0 and 1, not ~"
#~ msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

#~ msgid "~: internal error while building ~"
#~ msgstr "~: error interno durante la construcción de ~"

#, fuzzy
#~ msgid "~: argument ~ is not a hash table"
#~ msgstr "~: el argumento ~ no es un carácter"

#~ msgid "~: ~ is not a pair"
#~ msgstr "~: ~ no es un par"

#~ msgid "~: lists ~ and ~ are not of same length"
#~ msgstr "~: las listas ~ y ~ no son de la misma longitud"

#~ msgid "~: start index ~ too large for ~"
#~ msgstr "~: el índice :START ~ es demasiado grande para ~"

#~ msgid "~: end index ~ too large for ~"
#~ msgstr "~: el índice :END ~ es demasiado grande para ~"

#~ msgid "symbol ~ cannot be deleted from symbol table"
#~ msgstr "el símbolo ~ no puede ser borrado de la tabla de símbolos"

#~ msgid "~ inconsistent: symbol ~ is a shadowing symbol but not present"
#~ msgstr "inconsistencia en ~: el símbolo ~ es un símbolo que eclipsa a otro/s, sin embargo no está presente."

#, fuzzy
#~ msgid ""
#~ "Uninterning ~ from ~ uncovers a name conflict.\n"
#~ "You may choose the symbol in favour of which to resolve the conflict."
#~ msgstr "Puede elegir el símbolo en favor del cual se resolverá el conflicto."

#, fuzzy
#~ msgid "Importing ~ into ~ produces a name conflict with ~ and other symbols."
#~ msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S y otros símbolos."

#, fuzzy
#~ msgid "Importing ~ into ~ produces a name conflict with ~."
#~ msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S."

#~ msgid "UNEXPORT in ~ is illegal"
#~ msgstr "UNEXPORT en ~ es inválido"

#
# "UNEXPORT sólo funciona con símbolos accesibles, no con ~ en ~" - lsg
#
# Ya, o sea, que cambie "sobre" por "con". Vale, me gusta mucho más tu
# mensaje que el mío - cll
#
#~ msgid "UNEXPORT works only on accessible symbols, not on ~ in ~"
#~ msgstr "UNEXPORT sólo funciona sobre símbolos accesibles, no con ~ en ~"

#, fuzzy
#~ msgid "~: Symbol ~ should be imported into ~ before being exported."
#~ msgstr "el símbolo ~S debe ser importado a ~S antes de ser exportado."

#
# El segundo from deberia ser 'de', porque quiere decir que un símbolo
# a de un paquete A entra en conflicto con el símbolo b _del_ paquete
# B. Luego, debe ser 'de'.
#
#, fuzzy
#~ msgid ""
#~ "Exporting ~ from ~ produces a name conflict with ~ from ~.\n"
#~ "You may choose which symbol should be accessible in ~."
#~ msgstr "la exportación de ~S desde ~S produce un conflicto de nombres con ~S de ~S."

#, fuzzy
#~ msgid ""
#~ "(~ ~ ~): ~ name conflicts remain\n"
#~ "Which symbol with name ~ should be accessible in ~?"
#~ msgstr "¿ Qué símbolo con nombre ~S debe ser accesible en ~S ?"

#~ msgid "The value of *PACKAGE* was not a package. Old value ~. New value ~."
#~ msgstr "El valor de *PACKAGE* no era un paquete. Valor anterior ~. Nuevo valor ~."

#, fuzzy
#~ msgid "~: Package ~ has been deleted."
#~ msgstr "El paquete ~ ha sido borrado."

#~ msgid "~: argument should be a package or a package name, not ~"
#~ msgstr "~: el argumento debe ser un paquete o el nombre de un paquete, no ~"

#~ msgid "~: there is already a package named ~"
#~ msgstr "~: ya hay un paquete llamado ~"

#
# "~: el argumento debe ser un símbolo o una lista de símbolos, no ~" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#~ msgid "~: argument should be a symbol or a list of symbols, not ~"
#~ msgstr "~: el argumento debe ser un símbolo o una lista de símbolos, no ~"

#, fuzzy
#~ msgid "~: a package with name ~ already exists."
#~ msgstr "ya existe un paquete con el nombre ~S."

#~ msgid "Cannot change the case sensitiveness of ~."
#~ msgstr "No es posible cambiar las mayúsculas/minúsculas de ~."

#, fuzzy
#~ msgid "~: ~ is not using ~"
#~ msgstr "Esto no es una cadena: ~"

#~ msgid "~: ~ is not a valid index into ~"
#~ msgstr "~: ~ no es un índice válido en ~"

#~ msgid "~: ~ is not a record"
#~ msgstr "~: ~ no es un registro"

#, fuzzy
#~ msgid "~: length ~ should be of type ~"
#~ msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#~ msgid "~: ~ is not a structure of type ~"
#~ msgstr "~: ~ no es una estructura del tipo ~"

#, fuzzy
#~ msgid "~: Slot ~ of ~ has no value"
#~ msgstr "~: Una ranura de ~ no tiene valor"

#~ msgid "~: This is not a compiled closure: ~"
#~ msgstr "~: No se trata de una cerradura compilada: ~"

#~ msgid "~ is not a valid code-vector byte"
#~ msgstr "~ no es un byte CODE-VECTOR válido"

#, fuzzy
#~ msgid "~: invalid side-effect class ~ for function ~"
#~ msgstr "~S: especificación inválida de ranura y función de acceso: ~S"

#~ msgid "~: invalid code-vector ~"
#~ msgstr "~: CODE-VECTOR inválido ~"

#~ msgid "~: function ~ is too big: ~"
#~ msgstr "~: la función ~ es demasiado grande: ~"

#, fuzzy
#~ msgid "~: This is not a prototype of a generic function: ~"
#~ msgstr "~: Ésta no es una función genérica: ~"

#~ msgid "There are no sequences of type ~"
#~ msgstr "No hay secuencias del tipo ~"

#~ msgid "~: ~ should be an integer >=0, not ~"
#~ msgstr "~: ~ debe ser un entero >=0, no ~"

#~ msgid "~: ~ = ~ should not be greater than ~ = ~"
#~ msgstr "~: ~ = ~ no debe ser mayor que ~ = ~"

#~ msgid "~: the index should be a fixnum >=0, not ~"
#~ msgstr "~: el índice debe ser un número >=0 del tipo FIXNUM, no ~"

#~ msgid "~: bad length ~"
#~ msgstr "~: longitud incorrecta ~"

#~ msgid "~: size should be an integer >=0, not ~"
#~ msgstr "~: el tamaño debe ser un entero >=0, no ~"

#~ msgid "~: :update must not be specified without :initial-element"
#~ msgstr "~: no debe especificarse :update sin :initial-element"

#~ msgid "~: Must not specify both arguments to :TEST and :TEST-NOT"
#~ msgstr "~: Los argumentos :TEST y :TEST-NOT no deben tener valor simultáneamente"

#~ msgid "~: sequence ~ is too long"
#~ msgstr "~: la secuencia ~ es demasiado larga"

#~ msgid "too long sequence ~"
#~ msgstr "secuencia demasiado larga ~"

#~ msgid "~: the radix must be an integer between 2 and 36, not ~"
#~ msgstr "~: la base debe ser un entero entre 2 y 36, no ~"

#~ msgid "~: the code argument should be an integer, not ~"
#~ msgstr "~: el argumento del código debe ser un entero y no ~"

# "~: no se puede convertir ~ al tipo character"
#
# No sé si traducir la palabra character, puesto que es una palabra
# clave en Lisp. - lsg
#
# Yo ya había traducido este mensaje como:
#
# "~: ~ no puede convertirse a un carácter"
#
# Pero el tuyo me gusta mucho más, salvo que `character', puesto que es
# un término definido en el estándar Common Lisp, debe ir en mayúsculas
# - cll
#
#~ msgid "~: cannot coerce ~ to a character"
#~ msgstr "~: no se puede convertir ~ al tipo CHARACTER"

#~ msgid "~: the weight argument should be an integer, not ~"
#~ msgstr "~: el argumento de ponderación debe ser un entero, y no ~"

#~ msgid "~: argument should be an integer, not ~"
#~ msgstr "~: el argumento debe ser un entero, no ~"

#~ msgid "~: ~-index should be an integer, not ~"
#~ msgstr "~: el índice ~ debe ser un entero, no ~"

#~ msgid "~: index should be NIL or an integer, not ~"
#~ msgstr "~: el índice debe ser NIL o un entero, no ~"

#~ msgid "~: ~-index should be NIL or an integer, not ~"
#~ msgstr "~: el índice ~ debe ser NIL o un entero, no ~"

#~ msgid "~: index should not be negative: ~"
#~ msgstr "~: el índice no debe ser negativo: ~"

#~ msgid "~: ~-index should not be negative: ~"
#~ msgstr "~: el índice ~ no debe ser negativo: ~"

#~ msgid "~: index ~ should not be greater than the length of the string"
#~ msgstr "~: el índice ~ no debe ser mayor que la longitud de la cadena"

#~ msgid "~: ~-index ~ should not be greater than the length of the string"
#~ msgstr "~: el índice ~ = ~ no debe ser mayor que la longitud de la cadena"

#~ msgid "~: index ~ should be less than the length of the string"
#~ msgstr "~: el índice ~ debe ser menor que la longitud de la cadena"

#~ msgid "~: ~-index ~ should be less than the length of the string"
#~ msgstr "~: el índice ~ = ~ debe ser menor que la longitud de la cadena"

#, fuzzy
#~ msgid "~: :START-index ~ must not be greater than :END-index ~"
#~ msgstr "~: El índice :start ~ no debe ser mayor que el índice :end ~"

#, fuzzy
#~ msgid "~: argument ~ should be a string, a symbol or a character"
#~ msgstr "~: el argumento ~ debe ser del tipo string o string-char, o un símbolo"

#~ msgid "~: :start-index ~ must not be greater than :end-index ~"
#~ msgstr "~: El índice :start ~ no debe ser mayor que el índice :end ~"

#~ msgid "~: :start1-index ~ must not be greater than :end1-index ~"
#~ msgstr "~: El índice start1 ~ no debe ser mayor que el índice :end1 ~"

#~ msgid "~: :start2-index ~ must not be greater than :end2-index ~"
#~ msgstr "~: El índice :start2 ~ no debe ser mayor que el índice :end2 ~"

#~ msgid "~: the string length ~ should be nonnegative fixnum"
#~ msgstr ""
#~ "~: la longitud de la cadena de caracteres ~ debe ser un número no negativo\n"
#~ "del tipo FIXNUM"

#, fuzzy
#~ msgid "~: ~ argument ~ should be of type ~"
#~ msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#
# Duda: esta traducción ha sido muy difícil, y está basada en la
# traducción francesa que dice: "~: Mauvais mode de saut d'environnement
# ~."
#
#~ msgid "~: bad frame climbing mode ~"
#~ msgstr "~: modo de salto de marco incorrecto"

#~ msgid "~: ~ is not a stack pointer"
#~ msgstr "~: ~ no es un puntero de pila"

#~ msgid "~: ~ is not a pointer to an EVAL/APPLY frame"
#~ msgstr "~: ~ no es un puntero a un marco de tipo EVAL/APPLY"

#~ msgid "~: environment is not an alist"
#~ msgstr "~: el entorno no es una a-lista"

#~ msgid "~: unknown frame type"
#~ msgstr "~: tipo de marco desconocido"

#, fuzzy
#~ msgid "~: ~ comes from a previous Lisp session and is invalid"
#~ msgstr "~ proviene de una sesion anterior de Lisp y es inválido"

#, fuzzy
#~ msgid "~: ~ is not a list"
#~ msgstr "~: ~ no es un par"

#~ msgid "~: A true list must not end with ~"
#~ msgstr "~: Una auténtica lista no debe finalizar con ~"

# me comería el "y por ello", todo el mundo lo entenderá, y además no
# está en el original. sv
#
# No sólo eso, sino que además el mensaje queda demasiado largo. Ser
# mucho más cómodo, para quien esté trabajando, ver mensajes cortos,
# ... sugerencia aceptada. cll
#
#, fuzzy
#~ msgid "~: ~ is a constant, may not be used as a variable"
#~ msgstr "FUNCTION: ~ es una constante, no puede usarse como una variable"

# Duda: Nótese cómo la traducción dice `declararse SPECIAL'. Esto es
# así, porque en Common Lisp existe SPECIAL para declarar variables
# especiales. Por eso, si digo `declararse SPECIAL' estoy diciendo
# `declararse especial con SPECIAL', pero esto último me parece muy
# rebuscado, ¿o es lo correcto?
#
# La traducción es perfectamente fiel. Déjala así. sv
#
# Además, he quitado el "por ello". cll
#, fuzzy
#~ msgid "~: ~ is not a symbol, cannot be declared ~"
#~ msgstr "FUNCTION: ~ no es un símbolo, no puede declararse SPECIAL"

#, fuzzy
#~ msgid "~: ~ is not a vector"
#~ msgstr "~: ~ no es un registro"

#~ msgid "~: ~ may not be used as an environment"
#~ msgstr "~: ~ no puede usarse como un entorno"

#~ msgid "~: argument ~ should be a nonnegative fixnum"
#~ msgstr "~: el argumento ~ debe ser un número no negativo del tipo fixnum"

#, fuzzy
#~ msgid "~: ~ is not an integer"
#~ msgstr "~: ~ no es un par"

#, fuzzy
#~ msgid "~: ~ is not a non-negative integer"
#~ msgstr "~: ~ no es el nombre de una función"

#, fuzzy
#~ msgid "~: argument ~ is not a string"
#~ msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#, fuzzy
#~ msgid "~: argument ~ is neither a string nor an integer"
#~ msgstr "~: el argumento ~ no es un string"

#, fuzzy
#~ msgid "~: argument ~ is not a stream"
#~ msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#~ msgid "~: argument ~ should be a stream of type ~"
#~ msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#, fuzzy
#~ msgid "~: argument ~ is not a character set"
#~ msgstr "~: el argumento ~ no es un carácter"

#, fuzzy
#~ msgid "~: keyword arguments in ~ should occur pairwise"
#~ msgstr "EVAL/APPLY: los argumentos clave de ~ deben aparecer por pares"

#, fuzzy
#~ msgid "~: ~ marker ~ is not a symbol"
#~ msgstr "~: ~ no es un par"

#
# Yo pondría un guión entre argumento y clave. - lsg
#
# Hmm, o sea `argumento-clave'. No, no me gusta y de hecho, en el
# "Vocabulario bilingüe de términos técnicos" de "Lisp" (3ra edición) de
# Winston y Horn, los traductores al español ponen en la página 649:
#
# keyword arguments - argumentos clave
#
# sin guión por medio - cll
#
#~ msgid ""
#~ "~: illegal keyword/value pair ~, ~ in argument list.\n"
#~ "The allowed keywords are ~"
#~ msgstr ""
#~ "~: par argumento clave/valor inválido ~, ~ en la lista de argumentos.\n"
#~ "Los parámetros clave permitidos son ~"

#, fuzzy
#~ msgid "~: ~ is not a function"
#~ msgstr "~: ~ no es el nombre de una función"

#~ msgid "~: ~ is not a function name"
#~ msgstr "~: ~ no es el nombre de una función"

#, fuzzy
#~ msgid "EVAL/APPLY: Too many arguments (~ instead of at most ~) given to ~"
#~ msgstr "~: Demasiados argumentos (~ en vez de ~) para ~"

#, fuzzy
#~ msgid "~: Too many arguments (~ instead of at most ~) given to ~"
#~ msgstr "~: Demasiados argumentos (~ en vez de ~) para ~"

#, fuzzy
#~ msgid "EVAL/APPLY: Too few arguments (~ instead of at least ~) given to ~"
#~ msgstr "~: Muy pocos argumentos (~ en vez de, al menos, ~) para ~"

#, fuzzy
#~ msgid "~: Too few arguments (~ instead of at least ~) given to ~"
#~ msgstr "~: Muy pocos argumentos (~ en vez de, al menos, ~) para ~"

#~ msgid "~: ~ is not an 8-bit number"
#~ msgstr "~: ~ no es un número de 8 bits"

#~ msgid "~: ~ is not a 16-bit number"
#~ msgstr "~: ~ no es un número de 16 bits"

#~ msgid "~: ~ is not an 32-bit number"
#~ msgstr "~: ~ no es un número de 32 bits"

#~ msgid "~: ~ is not an 64-bit number"
#~ msgstr "~: ~ no es un número de 64 bits"

#~ msgid "~: ~ is not an `unsigned int' number"
#~ msgstr "~: ~ no es un número del tipo `unsigned int'"

#~ msgid "~: ~ is not an `int' number"
#~ msgstr "~: ~ no es un número del tipo `int'"

#~ msgid "~: ~ is not a `unsigned long' number"
#~ msgstr "~: ~ no es un número del tipo `unsigned long'"

#~ msgid "~: ~ is not a `long' number"
#~ msgstr "~: ~ no es un número del tipo `long'"

#~ msgid "~: ~ is not a single-float"
#~ msgstr "~: ~ no es un SINGLE-FLOAT"

#~ msgid "~: ~ is not a double-float"
#~ msgstr "~: ~ no es un DOUBLE-FLOAT"

#~ msgid "~: type of attribute ~ is unsupported"
#~ msgstr "~: el tipo de atributo ~ no está soportado"

#~ msgid "~: too large shift amount ~"
#~ msgstr "~: el tamaño del desplazamiento es muy grande ~"

#~ msgid "~: unidentifiable type!!!"
#~ msgstr "~: a¡tipo irreconocible!!!"

#~ msgid "~: type ~ does not correspond to a class"
#~ msgstr "~: el tipo ~ no se corresponde con una clase"

#~ msgid "~: ~ does not name a class"
#~ msgstr "~: ~ no es el nombre de una clase"

#~ msgid "~: ~ cannot be coerced to type ~"
#~ msgstr "~: ~ no puede convertirse al tipo ~"

#~ msgid "~: the property list of ~ has an odd length"
#~ msgstr "~: la lista de propiedades de ~ tiene longitud impar"

#~ msgid "~: the property list ~ has an odd length"
#~ msgstr "~: la lista de propiedades ~ tiene longitud impar"

#~ msgid "~: ~ is not a system function"
#~ msgstr "~: ~ no es una función del sistema"

#~ msgid "~: index ~ is negative"
#~ msgstr "~: el índice ~ es negativo"

#~ msgid "~: invalid argument ~"
#~ msgstr "~: el argumento ~ es inválido"

#~ msgid "The value of *GENSYM-COUNTER* was not a nonnegative integer. Old value ~. New value ~."
#~ msgstr "El valor de *GENSYM-COUNTER* no era un entero no negativo. Valor anterior ~. Nuevo valor ~."

#~ msgid "~: argument should be a positive fixnum, not ~"
#~ msgstr "~: el argumento debe ser un número positivo del tipo FIXNUM, no ~"

#, fuzzy
#~ msgid "~: ~ is not a number"
#~ msgstr "~: ~ no es un número de 8 bits"

#, fuzzy
#~ msgid "~: ~ is not a real number"
#~ msgstr "~: ~ no es un número del tipo `long'"

#, fuzzy
#~ msgid "~: ~ is not a floating-point number"
#~ msgstr "~: ~ no es un número del tipo `long'"

#, fuzzy
#~ msgid "~: ~ is not a rational number"
#~ msgstr "~: ~ no es un número del tipo `long'"

#, fuzzy
#~ msgid "~: the value of ~ should be a ~, not ~"
#~ msgstr "~: el valor de ~ debe ser un RANDOM-STATE, no ~"

#~ msgid "~: argument should be positive and an integer or float, not ~"
#~ msgstr "~: el argumento debe ser un número positivo del tipo INTEGER o FLOAT, no ~"

#~ msgid "not a 32-bit integer: ~"
#~ msgstr "no es un entero de 32 bits: ~"

#~ msgid "not a 64-bit integer: ~"
#~ msgstr "no es un entero de 64 bits: ~"

#~ msgid "~: ~ is not a valid boolean operation"
#~ msgstr "~: ~ no es una operación lógica válida"

# Duda: En Lisp existe un tipo predeterminado: `fixnum'. Por ese motivo,
# dejo sin traducir este término.
#
#~ msgid "The arguments to BYTE must be fixnums >=0: ~, ~"
#~ msgstr "Los argumentos de BYTE deben ser números enteros del tipo FIXNUM >=0: ~, ~"

#~ msgid "~ is not a BYTE specifier"
#~ msgstr "~ no es un especificador de BYTE"

#~ msgid "quotient ~ / ~ is not an integer"
#~ msgstr "el cociente ~ / ~ no es un entero"

#~ msgid "~: Unsupported call mechanism: ~"
#~ msgstr "~: mecanismo de llamado no soportado: ~"

#~ msgid "~: Bad function prototype: ~"
#~ msgstr "~: Prototipo de función incorrecto: ~"

#~ msgid "~: Wrong number of arguments for prototype ~"
#~ msgstr "~: número incorrecto de argumentos para el prototipo ~"

#~ msgid "~: Bad argument for prototype ~: ~"
#~ msgstr "~: Argumento incorrecto para el prototipo ~: ~"

#~ msgid "~: Bad argument: ~"
#~ msgstr "~: El argumento ~ es inválido"

#~ msgid "~: ~ is not a valid address"
#~ msgstr "~: ~ no es una dirección válida"

#, fuzzy
#~ msgid "~: argument is not a foreign object: ~"
#~ msgstr "~: el argumento no es una variable extranjera: ~"

#, fuzzy
#~ msgid "~: argument ~ should be a ~, ~ or ~"
#~ msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#, fuzzy
#~ msgid "~: cannot resurrect the zombie ~"
#~ msgstr "~: no se puede escribir en ~"

#~ msgid "~ cannot be converted to the foreign type ~"
#~ msgstr "~ no puede ser compartido al tipo extranjero ~"

#~ msgid "64 bit integers are not supported on this platform and with this C compiler: ~"
#~ msgstr "los enteros de 64 bits no están soportados en esta arquitectura, para este compilador de C:"

#~ msgid "~ cannot be converted to a foreign function with another calling convention."
#~ msgstr "~ no puede ser convertido a una función extranjera con otra convención de llamada."

#, fuzzy
#~ msgid "~: element type has size 0: ~"
#~ msgstr "el tipo del elemento tiene tamaño 0: ~"

#~ msgid "~: argument is not a foreign variable: ~"
#~ msgstr "~: el argumento no es una variable extranjera: ~"

#~ msgid "~: foreign variable with unknown type, missing DEF-C-VAR: ~"
#~ msgstr "~: variable externa de tipo desconocido, se ha omitido DEF-C-VAR: ~"

#~ msgid "A foreign variable ~ does not exist"
#~ msgstr "La variable extranjera ~ no existe"

#~ msgid "~: foreign variable ~ does not have the required size or alignment"
#~ msgstr "~: la variable externa ~ no tiene el tamaño o alineamiento requerido"

#~ msgid "~: type specifications for foreign variable ~ conflict: ~ and ~"
#~ msgstr "~: conflicto de especificación de tipo de la variable extranjera ~: ~ y ~"

#~ msgid "~: foreign variable ~ may not be modified"
#~ msgstr "~: no se puede modificar la variable externa ~"

#~ msgid "~: foreign variable ~ of type ~ is not an array"
#~ msgstr "~: la variable externa ~ del tipo ~ no es una matriz"

#~ msgid "~: foreign variable ~ of type ~ is not a pointer"
#~ msgstr "~: la variable externa ~ del tipo ~ no es un puntero"

#~ msgid "~: foreign variable ~ of type ~ is not a struct or union"
#~ msgstr "~: la variable externa ~ del tipo ~ no es, ni una estructura, ni una unión"

#~ msgid "~: foreign variable ~ of type ~ has no component with name ~"
#~ msgstr "~: la variable externa ~ del tipo ~ no tiene ningún componente con el nombre ~"

#~ msgid "~: foreign variable ~ does not have the required alignment"
#~ msgstr "~: la variable externa ~ no tiene el alineamiento requerido"

#~ msgid "~: argument is not a foreign function: ~"
#~ msgstr "~: el argumento no es una función extranjera: ~"

#~ msgid "~: foreign function with unknown calling convention, missing DEF-CALL-OUT: ~"
#~ msgstr "~: función externa con convención de llamada desconocida, se ha omitido DEF-CALL-OUT: ~"

#~ msgid "~: illegal foreign function type ~"
#~ msgstr "~: tipo de función externa inválido ~"

#~ msgid "~: A foreign function ~ does not exist"
#~ msgstr "~: La función extranjera ~ no existe"

#~ msgid "~: calling conventions for foreign function ~ conflict"
#~ msgstr "~: conflicto en la convención de llamada de la función externa ~"

#, fuzzy
#~ msgid "~: Cannot open library ~: ~"
#~ msgstr "~: No se puede abrir la biblioteca ~"

#~ msgid "~: Cannot open library ~"
#~ msgstr "~: No se puede abrir la biblioteca ~"

#, fuzzy
#~ msgid "~: no dynamic object named ~ in library ~"
#~ msgstr "~: No se puede abrir la biblioteca ~"

#~ msgid "~: ~ is not a library"
#~ msgstr "~: ~ no es una biblioteca"

#, fuzzy
#~ msgid "symbol ~SA from ~SA will become a shadowing symbol"
#~ msgstr "el símbolo ~SA del paquete #<PACKAGE ~SA> se convertirá en un símbolo que eclipsa a otro"

#
# A ver aquí, que hay mogollón, hay mogollón, ...
#
# Leo, tu opinas que aquí deberíamos traducir:
#
# "variables con vinculación de recintos (~S = dinámicamente):"
#
# Sin embargo, yo creo que lo más correcto es:
#
# "trama de ligadura de las variables (~S = dinámicamente):"
#
# Puesto que esto se refiere al tipo de tramas que hay en la pila,
# cuando ésta está siendo examinada. De hecho, la traducción francesa
# es:
#
# "Le «frame» de liaison de variables (~S signifiant dynamique) lie :"
#
# ..., que viene a ser algo como lo que he puesto yo. - cll
#
#~ msgid "frame binding variables (~S = dynamically):"
#~ msgstr "marco de ligadura de las variables (~S = dinámicamente):"

#~ msgid " binds (~S = dynamically):"
#~ msgstr " vincula (~S = dinámicamente):"

#, fuzzy
#~ msgid "~Sa: redefining ~Sa ~Ss in ~Sa, was defined in ~Sa"
#~ msgstr "~SS: redefiniendo ~SS; ¡estaba siendo rastreada!"

#, fuzzy
#~ msgid "Loading file ~SA ..."
#~ msgstr "Cargando el fichero \""

#, fuzzy
#~ msgid "Loaded file ~SA"
#~ msgstr "Cargando el fichero \""

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# No tengo ni idea de qué significa ese "0*"
#~ msgid "~S0*It will be ignored."
#~ msgstr "Será ignorado."

#, fuzzy
#~ msgid "Loading logical hosts from file ~SA ..."
#~ msgstr "La carga del fichero "

#, fuzzy
#~ msgid "Defined logical host ~SA"
#~ msgstr "La carga del fichero "

#~ msgid "~SA must introduce a number."
#~ msgstr "~SA debe introducir un número."

#, fuzzy
#~ msgid "The closing format directive '~SA' does not have a corresponding opening one."
#~ msgstr "No existe una directiva de apertura para la de cierre `~SA'."

#, fuzzy
#~ msgid "The closing format directive '~SA' does not match the corresponding opening one. It should read '~SA'."
#~ msgstr "La directiva de cierre `~SA' no se corresponde con la de apertura. Debe leerse `~SA'."

#, fuzzy
#~ msgid "The ~S~S; format directive is not allowed at this point."
#~ msgstr "La directiva ~S~S; no está permitida aquí."

#, fuzzy
#~ msgid "The ~S~Snewline format directive cannot take both modifiers."
#~ msgstr "La directiva ~S~Snewline no puede tomar ambos modificadores."

# Ojo: Estos "ing" no son siempre gerundios.
# Tal vez sea simplemente "...; se esperaba '~SA'." sv
#
# Bueno, ..., cuando el mensaje ha salido es que se ha producido un
# error. En tal caso, no se puede estar `esper*ando*', sino que se
# esperaba, ... Si, creo que tienes toda la razón. cll
#
#, fuzzy
#~ msgid "An opening format directive is never closed; expecting '~SA'."
#~ msgstr "No se ha cerrado una directiva; se esperaba `~SA'."

#, fuzzy
#~ msgid "The argument for the ~S~SR format directive is too large."
#~ msgstr "El argumento de la directiva ~S~SR es demasiado grande."

#, fuzzy
#~ msgid "The ~S~S[ format directive cannot take both modifiers."
#~ msgstr "La directiva ~S~S[ no puede tomar ambos modificadores."

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#, fuzzy
#~ msgid "Wrote the memory image into ~SA"
#~ msgstr "No es el nombre de una función: ~SS"

#, fuzzy
#~ msgid "~Ss: ~Ss is not a function name"
#~ msgstr "~S: ~S no es el nombre de una función"

# Aquí también junto las exclamaciones. sv
#~ msgid "Compiler bug!! Occurred in ~SA~S@[ at ~SA~S]."
#~ msgstr "aError del compilador!! Ocurrió en ~SA~S@[ en ~SA~S]."

#~ msgid " in line ~SD"
#~ msgstr " en la línea ~SD"

#~ msgid " in lines ~SD..~SD"
#~ msgstr " en las líneas ~SD..~SD"

#
# Duda: He querido traducir la palabra `warning' por `aviso' que es como
# debería decirse en español, ¿no?. ¿Hay algún término adoptado en
# es@li.org, para esta palabra?.
#
# Sí, atención. sv
#
# Si, si, ya lo he hecho, ... En todas partes he puesto "WARNING" por
# "ATENCIÓN". No es exactamente lo mismo, pero me parece una sugerencia
# genial, de hecho me gusta muchísimo más que aquello de "AVISO:". De
# esta manera, parecía que te estaban hablando los "super-tacañones" :) - cll
#
# Sin embargo, Santiago, este caso es bastante peculiar. Verás, si dejo
# "ATENCIÓN" aquí, entonces, durante la compilación de un proyecto con
# varios ficheros en Lisp, podría salir, por ejemplo, un mensaje como el
# siguiente (tomado de un ejemplo real, que conste, ...):
#
# --------------
# ATENCIÓN en la función PROBLEMA~C~CESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
# Y yo pregunto, en este caso ¿no es mejor poner "ADVERTENCIA"? La
# verdad es que "ADVERTENCIA" me suena mucho mejor que "ATENCIÓN" y que
# "AVISO". En este caso, lo que se tendría es:
#
# --------------
# ADVERTENCIA en la función PROBLEMA~C~CESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
#
#, fuzzy
#~ msgid "WARNING~S@[ in ~SA~S]~SA :"
#~ msgstr "ADVERTENCIA~S@[ en la función ~SS~S]~SA :~S%"

#, fuzzy
#~ msgid "Function ~Ss is deprecated~S@[, use ~Ss instead~S]"
#~ msgstr "Función no implementada"

#
# Duda: ¡atención a la utilización de la directiva ~SP!
#
# La siguiente traducción funcionará si, para el caso del español (como
# para el alemán), se pasa el parámetro (eql *error-count* 1), en
# segundo lugar.
#
# Ya no hace falta. Tal y como está hecho no es necesario pasar ningún
# parámetro extra. Así funciona correctamente.
#
# Aquí dudo porque atención no es tan "pluralizable" como aviso. sv
#
# Claro, de hecho, a mí también me pasa lo mismo. He preferido cambiar
# la traducción de "aviso" por "advertencia", en este mensaje y en aquél
# en el que se sacan los mensajes del compilador. ¿No os suena muchísimo
# mejor esta segunda alternativa? - cll
#
#~ msgid "~SD error~S:P, ~SD warning~S:P"
#~ msgstr "~SD error~S:*~S[es~S;~S:;es~S], ~SD advertencia~S:P"

#~ msgid "Listing of compilation of file ~SA~S%on ~S@? by ~SA, version ~SA"
#~ msgstr "Listado de la compilación del fichero ~SA~S%el ~S@? por ~SA, versión ~SA"

#~ msgid "Compiling file ~SA ..."
#~ msgstr "Compilando el fichero ~SA ..."

#, fuzzy
#~ msgid "Wrote file ~SA"
#~ msgstr " de la fuente ~SS"

#, fuzzy
#~ msgid "service does not exist: ~SA/~SA"
#~ msgstr "el fichero ~S no existe"

#, fuzzy
#~ msgid "~SA is not a number. Try again."
#~ msgstr "~S: ~S no es un número de 8 bits"

#~ msgid "a label used for resolving #~SD# references during READ."
#~ msgstr "una etiqueta para resolver #~SD# referencias en READ."

# Nota: Caso brillante de la generación de mensajes diferentes gracias a las
#       directivas condicionales del Clisp (y del Common Lisp en general).
#
#, fuzzy
#~ msgid ", is accessible in ~S:d package~S:*~S[~S;~S:;s~S] ~S{~SA~S^, ~S}"
#~ msgstr " y es accesible desde ~S:[el paquete~S;los paquetes~S] ~S{~SA~S^, ~S}"

#, fuzzy
#~ msgid " (macro: ~Ss)"
#~ msgstr " (macro)"

#, fuzzy
#~ msgid ", value: ~Ss"
#~ msgstr " valores: "

#, fuzzy
#~ msgid "a~S:[~S; deprecated~S] function"
#~ msgstr "una función ~S:[interpret~S;compil~S]ada."

#, fuzzy
#~ msgid "a~S:[~S; deprecated~S] macro"
#~ msgstr "una función ~S:[interpret~S;compil~S]ada."

#~ msgid "on the ~S:[posi~S;nega~S]tive real axis"
#~ msgstr "en el eje real ~S:[posi~S;nega~S]tivo"

#~ msgid "on the ~S:[posi~S;nega~S]tive imaginary axis"
#~ msgstr "en el eje imaginario ~S:[posi~S;nega~S]tivo"

#, fuzzy
#~ msgid "in the ~S:[~S:[first~S;fourth~S]~S;~S:[second~S;third~S]~S] quadrant"
#~ msgstr "en el ~S:[~S:[primer~S;cuarto~S]~S;~S:[segundo~S;tercer~S]~S] cuadrante"

#~ msgid "It is a ~S:[non-~S;~S]printable character."
#~ msgstr "Se trata de un carácter ~S:[no ~S;~S]imprimible."

#~ msgid "a~S:[~S:[ closed ~S;n output-~S]~S;~S:[n input-~S;n input/output-~S]~S]stream."
#~ msgstr "un flujo ~S:[~S:[cerrado~S;de salida~S]~S;~S:[de entrada~S;de entrada/salida~S]~S]."

#~ msgid "the package named ~SA"
#~ msgstr "el paquete ~SA"

#, fuzzy
#~ msgid ". It has ~S:d nickname~S:*~S[~S;~S:;s~S] ~S{~SA~S^, ~S}"
#~ msgstr ". Tiene los apodos ~S{~SA~S^, ~S}"

#, fuzzy
#~ msgid "imports the external symbols of ~S:d package~S:*~S[~S;~S:;s~S] ~S{~SA~S^, ~S} and "
#~ msgstr "importa los símbolos externos de~S:[l paquete~S; los paquetes~S] ~S{~SA~S^, ~S} y "

#, fuzzy
#~ msgid "exports ~S[no symbols~S:;~S:*~S:d symbol~S:*~S[~S;~S:;s~S]~S]"
#~ msgstr "~S:[no exporta ningún símbolo~S;exporta los símbolos~S:*~S{~S<~S%~S:; ~SS~S>~S^~S}~S]"

#, fuzzy
#~ msgid " to ~S:d package~S:*~S[~S;~S:;s~S] ~S{~SA~S^, ~S}"
#~ msgstr " ~S:[al paquete~S;a los paquetes~S]: ~S{~SA~S^, ~S}"

# Este mensaje tiene una especial dificultad, porque de el deberían
# salir cosas del tipo: "una tabla de lectura" (con `tabla de lectura'
# al final del mensaje) o "la tabla de lectura de Common Lisp" (con
# `tabla de lectura' al principio).
#
# Afortunadamente, la situación puede salvarse sin ningún problema
# gracias a la directiva ~S:* de format
#
#~ msgid "~S:[a~S;the Common Lisp~S] readtable."
#~ msgstr "~S:[una~S;la~S] tabla de lectura~S:*~S:[~S; de Common Lisp~S]"

#~ msgid "a ~S:[~S;portable ~S]pathname~S:[.~S;~S:*, with the following components:~S{~SA~S}~S]"
#~ msgstr "una trayectoria~S:[~S; portátil~S]~S:[.~S;~S:*, constituída por: ~S{~SA~S}~S]"

#~ msgid "a~S:[~S; simple~S] ~SA dimensional array"
#~ msgstr "una matriz~S:[~S; simple~S] de dimensión ~SA"

#, fuzzy
#~ msgid " of ~SAs"
#~ msgstr " de ~S(~SA~S)s"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#, fuzzy
#~ msgid "~S%No methods."
#~ msgstr "~S%Sin ranuras."

#, fuzzy
#~ msgid "Argument list: ~S:S"
#~ msgstr "lista de argumentos: ~SS"

#, fuzzy
#~ msgid "Documentation: ~SA"
#~ msgstr "documentación: ~SA"

#, fuzzy
#~ msgid "Argument list: ~SA."
#~ msgstr "~S%lista de argumentos: "

#~ msgid "Bytes permanently allocated:   ~S9D~S%Bytes currently in use:        ~S9D~S%Bytes available until next GC: ~S9D"
#~ msgstr "Bytes permanentemente asignados:   ~S9D~S%Bytes actualmente en uso:        ~S9D~S%Bytes disponibles hasta el próximo GC: ~S9D"

#, fuzzy
#~ msgid "~S: ~S is not an output ~S"
#~ msgstr "~S: ~S no es un par"

#, fuzzy
#~ msgid "~S: argument ~S should be ~S."
#~ msgstr "~S: el argumento ~S debe ser un flujo"

#~ msgid "Please choose one of ~S:{~SA~S:^, ~S} ."
#~ msgstr "Por favor, elija uno/a de ~S:{~SA~S:^, ~S} ."

#, fuzzy
#~ msgid "Error: ~S~S:@> not implemented"
#~ msgstr "función no implementada"
